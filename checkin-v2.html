<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>checkin</title>
    <link rel="icon" href="data:;base64,=" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!--ä¸»é¢˜-->
    <style>
        #apps-notification {
            color: #1e3557;
            font-size: 60px;            /* ä¿æŒåŸæ¥çš„å¤§å­—å· */
            font-weight: 900;             /* æ›´ç²—ä¸€ç‚¹ï¼Œçœ‹èµ·æ¥æ›´å¤§ */
            line-height: 1.7;             /* ç´§å‡‘è¡Œé«˜ï¼Œè®©æ–‡å­—æ˜¾å¾—æ›´å¤§ */
            letter-spacing: 0.04em;       /* ç•¥å®½æ¾ï¼Œå¢åŠ è§†è§‰åšåº¦ */
            text-align: center;           /* å±…ä¸­æ˜¾ç¤º */

            padding: 20px 40px;           /* é€‚å½“åŠ å¤§å†…è¾¹è·ï¼Œè®©æ–‡å­—æœ‰å‘¼å¸ç©ºé—´ */
            border-radius: 14px;

            /* å…³é”®ï¼šçœŸå®è¾¹æ¡† */
            border: 2px solid #93c5fd;

            /* é˜´å½±æ•ˆæœ */
            box-shadow:
                0 8px 20px rgba(59, 130, 246, 0.18),
                inset 0 1px 0 rgba(255,255,255,0.6);

            display: inline-block;        /* è®©å…ƒç´ æ’‘å¼€ï¼Œä¸å—çˆ¶å…ƒç´ å½±å“ */
            
            animation:
                notify-shadow-breath 5s ease-in-out infinite,
                notify-text-breath 5s ease-in-out infinite;
        }

        /* æ–‡å­—é¢œè‰²å‘¼å¸ */
        @keyframes notify-text-breath {
            0%   { color: #1e3557; }
            50%  { color: #2563eb; }
            100% { color: #1e3557; }
        }

        /* é˜´å½±å‘¼å¸ */
        @keyframes notify-shadow-breath {
            0%   { box-shadow: 0 8px 20px rgba(59,130,246,0.18), inset 0 1px 0 rgba(255,255,255,0.6); }
            50%  { box-shadow: 0 12px 30px rgba(59,130,246,0.28), inset 0 1px 0 rgba(255,255,255,0.6); }
            100% { box-shadow: 0 8px 20px rgba(59,130,246,0.18), inset 0 1px 0 rgba(255,255,255,0.6); }
        }



         /* =================äººå‘˜åˆ—è¡¨ç­›é€‰æ¡† ================= */
        .chat-contact-type-private {
            display: flex;
            flex-direction: column;   /* âœ… çºµå‘æ’åˆ— */
            align-items: stretch;     /* âœ… æœç´¢æ¡†æ’‘æ»¡å®½åº¦ */
            gap: 4px;
        }


        .chat-contact-search {
            margin-top: 4px;
            background: rgba(120, 180, 255, 0.08);
            border: 1px solid rgba(120, 180, 255, 0.25);
            color: #3a5f8a;
        }

        .chat-contact-search::placeholder {
            color: rgba(80, 130, 180, 0.6);
        }



        .chat-contact-search:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .chat-contact-title {
            position: relative;
            padding-left: 10px;
            font-size: 13px;
            font-weight: 600;
            color: #4a84c4; /* æ·¡è“ä¸»è‰² */
            letter-spacing: 0.5px;
            line-height: 1.2;
        }

        .chat-contact-title::before {
            content: "";
            position: absolute;
            left: 0;
            top: 1px;
            bottom: 1px;
            width: 3px;
            border-radius: 2px;
            background: linear-gradient(
                to bottom,
                rgba(120, 180, 255, 0.9),
                rgba(120, 180, 255, 0.4)
            );
        }

        /* ================= é™„ä»¶åˆ—è¡¨ ================= */
        /* ===== åœ¨çº¿æˆå‘˜ & é™„ä»¶åˆ—è¡¨å­—ä½“å¢å¼º ===== */
        /* ===== åœ¨çº¿æˆå‘˜ + é™„ä»¶ï¼šæ•´ä½“æµ…è“åº• ===== */
        .e_msgflow_mark_onlineusers {
            background-color: rgba(0, 123, 255, 0.06);  /* æµ…è“ä¸»é¢˜åº•è‰² */
        }

        /* é™„ä»¶è¡Œ hoverï¼Œå’Œæˆå‘˜ä¸€è‡´ */
        .cap-item:hover {
            background-color: rgba(0, 123, 255, 0.10);
        }

        .online-users-attachments {
            border-top: 1px solid rgba(0, 123, 255, 0.15);
            margin-top: 6px;
            padding-top: 4px;
        }


        /* ä¸‹è½½æŒ‰é’®åˆ«æ˜¾å¾—åƒèš‚èš */
        .cap-item .download-btn {
            font-size: 12px;
            padding: 2px 6px;
        }


        /* ===== é™„ä»¶åˆ—è¡¨è¡Œ ===== */
        .cap-item {
            display: flex;
            align-items: flex-start;
            padding: 4px 2px;
            border-bottom: 1px solid #eee;
            word-break: break-all; /* æ–‡ä»¶åå¤ªé•¿è‡ªåŠ¨æ¢è¡Œ */
        }

        /* =====é™„ä»¶ä¸‹è½½è¿›åº¦æ¡ ===== */
        .progress-bar-wrapper {
            width: 100%;
            height: 6px; /* ä¸è¦å¤ªå° */
            background-color: #eee;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%; /* åˆå§‹å®½åº¦0 */
            height: 100%;
            background-color: #4caf50;
            transition: width 0.2s ease;
        }

        /* é™„ä»¶å‰ç¼€ï¼šğŸ“ é™„ä»¶ */
        .cap-prefix {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            color: #3b6fdc;          /* æµ…è“ä¸»é¢˜å‹å¥½ */
            font-size: 12px;
            white-space: nowrap;
        }

        .cap-main {
            flex: 1;
        }

        .cap-main .name {
            font-weight: 500;
            line-height: 1.3;
            margin-bottom: 2px;

            display: -webkit-box;
            -webkit-line-clamp: 2;      /* æœ€å¤šæ˜¾ç¤º 2 è¡Œ */
            -webkit-box-orient: vertical;
            overflow: hidden;

            word-break: break-all;      /* è¶…é•¿æ— åˆ†éš”ç¬¦ä¹Ÿèƒ½æ–­ */
        }


        .cap-main .cap-info {
            display: flex;
            flex-wrap: wrap;   /* æ¢è¡Œæ˜¾ç¤ºçŠ¶æ€å’ŒæŒ‰é’® */
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            color: #555;
        }

        .cap-main .cap-info .download-btn {
            padding: 2px 6px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .cap-icon {
            font-size: 13px;
        }


        /* æ–‡ä»¶åä¸è¦è¢«æŒ¤çˆ† */
        .cap-item .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ================= é€‰æ‹©æ¶ˆæ¯å‡ºç°èœå• ================= */

        /* é€‰ä¸­é«˜äº® */
        .chat-message-content-container.selected {
            outline: none;
            border-radius: 0; /* å¯é€‰ï¼Œçœ‹ä½ æ˜¯å¦éœ€è¦åœ†è§’ */
        }

        /* åº•éƒ¨æ“ä½œæ¡ */
        .chat-msg-actionbar {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        /* é»˜è®¤ï¼šä»–äººæ¶ˆæ¯ï¼Œæ“ä½œæ¡é å·¦ */
        .chat-message .chat-msg-actionbar {
            justify-content: flex-start;
        }

        /* è‡ªå·±æ¶ˆæ¯ï¼Œæ“ä½œæ¡é å³ */
        .chat-message.sent-by-me .chat-msg-actionbar {
            justify-content: flex-end;
        }

        /* æ“ä½œæ¡æŒ‰é’® */
        .chat-msg-actionbar button {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 6px;
            border: none;
            background: #f0f0f0;
            cursor: pointer;
        }

        .chat-msg-actionbar button:hover {
            background: #e0e0e0;
        }

        /* ç§»é™¤æŒ‰é’®ç‚¹å‡»æ—¶çš„è“è‰²è¾¹æ¡† */
        .chat-msg-actionbar button:focus {
            outline: none;
        }

        /* å¯é€‰ï¼šå¦‚æœæ“ä½œæ¡å®¹å™¨ä¹Ÿè¢«ç‚¹å‡»æ˜¾ç¤ºç„¦ç‚¹ */
        .chat-message-content-container:focus {
            outline: none;
        }

         /* ================= æ¶ˆæ¯å†’æ³¡ - é¡¶éƒ¨å³ä¸Šè§’ ================= */
        #chat-toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 99999;
            display: flex;
            flex-direction: column-reverse; /* æœ€æ–°æ¶ˆæ¯åœ¨ä¸Šæ–¹ */
            gap: 10px;
            pointer-events: none;
        }

        .chat-toast {
            pointer-events: auto;
            font-size: 15px;
            min-width: 260px;
            max-width: 320px;
            background: #1f1f1f;
            color: #fff;
            border-radius: 10px;
            padding: 12px 14px;
            box-shadow: 0 10px 30px rgba(0,0,0,.35);
            cursor: pointer;
            animation: toast-in 0.25s ease-out;
            opacity: 1; /* é»˜è®¤å¯è§ */
            transition: opacity 0.5s ease-out; /* æ·¡å‡ºè¿‡æ¸¡ */
        }

        /* å‘ä»¶äººåå­— */
        .chat-toast .sender {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 1.2em;
        }

        /* æ¶ˆæ¯å†…å®¹ */
        .chat-toast .content {
            font-size: 1em;
            opacity: 0.9;
            line-height: 1.4;
        }

        /* é¡¶éƒ¨å‘ä¸‹å¼¹å…¥ */
        @keyframes toast-in {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* æ·¡å‡ºåŠ¨ç”»ï¼Œå»¶è¿Ÿåœç•™ 3 ç§’å†å¼€å§‹æ·¡å‡º */
        .chat-toast.fade-out {
            animation: toast-out 0.8s forwards;
            animation-delay: 3s; /* å…ˆæ˜¾ç¤º 3 ç§’ï¼Œå†æ·¡å‡º */
        }

        @keyframes toast-out {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }


        /* AIæç¤ºæ¡† */
        .ai-alert-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }

        .ai-alert-modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .ai-alert-content {
            background: white;
            padding: 25px 35px;
            border-radius: 10px;
            text-align: center;
            max-width: 420px;
            font-size: 1.25rem; /* å­—ä½“å¤§ */
            font-weight: 600;
            box-shadow: 0 6px 20px rgba(0,0,0,0.35);
            transform: scale(0.8);
            transition: transform 0.25s ease;
        }

        .ai-alert-modal.show .ai-alert-content {
            transform: scale(1);
        }

        .ai-alert-content p {
            margin-bottom: 20px;
        }

        .ai-alert-content button {
            padding: 10px 25px;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 6px;
            border: none;
            background-color: #1e90ff;
            color: white;
            transition: background-color 0.2s;
        }

        .ai-alert-content button:hover {
            background-color: #0d6efd;
        }


        /* å†™å­—æ¿æ•´ä½“ */
        /* =================å†™å­—ç¬”ç²— ================= */
        .brush-size {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1rem;
            margin-right: auto; /* æ¨åˆ°å·¦ä¾§ */
        }

        .chat-writeboard-size {
            width: 120px;
        }
        /* Header */
        .chat-writeboard-header {
            display: flex;
            justify-content: space-between; /* å·¦å³åˆ†å¼€ */
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }

        /* æ ‡é¢˜æ–‡å­— */
        .chat-writeboard-title {
            font-size: 1.2rem;
            font-weight: 500;
        }

        /* å…³é—­æŒ‰é’®å›ºå®šå³ä¸Š */
        .chat-writeboard-close {
            background: transparent;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #333;
        }

        .chat-writeboard {
            position: fixed;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }


        /* éšè—çŠ¶æ€ */
        .chat-writeboard.hidden {
            display: none;
        }

        /* åŠé€æ˜é®ç½©ï¼Œä¸æ‹¦æˆªé¼ æ ‡ */
        .chat-writeboard-mask {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.4); /* åŠé€æ˜é»‘è‰² */
            pointer-events: none;         /* ä¸é˜»æŒ¡é¼ æ ‡ */
            z-index: 0;                   /* ä¿è¯åœ¨é¢æ¿ä¸‹é¢ */
        }


        /* é¢æ¿ï¼šåŠå±ï¼Œé«˜åº¦å 50% */
        .chat-writeboard-panel {
            position: relative;     /* ç›¸å¯¹å®šä½ */
            display: flex;
            flex-direction: column;
            width: 95%;
            max-width: 1000px;
            height: 75%;            /* åŠå±é«˜åº¦ */
            background: #fff;
            border-radius: 8px;
            overflow: hidden;       /* é˜²æ­¢å†…å®¹æº¢å‡º */
            z-index: 1;             /* é«˜äºé®ç½© */
            box-shadow: 0 4px 16px rgba(0,0,0,0.3); /* è§†è§‰è¾¹ç¼˜ */
        }


        /* Canvas å ç”¨å‰©ä½™ç©ºé—´ */
        .chat-writeboard-canvas {
            flex: 1;           
            min-height: 100px; 
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        /* æŒ‰é’®åŒºåŸŸå›ºå®šæ˜¾ç¤º */
        .chat-writeboard-actions {
            flex: 0 0 auto;    
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 12px 16px;
            border-top: 1px solid #eee;
        }

        /* æŒ‰é’®å­—ä½“å¤§ */
        .chat-writeboard-actions button {
            font-size: 1.2rem;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            background-color: #007aff;
            color: #fff;
            border: none;
        }

        /* æ¸…ç©ºæŒ‰é’®å•ç‹¬çº¢è‰² */
        .chat-writeboard-actions button.clear-btn {
            background-color: #ff4d4f;
        }


        /*CSS æ‹–æ‹½æ‰‹æŸ„*/
        .chat-writeboard-resizer {
            position: absolute;
            width: 16px;
            height: 16px;
            right: 0;
            bottom: 0;
            cursor: se-resize;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            z-index: 2;
        }

        /* ä»…å›¾ç‰‡çŠ¶æ€ span */
        .chat-message-content-rect span.mcr-status {
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700; /* åŠ ç²— */
            display: inline-block;
            transition: all 0.2s;
        }

        /* ä¸‹è½½ä¸­ / è§£å¯†ä¸­ å°ç‚¹é—ªçƒ */
        .mcr-status.status-download::after,
        .mcr-status.status-encrypted::after {
            content: "";
            display: inline-block;
            width: 6px;
            height: 6px;
            margin-left: 4px;
            border-radius: 50%;
            background-color: currentColor;
            animation: blink 1s infinite;
        }

        /* é—ªçƒå…³é”®å¸§ */
        @keyframes blink {
            0%, 20%, 50%, 80%, 100% { opacity: 0; transform: translateY(0); }
            10%, 30%, 60%, 90% { opacity: 1; transform: translateY(-2px); }
        }

        /* å·²å°±ç»ª */
        .mcr-status.status-ready {
            color: #28a745;
            background: #e6ffe6;
        }

        /* ä¸‹è½½ / ä¸Šä¼  / è§£å¯†ä¸­ */
        .mcr-status.status-download { 
            color: #007bff; 
            background: #e6f0ff;
        }

        .mcr-status.status-encrypted { 
            color: #6f42c1; 
            background: #f0e6ff;
        }

        /* é”™è¯¯ */
        .mcr-status.status-error { 
            color: #dc3545; 
            background: #ffe6e6;
        }



		/*å€™é€‰è¯é¢æ¿*/
		.chat-candidate-panel {
			position: fixed;
			left: 0;
			right: 0;
			bottom: 0;

			height: 45vh;
			background: #fff;
			border-top: 1px solid #ddd;
			box-shadow: 0 -4px 12px rgba(0,0,0,.15);

			display: flex;
			flex-direction: column;
			z-index: 9999;
		}

		.chat-candidate-panel.hidden {
			display: none;
		}

		
		.chat-candidate-panel-header {
			height: 48px;
			display: flex;
			align-items: center;
			padding: 0 6px;
			border-bottom: 1px solid #eee;
			gap: 8px;
		}

        /* æ¸…ç©º & ç¡®å®šæŒ‰é’®å­—ä½“å˜å¤§ */
        .chat-writeboard-actions button {
            font-size: 1.2rem;       /* å­—ä½“æ›´å¤§ */
            padding: 8px 16px;       /* æŒ‰é’®æ›´æ˜¾çœ¼ */
            border-radius: 6px;
            cursor: pointer;
            background-color: #007aff;
            color: #fff;
            border: none;
            transition: background 0.2s;
        }

        .chat-writeboard-actions button:hover {
            background-color: #005bb5;
        }

        /* å¯é’ˆå¯¹â€œæ¸…ç©ºâ€æŒ‰é’®å•ç‹¬è®¾ç½®é¢œè‰² */
        .chat-writeboard-actions button.clear-btn {
            background-color: #ff4d4f;
        }

        .chat-writeboard-actions button.clear-btn:hover {
            background-color: #c0392b;
        }

		/* ç¿»é¡µæŒ‰é’® */
		.chat-candidate-panel-prev,
		.chat-candidate-panel-next {
			flex: 0 0 80px;         /* å›ºå®šå®½åº¦ 70pxï¼Œä¸è¢«å‹æ‰ */
			height: 36px;
			font-size: 15px;
			font-weight: bold;
			line-height: 36px;      /* æ–‡å­—å‚ç›´å±…ä¸­ */
			text-align: center;
			background-color: #3399ff;
			color: #fff;
			border: none;
			border-radius: 6px;
			cursor: pointer;
		}


		.chat-candidate-panel-prev:hover,
		.chat-candidate-panel-next:hover {
			background-color: #1a75ff; /* æ‚¬åœåŠ æ·± */
		}


		.chat-candidate-panel-prev:disabled,
		.chat-candidate-panel-next:disabled {
			background: #ddd;
			cursor: not-allowed;
		}

		
		/* ğŸ”¥ ç­›é€‰è¾“å…¥æ¡†æ ·å¼ */
		.chat-candidate-panel-filter {
			flex: 1;                /* å å‰©ä½™ç©ºé—´ï¼Œè‡ªé€‚åº” */
			padding: 6px 10px;
			font-size: 16px;
			background-color: #e6f2ff;
			border: 2px solid #3399ff;
			border-radius: 6px;
			outline: none;
			color: #000;
			box-sizing: border-box;
		}

		.chat-candidate-panel-filter:focus {
			border-color: #0066cc;       /* èšç„¦æ—¶æ·±è“è‰² */
			background-color: #cce6ff;   /* èšç„¦èƒŒæ™¯åŠ æ·± */
		}



		.chat-candidate-panel-filter::placeholder {
			color: rgba(0,0,0,0.4);
		}


		.chat-candidate-panel-prev:hover,
		.chat-candidate-panel-next:hover,
		.chat-candidate-panel-close:hover {
			background: #e0e0e0;
		}


		.chat-candidate-panel-body {
			flex: 1;
			overflow-y: auto;
			padding: 8px;

			display: grid;                             /* ğŸ”¥ å…³é”® */
			grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
			gap: 8px;
		}


		.chat-candidate-item {
			padding: 10px 6px;
			text-align: center;
			border-radius: 6px;
			cursor: pointer;
			background: #f7f7f7;
			user-select: none;
		}

		.chat-candidate-item:hover {
			background: #eaeaea;
		}



		/* ===== è½¬å‘ç»™æ‰€æœ‰äºº ===== */
		.fmic-forward-all-wrap {
			margin-bottom: 12px;
			padding: 10px 12px;
			border-radius: 8px;
			background: linear-gradient(135deg, #f0f6ff, #e6f0ff);
			border: 1px solid #c9ddff;
		}

		.fmic-forward-all {
			display: flex;
			align-items: center;
			gap: 8px;
			font-weight: 600;
			font-size: 14px;
			cursor: pointer;
		}

		.fmic-forward-all input {
			transform: scale(1.15);
		}

		.fmic-forward-all-text {
			color: #2b6de5;
		}

		.fmic-forward-all-desc {
			margin-left: 22px;
			margin-top: 4px;
			font-size: 12px;
			color: #6b7a99;
		}

        /* å€™é€‰è¯å®¹å™¨ */
        .chat-session-inputarea-candidates {
            position: absolute;
            bottom: calc(100% + 12px);  /* ç¦»è¾“å…¥æ¡†ç¨è¿œä¸€ç‚¹ */
            left: 12px;
            right: 12px;

            background: #ffffff;
            border: 1px solid #ccc;        /* è¾ƒæ˜æ˜¾è¾¹æ¡† */
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2); /* æ›´æ¸…æ™°é˜´å½± */

            display: flex;
            flex-wrap: nowrap;
            gap: 12px;              /* å€™é€‰è¯é—´è·æ›´å¤§ */
            
            padding: 10px;          /* å†…è¾¹è·å¢åŠ ï¼Œæ»šåŠ¨æ¡ä¸é®æŒ¡ */
            max-height: 120px;      /* å¢é«˜ä¸€äº›ï¼Œæ›´èˆ’æœ */
            overflow-x: auto;
            overflow-y: hidden;
            scroll-behavior: smooth;

            z-index: 9999;
        }

        /* éšè—çŠ¶æ€ */
        .chat-session-inputarea-candidates.hidden {
            display: none;
        }

        /* å•ä¸ªå€™é€‰è¯ */
        .chat-session-inputarea-candidate-item {
            flex: 0 0 auto;
            padding: 8px 14px;         /* å†…è¾¹è·å¢åŠ ï¼Œæ›´å®¹æ˜“ç‚¹å‡» */
            cursor: pointer;
            border-radius: 8px;
            font-size: 16px;            /* å­—ä½“åŠ å¤§ */
            font-weight: 600;           /* ç¨å¾®åŠ ç²— */
            color: #333;                /* å­—ä½“é¢œè‰²æ›´æ¸…æ™° */
            background: #f0f0f0;        /* èƒŒæ™¯è‰²ç¨æ·±ï¼Œå¢å¼ºå¯¹æ¯” */
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        /* æ‚¬åœæ•ˆæœ */
        .chat-session-inputarea-candidate-item:hover {
            background: #cce0ff;        /* è“è‰²é«˜äº®ï¼Œæ›´æ˜æ˜¾ */
            color: #000;
        }


        /* ç½‘ç›˜å’ŒèŠå¤©ä¸»é¡µé¢å¸ƒå±€ å·¦å³å¸ƒå±€ï¼ˆç½‘ç›˜å·¦ï¼ŒèŠå¤©å³ï¼‰*/

        /* =========================
           å·¦å³ä¸»å…¥å£å¸ƒå±€
        ========================= */
        .apps-item-row {
            display: flex;
            gap: 50px;
        }

        /* =========================
           ä¸»æŒ‰é’®åŸºç¡€æ ·å¼
        ========================= */
        .main-app {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;

            border-radius: 22px !important;   /* åœ†è§’ */
            overflow: hidden;                  /* å¿…é¡»ï¼Œé˜²æ­¢å†…é˜´å½±/å†…å®¹æŒ¡ä½åœ†è§’ */

            padding: 18px 20px;
            cursor: pointer;

            background: var(--bg-less);
            border: 2px solid rgba(147, 197, 253, 0.35);

            /* box-shadow ç”¨äºåœ†è§’æ˜¾ç¤º */
            box-shadow:
                0 6px 16px rgba(0, 0, 0, 0.18);
            
            /* ç§»é™¤ inset é˜´å½±ï¼Œå¦åˆ™åœ†è§’è¾¹ç¼˜è§†è§‰è¢«å‹å¹³ */
            /* inset 0 1px 0 rgba(255,255,255,0.45); */
        }



        /* =========================
           Hoverï¼ˆä¸ä½ç§»ï¼Œåªé è´¨æ„Ÿï¼‰
        ========================= */
        .main-app:hover {
            background: rgba(147, 197, 253, 0.12);
            border-color: rgba(147, 197, 253, 0.55);

            box-shadow:
                0 8px 20px rgba(59, 130, 246, 0.18),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
        }


        /* =========================
           ç½‘ç›˜ï¼ˆæ¬¡çº§å…¥å£ï¼‰
        ========================= */
        #apps-item-drive {
            flex: 1;
        }


        #apps-item-drive .apps-item-name {
            font-size: 20px;
            font-weight: 700;
            color: var(--fc-less);
        }


        /* =========================
           èŠå¤©ï¼ˆä¸»å…¥å£ï¼‰
        ========================= */
        @keyframes chat-text-breath {
            0%   { color: var(--c-thick-blue); }
            50%  { color: #3b82f6; }
            100% { color: var(--c-thick-blue); }
        }

        @keyframes chat-border-breath {
            0% {
                border-color: rgba(147,197,253,0.35);
                box-shadow:
                    0 6px 16px rgba(59,130,246,0.16),
                    inset 0 1px 0 rgba(255,255,255,0.45);
            }
            50% {
                border-color: rgba(147,197,253,0.6);
                box-shadow:
                    0 10px 22px rgba(59,130,246,0.26),
                    inset 0 1px 0 rgba(255,255,255,0.55);
            }
            100% {
                border-color: rgba(147,197,253,0.35);
                box-shadow:
                    0 6px 16px rgba(59,130,246,0.16),
                    inset 0 1px 0 rgba(255,255,255,0.45);
            }
        }

        #apps-item-chat {
            animation: chat-border-breath 4s ease-in-out infinite;
        }

        #apps-item-chat .apps-item-name {
            font-size: 20px;
            font-weight: 650;
            animation: chat-text-breath 4s ease-in-out infinite;
        }


        .theme-dark .main-app {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(86, 172, 255, 0.35);

            box-shadow:
                0 6px 16px rgba(0, 0, 0, 0.45),
                inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        .theme-dark .main-app:hover {
            background: rgba(86, 172, 255, 0.12);
            border-color: rgba(86, 172, 255, 0.6);
        }

        /* æ•´ä½“è¾“å…¥è¡Œï¼šè¾“å…¥æ¡† + æŒ‰é’® */
        .chat-session-inputarea-textarea-row {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            padding: 8px 12px;              /* å†…è¾¹è· */
            background-color: #f0f6ff;      /* æµ…è“èƒŒæ™¯ */
            border-radius: 12px;            /* åœ†è§’ */
            box-shadow: 0 1px 4px rgba(0,0,0,0.08); /* è½»å¾®é˜´å½± */
        }

        /* è¾“å…¥æ¡† */
        .chat-session-inputarea-textarea {
            flex: 1;
            min-height: 40px;
            max-height: 200px;
            padding: 8px 12px;
            font-size: 16px;
            resize: none;
            box-sizing: border-box;

            border: 1px solid #c0d6f0;     /* æµ…è“è¾¹æ¡† */
            border-radius: 6px;
            background-color: #ffffff;      /* ç™½è‰²èƒŒæ™¯ï¼Œè®©è¾“å…¥æ–‡å­—æ¸…æ™° */
            color: #1a1a1a;                 /* æ–‡å­—é¢œè‰² */
            outline: none;                  /* å»æ‰é»˜è®¤è“è‰²è¾¹æ¡† */
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .chat-session-inputarea-textarea:focus {
            border-color: #82b1ff;          /* èšç„¦è¾¹æ¡†è“è‰² */
            box-shadow: 0 0 6px rgba(130,177,255,0.4); /* èšç„¦é˜´å½± */
        }

        /* å‘é€æŒ‰é’® */
        /* å‘é€æŒ‰é’®ï¼šç°ä»£æµ…è“/æš—é»‘è‡ªé€‚åº” */
        .chat-session-inputarea-sendbtn {
            flex-shrink: 0;
            min-width: 80px;
            height: 44px;
            padding: 0 20px;
            border-radius: 20px;
            border: none;

            font-size: 16px;
            font-weight: 600;
            color: #fff;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;

            /* é»˜è®¤æµ…è‰²ä¸»é¢˜æ¸å˜ */
            background: linear-gradient(135deg, #6ca0f7, #a3c2ff);
        }

        /* æµ…è‰²ä¸»é¢˜æ‚¬æµ®æ•ˆæœ */
        .chat-session-inputarea-sendbtn:hover:not(:disabled) {
            background: linear-gradient(135deg, #7ab0ff, #b5d4ff); /* æ›´äº®æ¸å˜ */
            box-shadow: 0 4px 12px rgba(100, 160, 247, 0.35);       /* æŸ”å’Œé˜´å½± */
            transform: translateY(-1px);                             /* å¾®æµ®åŠ¨ */
        }

        /* ç‚¹å‡»æ•ˆæœ */
        .chat-session-inputarea-sendbtn:active:not(:disabled) {
            transform: scale(0.96);                          /* ç‚¹å‡»å›å¼¹ */
            box-shadow: 0 2px 6px rgba(100, 160, 247, 0.25);
        }

        /* ç¦ç”¨çŠ¶æ€ï¼šæµ…è“ + æ¸å˜ + ä¸å¯ç‚¹å‡»æ„Ÿ */
        .chat-session-inputarea-sendbtn:disabled {
            background: linear-gradient(135deg, #a6c8ff, #c2d9ff); /* æµ…è“æ¸å˜ */
            color: #fff;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.6;                /* è§†è§‰ä¸Šæ˜¾å¾—ä¸å¯ç‚¹å‡» */
            filter: grayscale(20%);      /* å¯é€‰ï¼Œå¢åŠ ç¦ç”¨æ„Ÿ */
        }

        /* æš—é»‘ä¸»é¢˜è‡ªé€‚åº” */
        body.dark-mode .chat-session-inputarea-sendbtn {
            background: linear-gradient(135deg, #4f7fcf, #7099e0);
        }

        body.dark-mode .chat-session-inputarea-sendbtn:hover:not(:disabled) {
            background: linear-gradient(135deg, #5a8ee0, #81a7f2);
            box-shadow: 0 4px 12px rgba(90, 142, 224, 0.35);
            transform: translateY(-1px);
        }

        body.dark-mode .chat-session-inputarea-sendbtn:active:not(:disabled) {
            box-shadow: 0 2px 6px rgba(90, 142, 224, 0.25);
            transform: translateY(0);
        }



      .chatgpt-float {
            position: fixed;
            right: -75px;          /* å…³é”®ï¼šå…ˆè—åˆ°å³è¾¹ */
            top: 35%;
            bottom: auto;
            z-index: 9999;

            padding: 10px 14px;
            background: #10a37f;
            color: #fff;
            font-size: 14px;
            border-radius: 999px;
            text-decoration: none;
            box-shadow: 0 4px 12px rgba(0,0,0,.25);

            transition: right .25s ease, background .2s ease;
        }

        /* é¼ æ ‡ç§»åˆ°â€œå¯æ„ŸçŸ¥åŒºåŸŸâ€å°±å‡ºæ¥ */
        .chatgpt-float:hover {
            right: 20px;
            background: #0e8f6e;
        }


        /* é»˜è®¤äº® */
        :root {
            --bg-body: white;
            --fc-body: black;
            --fc-less: #1c1c1c;
            --fc-least: #000000aa;
            --c-thick-blue: #14589a;
            --c-thick-blue2: #0655b0;
            --bg-less: rgba(169, 169, 169, 0.15);
        }

        /* æš— */
        .theme-dark {
            --bg-body: rgb(63, 63, 63);
            --fc-body: rgb(240, 240, 240);
            --fc-less: rgb(220, 220, 220);
            --fc-least: rgb(180, 180, 180);
            --c-thick-blue: #56acff;
            --c-thick-blue2: #3293f3;
            --bg-less: rgba(169, 169, 169, 0.15);
        }

        .theme-dark button {
            background-color: rgb(53, 53, 53);
            color: rgb(240, 240, 240);
            border: 1px solid #555;
        }

        .theme-dark button:hover {
            background-color: rgb(63, 63, 63);
            border-color: #666;
        }

        .theme-dark button:active {
            background-color: rgb(43, 43, 43);
            border-color: #444;
        }

        .theme-dark input, .theme-dark select, .theme-dark textarea {
            background-color: rgb(53, 53, 53);
            color: rgb(240, 240, 240);
            border: 1px solid #555;
        }

        .theme-dark {
            scrollbar-color: #666 rgb(53, 53, 53);
        }

    </style>

    <!--å…¨å±€-->
    <style>
        .initiation_hidden {
            display: none !important;
        }

        .hidden {
            display: none !important;
        }

        .transparent {
            opacity: 0;
            pointer-events: none;
        }

        .no-width {
            width: 0 !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        .no-height {
            height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
        }

        html {
            height: 100%;

            /*height: 100vh;*/
            /*overflow: hidden;*/
        }

        body {
            background: var(--bg-body);
            color: var(--fc-body);
            font-family: Arial, sans-serif;
            margin: 0 0 0 0;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        span.flex-grow {
            display: inline-block;
            flex-grow: 1;
        }

    </style>

    <!--æœ‰ä¸‰è§’çš„æŒ‰é’®-->
    <style>
        .menu-btn {
            position: relative; /* ä¸ºäº†ä¼ªå…ƒç´ å®šä½ */
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
        }

        /* ä½¿ç”¨ä¼ªå…ƒç´ æ·»åŠ ä¸‰è§’ */
        .menu-btn::after {
            content: "";
            position: absolute;
            right: 6px; /* è·ç¦»å³è¾¹ */
            bottom: 6px; /* è·ç¦»åº•éƒ¨ */
            width: 0;
            height: 0;
            border-left: 5px solid transparent; /* å·¦è¾¹é€æ˜ */
            border-right: 5px solid transparent; /* å³è¾¹é€æ˜ */
            border-top: 5px solid var(--fc-least); /* ä¸Šè¾¹é»‘è‰²ä¸‰è§’ */
        }
    </style>

    <!--é¡¶éƒ¨èœå•æ -->
    <style>
        header {
            background: #2088ee33;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            padding-left: 8px;
            padding-right: 8px;
            padding-top: 2px;
            padding-bottom: 2px;

            margin-bottom: 8px;

        }

        header > button.selected {
            font-weight: bold;
            color: white !important;
            background: #2581d5dd !important;
        }

        header > button.selected:hover {
            background: #3e8fe7dd !important;
        }

        header > button.selected:active {
            background: #146dbbdd !important;
        }

        header > button {
            display: inline-block;
            padding: 8px 20px;
            font-size: 16px;
            color: var(--c-thick-blue) !important;
            background: transparent !important;
            transition: all 0.1s ease-in-out;
            border: 0 solid #3498db !important;
            border-radius: 0;
            cursor: pointer;
        }

        header > button:hover {
            background: rgba(0, 0, 0, 0.1) !important;
        }

        header > button:active {
            background: rgba(0, 0, 0, 0.24) !important;
        }

        header > button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

    </style>

    <!--å†…å®¹åŒºåŸŸ å…¨å±€-->
    <style>
        main {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex-grow: 1;
        }

        main > section:not(.active) {
            display: none !important;
        }

        main > section.active {
            flex-grow: 1;

            display: flex;
            flex-direction: row;

            height: 0;

        }

    </style>

    <!--ç™»å½•é¢æ¿-->
    <style>
        section#login-panel {
            display: flex;
            flex-direction: column;
            align-items: center;

            justify-content: start;
        }

        div#login-rect {
            background: #2088ee33;
            padding: 24px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: left;
            gap: 12px;
        }

        span#login-top-margin {
            height: 20%;
        }

        span#login-tip-user, span#login-tip-admin {
            text-align: center;
            user-select: none;
            opacity: 0.8;
        }

        button#login-btn {
            padding: 6px 6px;
            cursor: pointer;
        }

    </style>

    <!--åº”ç”¨åˆ—è¡¨ é¢æ¿-->
    <style>
        section#apps-panel {
            display: flex;
            flex-direction: column;

            justify-content: start;
        }

        div#apps-rect {
            padding: 24px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            gap: 16px;
            flex-grow: 1;
        }

        span#apps-top-margin {
            height: 0;
        }

        div.apps-item {
            background: #2088ee33;
            display: flex;
            padding: 4px 20px;
            font-size: 16px;
            color: var(--c-thick-blue);
            transition: all 0.1s ease-in-out;
            border: 0 solid #3498db;
            border-radius: 0;
            cursor: pointer;
            min-width: 140px;
            flex-direction: column;
        }

        div.apps-item:hover {
            background: #2088ee44;
        }

        div.apps-item:active {
            background: rgba(22, 100, 176, 0.4);
        }

        p.apps-item-name {
            align-self: center;
            font-size: 16px;
            user-select: none;
            white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œå’Œç©ºæ ¼ */
        }

    </style>

    <!--æ»šåŠ¨æ¡-->
    <style>
        .tiny-scrollbar {
            overflow: auto;
            /* Firefox */
            scrollbar-width: thin;
            /*scrollbar-color: rgba(0, 0, 0, .2) transparent;*/
        }

        /*!* Chrome / Safari / Edge *!*/
        /*.tiny-scrollbar::-webkit-scrollbar {*/
        /*    width: 6px;*/
        /*    height: 6px;*/
        /*}*/

        /*.tiny-scrollbar::-webkit-scrollbar-thumb {*/
        /*    background: rgba(0, 0, 0, .2);*/
        /*    border-radius: 3px;*/
        /*}*/

        /*.tiny-scrollbar::-webkit-scrollbar-thumb:hover {*/
        /*    background: rgba(0, 0, 0, .3);*/
        /*}*/


    </style>

    <!--é€šç”¨ å·¦å³åˆ†æ -->
    <style>

        .aside-left-wrap {
            display: flex;
            flex-direction: column;

            width: 160px; /* åˆå§‹å®½åº¦ */
            min-width: 100px; /* æœ€å°å®½åº¦ */
            max-width: 80%; /* æœ€å¤§å®½åº¦ */
            background-color: rgba(118, 181, 246, 0.15);
            border-radius: 4px;
        }

        .aside-left-wrap.fullscreen {
            width: 98% !important;
            max-width: 100%;
        }

        .aside-left {
            flex-grow: 1;
            overflow: auto;

            display: flex;
            flex-direction: column;

            padding-top: 16px;
            padding-bottom: 16px;
            gap: 10px;

        }

        .aside-right {
            flex: 1;
            overflow: auto;
            display: flex;
            padding: 8px;
        }

        .aside-right > div {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .aside-divider {
            width: 2px;
            cursor: col-resize;
            background-color: #9b9b9b66;
            user-select: none;

            margin: 8px 0 0 0;

        }

        .aside-divider:hover {
            background-color: #69696988;
        }


        .btn-back-to-left-aside {
            border: 0;
            width: 40px;
            height: 40px;
            font-size: 16px;
            background: transparent !important;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            border: none !important;

            display: none;
        }

        .btn-back-to-left-aside:hover {
            background: rgba(0, 0, 0, 0.1) !important;
        }

        .btn-back-to-left-aside:active {
            background: rgba(0, 0, 0, 0.24) !important;
        }

        @media only screen and (max-width: 767px) {
            .btn-back-to-left-aside {
                display: block;
            }
        }
    </style>

    <!--é€šç”¨ å·¦æ æŒ‰é’®åˆ—è¡¨-->
    <style>
        .aside-left > nav {
            margin: 0 10px 0 10px;
            background-color: #fff;
            padding: 4px;
            border-radius: 4px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
        }

        .theme-dark .aside-left > nav {
            background-color: rgb(63, 63, 63);
        }

        /* ol å»æ‰é»˜è®¤åºå·å’Œ padding */
        .nav-buttons {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        /* li é»˜è®¤æ ·å¼ï¼Œæ— èƒŒæ™¯ */
        .nav-buttons li {
            padding: 10px 15px;
            margin: 5px 0;
            border-radius: 2px;
            cursor: pointer;
            transition: background-color 0.1s, transform 0.1s;
            user-select: none;
        }

        /* é¼ æ ‡æ‚¬æµ®æ•ˆæœ */
        .nav-buttons li:hover {
            background-color: rgba(0, 123, 255, 0.15); /* æµ…è“è‰²æ‚¬æµ® */
        }

        /* é¼ æ ‡æŒ‰ä¸‹æ•ˆæœ */
        .nav-buttons li:active {
            background-color: rgba(0, 123, 255, 0.4); /* æ·±ä¸€äº› */
        }

        /* é€‰ä¸­çŠ¶æ€ */
        .nav-buttons li.active {
            background-color: rgba(0, 123, 255, 0.2);
            font-weight: bold;
            border: #2088ee 0 solid;
            border-radius: 2px;
            border-left-width: 4px;
        }

    </style>

    <!--å‘ä¿¡æŒ‰é’®-->
    <style>
        #new-mail-btn {
            padding: 10px 6px;
            margin: 0 24px 0 24px;
            cursor: pointer;
            transition: background-color 0.1s, transform 0.1s;
            user-select: none;
            border: 0 solid #3498db;
            border-radius: 4px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
            font-size: 16px;
            background: white;
        }

        #new-mail-btn:hover {
            background-color: rgba(24, 128, 255, 0.15);
        }

        #new-mail-btn:active {
            background-color: rgba(0, 123, 255, 0.2);
        }
    </style>

    <!--å‘å¸ƒä¸»é¢˜æŒ‰é’®-->
    <style>
        #new-discussion-btn {
            padding: 10px 6px;
            margin: 0 24px 0 24px;
            cursor: pointer;
            transition: background-color 0.1s, transform 0.1s;
            user-select: none;
            border: 0 solid #3498db;
            border-radius: 4px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
            font-size: 16px;
            background: white;
        }

        #new-discussion-btn:hover {
            background-color: rgba(24, 128, 255, 0.15);
        }

        #new-discussion-btn:active {
            background-color: rgba(0, 123, 255, 0.4);
        }
    </style>

    <!--æ¨¡ç³Šé®ç½©-->
    <style>
        .for-blur-mark {
            /*å¯¹äº é®ç½©çš„çˆ¶çº§ çš„è®¾ç½®*/
            position: relative; /* å…³é”®ï¼šè®© å­div ä»¥å®ƒä¸ºå®šä½åŸºå‡† */
            /*overflow: hidden; !* é˜²æ­¢ å­div æº¢å‡º *!*/

            /*overflow: visible;*/
        }

        div.blur-mark {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;

            position: absolute;
            inset: 0; /* ç­‰ä»·äº top:0; right:0; bottom:0; left:0; */
            z-index: 9;

            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }

        .theme-dark div.blur-mark {
            background: rgba(255, 255, 255, 0.1);
        }

    </style>

    <!--é®ç½©å†…å®¹ è½¬åœˆåŠ¨ç”»-->
    <style>
        .spinner-ring {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 6px solid rgba(0, 0, 0, 0.12); /* ç¯çš„èƒŒæ™¯æ¡ */
            border-top-color: #2563eb; /* åŠ¨æ€é¢œè‰²ï¼ˆå¯æ¢ï¼‰ */
            /* ä¸ºäº†æ›´åœ†æ»‘å¯ä»¥ç”¨ box-shadow å¾®è°ƒ */
            animation: spin 0.6s linear infinite;
        }

        .theme-dark .spinner-ring {
            border-top-color: #3d77ef;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

    </style>

    <!--é®ç½©å†…å®¹ æ–‡æœ¬æ¶ˆæ¯-->
    <style>
        div#message-mark-dialog {
            display: flex;
            flex-direction: column;
            align-items: center;

            justify-content: start;

            flex-grow: 1;
            height: 100%;
        }

        span#message-mark-top-margin {
            height: 20%;
        }

        span#message-mark-bottom-margin {
            height: 25%;
        }

        div#message-mark-rect {
            background: white;
            padding: 24px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: left;
            gap: 12px;

            /*position: absolute;*/
            /*flex-wrap: wrap;*/
            /*width: fit-content;*/
            max-width: calc(90vw - 48px - 16px - 10px); /* æœ€å¤§å®½åº¦ä¸è¶…è¿‡è§†å£ - padding - shadow - fit */
        }

        p#message-mark-text {
            text-align: center;
            opacity: 0.9;

            white-space: normal; /* å…è®¸æ­£å¸¸æ¢è¡Œ */
            word-wrap: break-word; /* åœ¨å•è¯å†…æ¢è¡Œï¼ˆæ—§æ ‡å‡†ï¼‰ */
            overflow-wrap: break-word; /* åœ¨éœ€è¦æ—¶å¼ºåˆ¶æ¢è¡Œï¼ˆæ–°æ ‡å‡†ï¼‰ */

            /*white-space: pre-wrap; !* ä¿ç•™ç©ºæ ¼ï¼Œä½†è‡ªåŠ¨æ¢è¡Œ *!*/
            /*word-break: keep-all; !* å°½é‡ä¿æŒå•è¯/å­—ç¬¦ä¸æ¢è¡Œ *!*/
            /*overflow-wrap: anywhere; !* å¿…è¦æ—¶æ‰åœ¨å•è¯å†…æ¢è¡Œ *!*/

        }

        button.message-mark-btn {
            padding: 6px 14px;
            cursor: pointer;
        }

        div#message-mark-btn-group {
            display: flex;
            flex-direction: row;
            justify-content: right;
            gap: 10px;
        }

    </style>

    <!--é®ç½©å†…å®¹ è¾“å…¥è¡¨å•-->
    <style>
        div#form-mark-dialog {
            display: flex;
            flex-direction: column;
            align-items: center;

            justify-content: start;

            flex-grow: 1;
            height: 100%;
        }

        span#form-mark-top-margin {
            height: 15%;
        }

        span#form-mark-bottom-margin {
            height: 25%;
        }

        div#form-mark-rect {
            background: white;
            padding: 24px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: left;
            gap: 12px;
        }

        button.form-mark-btn {
            padding: 6px 14px;
            cursor: pointer;
        }

        div#form-mark-btn-group {
            display: flex;
            flex-direction: row;
            justify-content: right;
            gap: 10px;
        }

        div#form-mark-input-group {
            display: flex;
            flex-direction: column;
            justify-content: left;
            gap: 4px;

            overflow-y: auto;
            max-height: 60vh;
        }

        div#form-mark-input-group > label {
            display: flex;
            flex-direction: row;
            justify-content: left;
            flex-wrap: nowrap;
            white-space: nowrap;
        }

        div#form-mark-input-group > label > *:first-child {
            margin-left: 4px;
        }

        div.form-mark-input-group {
            display: flex;
            flex-direction: column;
            justify-content: left;
            gap: 4px;

            border: #1c1c1c20 1px solid;
            border-radius: 4px;
            background: #1c1c1c05;
            padding: 6px;
            margin-bottom: 2px;
        }

        div.form-mark-input-group > label {
            display: flex;
            flex-direction: row;
            justify-content: left;
            flex-wrap: nowrap;
            white-space: nowrap;
        }

        div.form-mark-input-group > label > *:first-child {
            margin-left: 4px;
        }

        div.form-mark-input-group > label.form-mark-input-group-title {
            display: inline-block;
            font-size: 14px;
            font-weight: bold;
            margin: 0 0 2px 0;

        }

        div.form-mark-input-custom {
            display: flex;
            flex-direction: column;
            justify-content: left;
        }

        span#form-mark-input-title {
            display: inline-block;
            font-size: 16px;
            font-weight: bold;
            margin: 0 0 2px 0;
        }

        span.form-mark-input-multiselectbutton-value {
            margin: 0;
            padding: 0;
            color: var(--fc-least);
            font-size: 12px;
            user-select: none;
            margin-left: 4px;
        }

        span.form-mark-input-noticing {
            font-size: 14px;
            color: rgba(253, 25, 25, 0.9);
        }

    </style>

    <!--é®ç½©å†…å®¹ å›¾ç‰‡æŸ¥çœ‹-->
    <style>
        .image-mark-rect {
            flex-grow: 1;
            height: 100%;
            position: relative;

            overflow: hidden;
        }

        .image-mark-rect > img {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            user-select: none;
        }

        .image-mark-top-actions {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            display: flex;
            flex-direction: row;
            background: rgba(0, 0, 0, 0.1);
            min-height: 10px;
        }

        .image-mark-action-gap {
            flex-grow: 1;
        }

        .image-mark-top-actions > button {
            display: inline-block;
            padding: 8px 20px;
            font-size: 16px;
            background: transparent;
            transition: all 0.1s ease-in-out;
            border: none;
            border-radius: 0;
            cursor: pointer;
        }

        .image-mark-top-actions > button:hover {
            background: rgba(0, 0, 0, 0.15);
        }

        .image-mark-top-actions > button:active {
            background: rgba(0, 0, 0, 0.3);
        }

        .image-mark-top-actions > button.image-mark-top-actions-close {
            color: #dc1d1d;
        }


    </style>

    <!--é®ç½©å†…å®¹ æ‚¬æµ®çƒå¼¹å‡ºçª—å£-->
    <style>
        div#floatball-mark-dialog {
            display: flex;
            flex-direction: column;
            align-items: center;

            justify-content: start;

            flex-grow: 1;
            height: 100%;
        }

        span#floatball-mark-top-margin {
            height: 20%;
        }

        span#floatball-mark-bottom-margin {
            height: 25%;
        }

        div#floatball-mark-rect {
            background: white;
            padding: 14px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: left;
            gap: 6px;

            /*position: absolute;*/
            /*flex-wrap: wrap;*/
            /*width: fit-content;*/
            max-width: calc(90vw - 48px - 16px - 10px); /* æœ€å¤§å®½åº¦ä¸è¶…è¿‡è§†å£ - padding - shadow - fit */

            min-width: 300px;
        }

        div.floatball-mark-tabbar {
            display: flex;
            flex-direction: row;
            border: 0 solid #2088eeaa;
            border-bottom-width: 2px;
            padding: 0 4px;
        }

        div.floatball-mark-tabbar button {
            display: inline-block;
            padding: 6px 14px;
            /*font-size: 14px;*/
            background: transparent;
            transition: all 0.1s ease-in-out;
            border: 0 solid #3498db;
            border-radius: 0;
            cursor: pointer;

            text-align: left;

            font-size: 16px;
            color: var(--fc-less);
        }

        div.floatball-mark-tabbar button:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        div.floatball-mark-tabbar button:active {
            background: rgba(0, 0, 0, 0.24);
        }

        div.floatball-mark-tabbar button.active {
            font-weight: bold;
            /*color: #1574D1;*/
            background: #2088ee33;
        }

        div.floatball-mark-tabcontent {
            display: flex;
            overflow: auto;
            max-height: 60vh;
        }

        div.floatball-mark-tabcontent-settings {
            display: flex;
            flex-direction: column;
            gap: 4px
        }

        div.floatball-mark-tabcontent-settings label {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
        }

        div.floatball-mark-tabcontent-backtasks {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 2px;
        }

    </style>

    <!--æ‚¬æµ®çƒå¼¹å‡ºçª—å£ åå°ä»»åŠ¡-->
    <style>
        .backtask-rect {
            display: flex;
            flex-direction: row;
            gap: 6px;
            padding: 6px;
            width: calc(100% - 12px);
            border-radius: 2px;
        }

        .backtask-rect:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .backtask-name {
            margin: 0;
            padding: 0;
        }

        .backtask-status-text {
            margin: 0;
            padding: 0;
            color: var(--fc-least);
            font-size: 12px;
            user-select: none;
        }

        .backtask-progress-bar {
            width: 100%;
            background-color: white;
            border: 0 solid #ccc;
            height: 6px;
            flex-shrink: 0;
            /*display: none; */
            display: block;
            overflow: hidden;
            position: relative;
        }

        .backtask-progress {
            height: 100%;
            background-color: #2E89E0;
            width: 30%;
        }

        .sliding-bar-animation {
            animation: slidingBar 1200ms infinite;
            animation-timing-function: cubic-bezier(0.2, 1, 0.8, 1);
        }

        @keyframes slidingBar {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(333%);
            }
        }

        .backtask-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex-grow: 1;
        }

        .backtask-btns {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .backtask-btns > button {
            background-color: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s ease, background-color 0.1s ease;
            padding: 6px 6px;
        }

        .backtask-btns > button:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .backtask-btns > button:active {
            background-color: rgba(0, 0, 0, 0.3);
        }

        i.backtask-btnicon {
            background-repeat: no-repeat;
            background-size: contain;
            width: 22px;
            height: 22px;
            display: inline-block;
        }

        .backtask-btn-cancel i.backtask-btnicon {
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='%23F44336' d='M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z' /></svg>");
        }

        .backtask-btn-retry i.backtask-btnicon {
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='%232196F3' d='M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z'/></svg>");
        }

    </style>

    <!--ç©ºç™½é®ç½©-->
    <style>
        .for-blank-mark {
            /*å¯¹äº é®ç½©çš„çˆ¶çº§ çš„è®¾ç½®*/
            position: relative; /* å…³é”®ï¼šè®© å­div ä»¥å®ƒä¸ºå®šä½åŸºå‡† */
            /*overflow: hidden; !* é˜²æ­¢ å­div æº¢å‡º *!*/

        }

        div.blank-mark {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;

            position: absolute;
            inset: 0;
            z-index: 9;
        }
    </style>

    <!--é®ç½©å†…å®¹ èœå•-->
    <style>
        div#menu-mark-dialog {
            flex-grow: 1;
            height: 100%;
        }

        div#menu-mark-rect {
            background: white;
            padding: 6px 4px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: left;
            gap: 1px;

            position: absolute;
        }

        button.menu-mark-action-btn {
            display: inline-block;
            padding: 6px 14px;
            /*font-size: 14px;*/
            background: transparent;
            transition: all 0.1s ease-in-out;
            border: 0 solid #3498db;
            border-radius: 0;
            cursor: pointer;

            text-align: left;
        }

        button.menu-mark-action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        button.menu-mark-action-btn:active {
            background: rgba(0, 0, 0, 0.24);
        }

        button.menu-mark-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        div.menu-mark-action-section {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 2px;
            margin: 0;
            padding: 0;
            min-height: 1px;
        }

        .menu-mark-action-section-text {
            margin: 0;
            padding: 0;
            color: var(--fc-least);
            font-size: 12px;
        }

        .menu-mark-action-section-hr {
            flex-grow: 1;
            display: inline-block;
            min-height: 1px;
            max-height: 1px;
            background-color: #00000033;
            border: none;
            margin: 0;
            padding: 0;
        }

    </style>

    <!--æ ‘-->
    <style>

        .for-tree-widget {
            /*display: do nothings;*/
        }

        details.tree-widget {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        /* é¡¶çº§èŠ‚ç‚¹æ ·å¼ */
        details.tree-widget > summary {
            list-style: none;
            padding: 6px 12px;
            margin: 0;
            background-color: #CCE5FF;
            border-radius: 4px;
            display: flex;
            align-items: center;
            user-select: none;
            transition: transform 0.1s ease;
        }

        .theme-dark details.tree-widget > summary {
            background-color: #515c67;
        }

        /*details.tree-widget > summary:hover {*/
        /*    transform: scale(1.05);*/
        /*}*/

        details.tree-widget > summary.as-item {
            background-color: transparent;
            transition: all 0.1s ease-in-out;
        }

        details.tree-widget > summary.as-item:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        details.tree-widget > summary.as-item.hold {
            background-color: rgba(0, 123, 255, 0.2);
        }

        details.tree-widget > summary.as-item.active {
            background-color: rgba(255, 255, 0, 0.35);
        }

        /* Flexå¸ƒå±€æ¨¡æ‹Ÿå¤šåˆ— */
        div.tree-headers {
            display: flex;
            width: 100%;
            gap: 10px; /* åˆ—é—´è· */
        }

        /*div.tree-items-warp {*/
        /*    display: flex;*/
        /*    flex-direction: column;*/
        /*    flex-grow: 1;*/
        /*}*/

        ul.tree-items {
            overflow-y: auto;
            flex-grow: 1;

            padding-left: 12px;
            padding-right: 4px;
            margin: 4px 0;
        }

        ul.tree-items.align-right {
            padding-left: 4px;
            padding-right: 12px;
        }


        li.tree-item {
            display: flex;
            justify-content: flex-start;
            gap: 10px;
            margin: 2px 0;
            padding: 8px 4px;
            border-radius: 4px;
        }

        li.tree-item:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        li.tree-item[data-clickable="true"]:active {
            background-color: rgba(0, 123, 255, 0.3);
        }

        li.tree-item.active {
            background-color: rgba(255, 255, 0, 0.35);
        }

        .column-mark-inactive {
            color: red;
        }

        .column-mark-highlight {
            background: #FFFF0088;
        }

    </style>

    <!--ç½‘ç›˜é¡µé¢-->
    <style>

        .drive-rect {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 4px;
        }

        .drive-header {
            display: flex;
            flex-direction: row;
            gap: 0;
            align-items: end;
        }

        .drive-header-btn-close {
            border: 0;
            width: 40px;
            height: 90%;
            font-size: 16px;
            background: transparent !important;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            border: none !important;
        }

        .drive-header-btn-close:hover {
            background: rgba(0, 0, 0, 0.1) !important;
        }

        .drive-header-btn-close:active {
            background: rgba(0, 0, 0, 0.24) !important;
        }

        .drive-path {
            display: flex;
            flex-direction: row;
            justify-content: left;
            gap: 4px;
            margin-bottom: 2px;
            margin-left: 10px;
        }

        .drive-path-item {
            display: flex;
            flex-direction: row;
            gap: 2px;
            font-size: 16px;
            align-items: flex-end;
        }

        .drive-path-item-slash {
            color: var(--c-thick-blue);
            user-select: none;
        }

        .drive-path-item-btn {
            display: inline-block;
            padding: 10px 8px 6px 8px;
            background: transparent !important;
            transition: all 0.1s ease-in-out;
            border: 0 solid #3498db !important;
            border-bottom-width: 1px !important;
            border-radius: 3px 3px 6px 6px;
            cursor: pointer;
        }

        .drive-path-item-btn:hover {
            background: rgba(0, 0, 0, 0.1) !important;
        }

        .drive-path-item-btn:active {
            background: rgba(0, 0, 0, 0.24) !important;
        }

        .drive-path-item-btn.active {
            background-color: rgba(255, 255, 0, 0.35) !important;
        }

        .drive-actions {
            display: flex;
            flex-direction: row;
            /*background: #CCE5FF;*/
            background: linear-gradient(to bottom, #CCE5FF88, transparent);
            border-radius: 4px;
            padding: 3px 4px;
            gap: 4px;
            margin-bottom: 2px;
        }

        .theme-dark .drive-actions {
            background: linear-gradient(to bottom, rgba(93, 108, 119, 0.53), transparent);
        }

        .drive-action-btn {
            display: inline-block;
            padding: 8px 8px;
            background: transparent !important;
            transition: all 0.1s ease-in-out;
            border: 0 solid black !important;
            border-radius: 2px;
            cursor: pointer;
        }

        .drive-action-btn:first-of-type {
            margin-left: 4px !important;
        }

        .drive-action-btn.hidden-btn {
            display: none !important;
        }

        .drive-action-btn:hover {
            background-color: rgba(0, 123, 255, 0.15) !important;
        }

        .drive-action-btn:active {
            background-color: rgba(0, 123, 255, 0.4) !important;
        }

        .drive-items-wrap {
            display: flex;
            flex-direction: column;
            flex-grow: 1;

            overflow: auto;
        }

        .drive-items-wrap.drag-active {
            background-color: rgba(255, 255, 0, 0.35);
        }

        .drive-items-wrap > p {
            margin: 0;
            align-self: center;
        }

        .drive-items {
            display: flex;
            flex-direction: column;
            gap: 4px;

            /*overflow-y: auto;*/
            /*flex-grow: 1;*/
        }

        .drive-item {
            display: flex;
            flex-direction: row;
            gap: 4px;
            flex-grow: 1;
            align-items: center;
        }

        .drive-items details:last-of-type {
            margin-bottom: 100px;
        }

        .drive-item-icon-file {
            margin-left: 4px;
            background-repeat: no-repeat;
            background-size: contain;
            width: 22px;
            height: 22px;
            display: inline-block;
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='%23737373' d='M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z'/></svg>")
        }

        .theme-dark .drive-item-icon-file {
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='rgb(220, 220, 220)' d='M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z'/></svg>")
        }

        .drive-item-icon-folder {
            margin-left: 4px;
            background-repeat: no-repeat;
            background-size: contain;
            width: 22px;
            height: 22px;
            display: inline-block;
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='%23737373' d='M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4Z'/></svg>")
        }

        .theme-dark .drive-item-icon-folder {
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='rgb(220, 220, 220)' d='M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4Z'/></svg>")
        }

        .drive-item-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-grow: 1;
            /*gap: 2px;*/
        }

        .drive-item-info > a {
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-grow: 1;
            /*gap: 2px;*/

            text-decoration: none;
            color: inherit;
            /*pointer-events: none;*/
        }

        .drive-item-info-name {
            margin: 0;
            padding: 0;
            user-select: text;
        }

        .drive-item-info-name.red {
            color: red;
        }

        .drive-item-info-others {
            display: flex;
            flex-direction: row;
            justify-content: left;
            gap: 4px;
            align-items: end;
        }

        .drive-item-info-others span {
            margin: 0;
            padding: 0;
            color: var(--fc-least);
            font-size: 12px;
        }

        .theme-dark .drive-item-info-others span {
            color: var(--fc-least);
        }

        .drive-item-actions {
            display: flex;
            flex-direction: row;
            justify-content: left;
        }

        .drive-item-action {
            display: flex;
            padding: 8px 8px;
            background: transparent !important;
            transition: all 0.1s ease-in-out;
            border: 0 solid black !important;
            border-radius: 2px;
            cursor: pointer;
        }

        .drive-item-action:hover {
            background-color: rgba(0, 123, 255, 0.15) !important;
        }

        .drive-item-action:active {
            background-color: rgba(0, 123, 255, 0.4) !important;
        }

        .drive-item-action-icon-more {
            pointer-events: none;
            background-repeat: no-repeat;
            background-size: contain;
            width: 22px;
            height: 22px;
            display: inline-block;
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='%232196F3' d='M16,12A2,2 0 0,1 18,10A2,2 0 0,1 20,12A2,2 0 0,1 18,14A2,2 0 0,1 16,12M10,12A2,2 0 0,1 12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12M4,12A2,2 0 0,1 6,10A2,2 0 0,1 8,12A2,2 0 0,1 6,14A2,2 0 0,1 4,12Z'/></svg>");
        }


    </style>

    <!--ç®¡ç†é¡µé¢ ä¸Šçº¿æƒ…å†µ-->
    <style>
        .activity-rect {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 4px;
        }

        .activity-filter {
            display: flex;
            flex-direction: row;
            gap: 8px;
        }

        .activity-filter > label > *:first-child {
            margin-left: 4px;
        }

        .activity-users {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 4px;
        }

    </style>

    <!--å€™é€‰è¯ç®¡ç†-->
    <style>
        .candidate-words-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        .candidate-words-toolbar button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #f5f5f5;
            cursor: pointer;
        }

        .candidate-words-toolbar button:hover {
            background: #e8e8e8;
        }

        .candidate-words-filter {
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        .candidate-words-filter input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .select-all-label {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .select-all-label input {
            width: 16px;
            height: 16px;
        }

        .candidate-words-list {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow-y: auto;
            padding: 8px;
            gap: 4px;
        }

        .candidate-word-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            gap: 8px;
            background: #fafafa;
        }

        .candidate-word-item .candidate-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .candidate-word-item:hover {
            background: #f0f0f0;
        }

        .candidate-index {
            width: 30px;
            min-width: 30px;
            color: #888;
            font-size: 12px;
            text-align: center;
        }

        .candidate-word {
            flex: 1;
            word-break: break-all;
        }

        .candidate-count {
            width: 60px;
            text-align: center;
            color: #666;
            font-size: 12px;
            padding: 2px 6px;
            background: #e8f4ff;
            border-radius: 10px;
        }

        .candidate-actions {
            display: flex;
            gap: 4px;
        }

        .candidate-actions button {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #fff;
            cursor: pointer;
            font-size: 12px;
        }

        .candidate-actions button:hover {
            background: #f0f0f0;
        }

        .candidate-actions .btn-delete {
            color: #d32f2f;
            border-color: #d32f2f;
        }

        .candidate-actions .btn-delete:hover {
            background: #ffebee;
        }

    </style>

    <!--å…¨ä½“é€šçŸ¥ç®¡ç†-->
    <style>
        .all-people-notice-rect {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 8px;
            padding: 8px;
        }

        .all-people-notice-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        .all-people-notice-toolbar .btn-delete-selected {
            color: #d32f2f;
            border-color: #d32f2f;
        }

        .all-people-notice-toolbar .btn-delete-selected:hover {
            background: #ffebee;
        }

        .all-people-notice-toolbar button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #f5f5f5;
            cursor: pointer;
        }

        .all-people-notice-toolbar button:hover {
            background: #e8e8e8;
        }

        .all-people-notice-filter {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .all-people-notice-filter input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .all-people-notice-list {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow-y: auto;
            padding: 8px;
            gap: 8px;
        }

        .all-people-notice-item {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            gap: 12px;
            background: #fafafa;
        }

        .all-people-notice-item .notice-checkbox {
            margin-top: 4px;
        }

        .all-people-notice-item > .notice-item-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .all-people-notice-item.enabled {
            border-color: #4caf50;
            background: #f1f8f1;
        }

        .all-people-notice-content {
            flex: 1;
            word-break: break-all;
            white-space: pre-wrap;
        }

        .all-people-notice-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #888;
        }

        .all-people-notice-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .all-people-notice-actions button {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #fff;
            cursor: pointer;
            font-size: 12px;
        }

        .all-people-notice-actions button:hover {
            background: #f0f0f0;
        }

        .all-people-notice-actions .btn-enable {
            color: #4caf50;
            border-color: #4caf50;
        }

        .all-people-notice-actions .btn-enable:hover {
            background: #e8f5e9;
        }

        .all-people-notice-actions .btn-disable {
            color: #ff9800;
            border-color: #ff9800;
        }

        .all-people-notice-actions .btn-disable:hover {
            background: #fff3e0;
        }

        .all-people-notice-actions .btn-delete {
            color: #d32f2f;
            border-color: #d32f2f;
        }

        .all-people-notice-actions .btn-delete:hover {
            background: #ffebee;
        }

        .all-people-notice-empty {
            text-align: center;
            color: #888;
            padding: 40px;
        }

        .all-people-notice-editor {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .all-people-notice-editor.active {
            display: flex;
        }

        .all-people-notice-editor textarea {
            width: 100%;
            min-height: 200px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: inherit;
            resize: vertical;
            box-sizing: border-box;
        }

        .all-people-notice-editor label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .all-people-notice-editor .editor-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .all-people-notice-editor button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        .all-people-notice-editor button.btn-save {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .all-people-notice-editor button.btn-cancel {
            background: #f5f5f5;
        }
    </style>

    <!--ç®¡ç†é¡µé¢ æœåŠ¡çŠ¶æ€-->
    <style>
        .service-status-rect {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 4px;
        }

        .service-status-row {
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
        }

    </style>

    <!--ç®¡ç†é¡µé¢ å¤‡ä»½æ¢å¤-->
    <style>
        .backup-rect {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 4px;
        }

        .backup-rect > hr {
            border: none;
            height: 1px;
            background-color: #00000055;
            margin: 8px 0;
        }

        .backup-row {
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
        }

        .backup-row > button {
            padding: 4px;
        }

        .backup-row > span {
            font-size: 14px;
            color: rgba(253, 25, 25, 0.9);
        }

    </style>

    <!--å¤é€‰æ¡†-->
    <style>
        .checkbox {
            display: inline-flex;
            align-items: center;
            gap: 0;
            font-size: 18px;
            cursor: pointer;
            user-select: none;
        }

        .checkbox input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border: 2px solid #00000099;
            border-radius: 4px;
            display: inline-block;
            position: relative;
            cursor: pointer;
            background-color: transparent;
            transition: all 0.1s ease;
        }

        .theme-dark .checkbox input[type="checkbox"] {
            border-color: #FFFFFF99;
        }

        /* å·²é€‰ä¸­ */
        .checkbox input[type="checkbox"]:checked {
        }

        .checkbox input[type="checkbox"]:checked::after {
            content: "";
            position: absolute;
            left: 5px;
            top: 0;
            width: 7px;
            height: 13px;
            border: solid black;
            border-width: 0 3px 3px 0;
            transform: rotate(45deg);
        }

        .theme-dark .checkbox input[type="checkbox"]:checked::after {
            border-color: #FFFFFFbb;
        }

        /* ä¸ç¡®å®šçŠ¶æ€ */
        .checkbox input[type="checkbox"]:indeterminate {
        }

        .checkbox input[type="checkbox"]:indeterminate::after {
            content: "";
            position: absolute;
            left: 3px;
            top: 9px;
            width: 14px;
            height: 3px;
            background: black;
            border-radius: 2px;
        }

        .theme-dark .checkbox input[type="checkbox"]:indeterminate::after {
            background: #FFFFFFbb;
        }

    </style>

    <!--æ‚¬æµ®çƒ-->
    <style>
        .float-ball {
            position: fixed;
            right: -48px; /* éšè—åœ¨å±å¹•è¾¹ç¼˜ï¼Œåªéœ²å‡ºä¸€éƒ¨åˆ† */
            top: 50%;
            transform: translateY(-50%); /* æŠŠè‡ªèº«é«˜åº¦åç§»ä¸€åŠï¼Œå®ç°ç²¾ç¡®å±…ä¸­ */
            bottom: 32px;
            width: 58px;
            height: 58px;
            border-radius: 50%;
            background-color: #69b1fa;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            z-index: 9;
            user-select: none;
            transition: all 0.1s ease-in-out, opacity 0.1s ease;
            font-size: 20px;
            border: transparent 6px solid;
        }

        .float-ball:hover {
            background-color: #85c1ff;
        }

        .float-ball:active {
            background-color: #65a3e3;
        }

        .float-ball.drag-active {
            border: rgba(255, 255, 0, 0.6) 6px solid;
        }

        /* é¼ æ ‡é è¿‘æ—¶æ˜¾ç¤ºå®Œæ•´æ‚¬æµ®çƒ */
        .float-ball.show {
            right: 32px;
        }

    </style>

    <!--è¾“å…¥è¡¨å• è‡ªå®šä¹‰å…ƒç´ -->
    <style>
        /* nothings */
    </style>

    <!--è¾“å…¥è¡¨å• è‡ªå®šä¹‰å…ƒç´  å…±äº«è®¾ç½®-->
    <style>
        .fmic-item-sharesettings {
            display: flex;
            flex-direction: row;
            justify-content: left;
            margin-bottom: 6px;
            flex-wrap: nowrap;
            white-space: nowrap;
            gap: 4px;
            margin-right: 24px;
        }

        .fmic-item-sharesettings > label {
            white-space: nowrap;
        }

        .fmic-item-sharesettings > label > * {
            margin-left: 4px;
        }

        .fmic-item-sharesettings > label > *:first-child {
            margin-left: 4px;
        }

        .fmic-item-sharesettings select {
        }
    </style>

    <!--è¾“å…¥è¡¨å• è‡ªå®šä¹‰å…ƒç´  è½¬å‘æ¶ˆæ¯åˆ°-->
    <style>
        .fmic-item-forwardmsgto {
            display: flex;
            flex-direction: row;
            justify-content: left;
            margin-bottom: 6px;
            flex-wrap: nowrap;
            white-space: nowrap;
            gap: 4px;
            margin-right: 32px;
        }

        .fmic-item-forwardmsgto > label {
            white-space: nowrap;
        }

        .fmic-item-forwardmsgto > label > * {
            margin-left: 4px;
        }

        .fmic-item-forwardmsgto > label > *:first-child {
            margin-left: 4px;
        }

    </style>

    <!--èŠå¤©é¡µé¢ è”ç³»äºº-->
    <style>

        .chat-contacts-mark-syncing {
            user-select: none;
            position: absolute;
            transition: opacity 0.4s ease;

            left: 0;
            right: 0;
        }

        .chat-contacts-mark-syncing p {
            /*background: var(--bg-less);*/
            background: rgba(253, 25, 25, 0.1);
            font-size: 12px;
            margin: 0 0;
            padding: 4px 8px;
            text-align: center;
        }

        p.chat-contact-type {
            margin: 0;
            padding: 0 0 0 4px;
            user-select: none;
            background: rgba(0, 0, 0, 0.05);
            color: var(--c-thick-blue2);
            font-size: 14px;
        }

        /* li é»˜è®¤æ ·å¼ï¼Œæ— èƒŒæ™¯ */
        div.chat-contact {
            padding: 4px 4px;
            margin: 4px 0;
            border-radius: 2px;
            cursor: pointer;
            transition: background-color 0.1s, transform 0.1s;
            user-select: none;
            display: flex;
            flex-direction: row;
            gap: 1px;
        }

        /* é¼ æ ‡æ‚¬æµ®æ•ˆæœ */
        div.chat-contact:hover {
            background-color: rgba(0, 123, 255, 0.15); /* æµ…è“è‰²æ‚¬æµ® */
        }

        /* é¼ æ ‡æŒ‰ä¸‹æ•ˆæœ */
        div.chat-contact:active {
            background-color: rgba(0, 123, 255, 0.4); /* æ·±ä¸€äº› */
        }

        /* é€‰ä¸­çŠ¶æ€ */
        div.chat-contact.active {
            background-color: rgba(0, 123, 255, 0.2);
            font-weight: bold;
            border: #2088ee 0 solid;
            border-radius: 2px;
            border-left-width: 4px;
        }

        span.chat-contact-online-status {
            font-size: 20px;
            align-self: flex-start;
        }

        span.chat-contact-online-status[data-online-status="online"] {
            color: #00c700aa;
        }

        span.chat-contact-online-status[data-online-status="offline"] {
            color: #c70000aa;
        }

        div.chat-contact-session-status {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        div.chat-contact-session-status-top, div.chat-contact-session-status-bottom {
            display: flex;
            flex-direction: row;
        }

        span.chat-contact-session-status-top-name {
            flex-grow: 1;

            white-space: nowrap; /* ä¸æ¢è¡Œ */
            overflow: hidden; /* è¶…å‡ºéšè— */
            text-overflow: ellipsis; /* ç”¨çœç•¥å·ä»£æ›¿æº¢å‡ºæ–‡æœ¬ */
            width: 0; /* æˆ–å›ºå®š/æœ€å¤§å®½åº¦ */
            display: inline-block; /* å¿…é¡»è®©å®½åº¦ç”Ÿæ•ˆ */
        }

        span.chat-contact-session-status-top-lastmsgtime {
            font-weight: normal;
            font-size: 12px;
            color: var(--fc-least);
            white-space: nowrap;
        }

        span.chat-contact-session-status-bottom-lastmsgview {
            flex-grow: 1;
            font-weight: normal;
            font-size: 12px;
            color: var(--fc-least);

            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 0;
            display: inline-block;
        }

        span.chat-contact-session-status-bottom-lastmsgview[data-has-activity="true"] {
            color: #006edc;
        }

        .theme-dark span.chat-contact-session-status-bottom-lastmsgview[data-has-activity="true"] {
            color: #54a6ff;
        }

        span.chat-contact-session-status-bottom-unreadcount {
            font-size: 12px;
            font-weight: 900;
            color: #fff;

            min-width: 22px;
            height: 22px;
            padding: 0 6px;

            border-radius: 999px;

            /* é«˜å¯¹æ¯”çº¢ï¼ˆæµ…è“èƒŒæ™¯æœ€ä½³ï¼‰ */
            background: linear-gradient(135deg, #ff1a1a, #ff4d4d);

            display: flex;
            align-items: center;
            justify-content: center;

            white-space: nowrap;

            /* ç™½æè¾¹ï¼šä¿è¯åœ¨ä»»ä½•è“è‰²ä¸Šéƒ½æ¸…æ™° */
            border: 2px solid #ffffff;

            /* å¤šå±‚é˜´å½± + çº¢è‰²å…‰æ™•ï¼ˆæ‚¬æµ®æ„Ÿï¼‰ */
            box-shadow:
                0 0 0 3px rgba(255, 0, 0, 0.35),
                0 0 14px rgba(255, 0, 0, 0.9),
                0 2px 10px rgba(0, 0, 0, 0.45);

            cursor: pointer;

            /* å‡ºç°çˆ†å‡º + æŒç»­æé†’ */
            animation:
                unreadPop 0.35s ease-out,
                unreadBreath 3s ease-in-out 8 0.35s,
                unreadGlow 4s ease-in-out 6 0.35s;

            transition: transform 0.15s ease;
        }

        /* é¼ æ ‡æ‚¬åœï¼šæš—ç¤ºå¯ç‚¹å‡» */
        span.chat-contact-session-status-bottom-unreadcount:hover {
            transform: scale(1.15);

            box-shadow:
                0 0 0 4px rgba(255, 0, 0, 0.35),
                0 6px 16px rgba(0, 0, 0, 0.45);
        }


        @keyframes unreadBreath {
            0%,100% { transform: scale(1); }
            50%     { transform: scale(1.08); }
        }

        @keyframes unreadPop {
            0%   { transform: scale(0); }
            80%  { transform: scale(1.35); }
            100% { transform: scale(1); }
        }

        @keyframes unreadAttention {
            0%,100% { transform: scale(1); }
            25%     { transform: scale(1.25); }
            50%     { transform: scale(0.95); }
            75%     { transform: scale(1.15); }
        }

        @keyframes unreadGlow {
            0%,100% {
                box-shadow:
                    0 0 0 3px rgba(255,0,0,0.35),
                    0 0 10px rgba(255,0,0,0.8),
                    0 2px 10px rgba(0,0,0,0.45);
            }
            50% {
                box-shadow:
                    0 0 0 6px rgba(255,0,0,0.45),
                    0 0 22px rgba(255,0,0,1),
                    0 2px 12px rgba(0,0,0,0.5);
            }
        }

    </style>

    <!--èŠå¤©é¡µé¢ ä¼šè¯-->
    <style>
        .chat-session-rect {
            display: flex;
            flex-direction: column;
            /*flex-grow: 1;*/
            height: 100%;
            overflow: visible;
        }

        .chat-session-header {
            display: flex;
            flex-direction: row;
            align-items: end;
            background: #CCE5FF88;
            padding: 4px;
            border-radius: 4px;

            border: 0 #3C8FDB66 solid;
            border-bottom-width: 1px;
        }

        .theme-dark .chat-session-header {
            background: rgba(70, 84, 105, 0.53);
        }

        .chat-session-header-btn-close {
            border: 0;
            width: 40px;
            height: 90%;
            font-size: 16px;
            background: transparent !important;
            transition: all 0.1s ease-in-out;
            margin-right: 2px;
            cursor: pointer;
            border: none !important;
        }

        .chat-session-header-btn-close:hover {
            background: rgba(0, 0, 0, 0.1) !important;
        }

        .chat-session-header-btn-close:active {
            background: rgba(0, 0, 0, 0.24) !important;
        }

        .chat-session-header-info {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 1px;
            padding-left: 4px;
            padding-top: 4px;
            padding-bottom: 2px;
            user-select: none;

            position: relative;
        }

        .chat-session-header-info-clickmark {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            max-width: 100px;
            height: 100%;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            border-radius: 2px;
            /*z-index: 1;*/
        }

        .chat-session-header-info-clickmark:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .chat-session-header-info-clickmark:active {
            background: rgba(0, 0, 0, 0.24);
        }

        span.chat-session-header-info-name {
            font-weight: bold;
            white-space: nowrap;
        }

        span.chat-session-header-info-status {
            font-weight: normal;
            font-size: 12px;
            color: var(--fc-least);
            white-space: nowrap;
        }

        .chat-session-header-actions {
            display: flex;
            flex-direction: row;
            align-items: center;

            margin-right: 8px;
        }

        .chat-session-header-actions > button {
            display: inline-block;
            background: transparent;
            transition: all 0.1s ease-in-out;
            border: 0 solid #3498db;
            border-radius: 0;
            cursor: pointer;

            width: 38px;
            height: 32px;

            font-size: 22px;
            color: var(--fc-less);
        }

        .chat-session-header-actions > button:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .chat-session-header-actions > button:active {
            background: rgba(0, 0, 0, 0.24);
        }

        /* ğŸ”¥ è¯é¢˜ç­›é€‰æ  */
        .chat-topic-filter-bar {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0, 123, 255, 0.08);
            border-bottom: 1px solid rgba(0, 123, 255, 0.15);
        }

        .chat-topic-filter-label {
            font-size: 12px;
            color: #1e90ff;
            font-weight: 500;
            white-space: nowrap;
        }

        .chat-topic-filter-select {
            flex: 1;
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid rgba(0, 123, 255, 0.3);
            border-radius: 4px;
            background: white;
            color: #333;
            cursor: pointer;
        }

        .chat-topic-filter-select:focus {
            outline: none;
            border-color: #1e90ff;
        }

        .chat-topic-filter-clear {
            padding: 4px 8px;
            font-size: 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-topic-filter-clear:hover {
            background: #5a6268;
        }

        .chat-session-onlineusers-item:first-child {
            margin-top: 6px;
        }

        .chat-session-onlineusers-item {
            padding: 6px 6px;
            margin: 4px 0;
            border-radius: 2px;
            cursor: pointer;
            transition: background-color 0.1s, transform 0.1s;
            user-select: none;

            display: flex;
            flex-direction: row;
            gap: 4px;

            align-items: center;

        }

        .chat-session-onlineusers-item:hover {
            background-color: rgba(0, 123, 255, 0.12);
        }


        /*.chat-session-onlineusers-item:active {*/
        /*    background-color: rgba(0, 123, 255, 0.4);*/
        /*}*/

        .chat-session-onlineusers-item.active {
            background-color: rgba(255, 255, 0, 0.25);
        }


        .chat-session-onlineusers-item-name {
            display: inline-block;
            flex-grow: 1;
            align-self: center;
        }

        span.chat-session-onlineusers-item-online-status {
            font-size: 18px;
            align-self: flex-start;
        }

        span.chat-session-onlineusers-item-online-status[data-online-status="online"] {
            color: #00c700aa;
        }

        span.chat-session-onlineusers-item-online-status[data-online-status="offline"] {
            color: #c70000aa;
        }


        /* çˆ¶å®¹å™¨æ’‘æ»¡å®½åº¦ */
        .chat-session-inputarea {
            display: flex;
            flex-direction: column;
            width: 100%;
            box-sizing: border-box;
            position: relative; /* å®šä½åŸºå‡†ï¼Œå¿…é¡»æœ‰ */
        }

        .theme-dark .chat-session-inputarea {
            background: rgba(70, 84, 105, 0.53);
        }

        .chat-session-inputarea-othertypes {
            display: flex;
            flex-direction: row;
            gap: 4px;
            align-items: end;
        }

        .chat-session-inputarea-othertypes button {
            padding: 6px;
        }

        /* ğŸ”¥ è¯é¢˜é€‰æ‹©å™¨æ ·å¼ */
        .chat-topic-selector {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(0, 123, 255, 0.08);
            border-radius: 6px;
            margin-bottom: 6px;
        }

        .chat-topic-selector label {
            font-size: 13px;
            color: #1e90ff;
            font-weight: 500;
            white-space: nowrap;
        }

        .chat-topic-selector select {
            padding: 4px 8px;
            font-size: 13px;
            border: 1px solid rgba(0, 123, 255, 0.3);
            border-radius: 4px;
            background: white;
            color: #333;
            cursor: pointer;
            min-width: 100px;
        }

        .chat-topic-selector select:focus {
            outline: none;
            border-color: #1e90ff;
        }

        .chat-topic-selector input {
            padding: 4px 8px;
            font-size: 13px;
            border: 1px solid rgba(0, 123, 255, 0.3);
            border-radius: 4px;
            width: 100px;
        }

        .chat-topic-selector input:focus {
            outline: none;
            border-color: #1e90ff;
        }

        .chat-topic-selector .chat-topic-new-btn {
            padding: 4px 8px;
            font-size: 12px;
            background: #1e90ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-topic-selector .chat-topic-new-btn:hover {
            background: #0d6efd;
        }

        .chat-session-inputarea-textarea-row {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;              /* æ¨ªå‘æ’‘æ»¡ */
        }

        .chat-session-inputarea-textarea {
            flex: 1;                  /* å æ»¡å‰©ä½™ç©ºé—´ */
            min-height: 40px;
            max-height: 200px;
            padding: 8px;
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
        }


        .chat-session-inputarea-tip-editing {
            display: flex;
            flex-direction: row;
            align-items: end;
        }

        .chat-session-inputarea-tip-editing > span {
            font-weight: bold;
            font-size: 14px;
            color: var(--c-thick-blue2);
        }

        .chat-session-inputarea-tip-editing > button {
            padding: 0 4px;
        }

    </style>

    <!--èŠå¤©é¡µé¢ æ¶ˆæ¯æµ-->
    <style>
        .chat-session-msgflow-wrap {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 10px;

            overflow-y: hidden;
        }

        .chat-session-msgflow-wrap.drag-active {
            background-color: rgba(255, 255, 0, 0.35);
        }

        .chat-session-msgflow {
            flex-grow: 1;
            display: flex;
            flex-direction: column;

            min-height: 10px;
            height: 100%;
            overflow-y: scroll;

            gap: 2px;
        }

        .chat-session-msgflow-mark-onlineusers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            max-width: 100px;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            border: 0 rgba(0, 0, 0, 0.15) solid;
            border-right-width: 1px;
            box-shadow: 4px 0 4px -2px rgba(0, 0, 0, 0.1);
            min-width: 160px;
            padding-right: 4px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .theme-dark .chat-session-msgflow-mark-onlineusers {
            background: rgba(63, 63, 63, 0.95);
        }

        .chat-session-msgflow-mark-currentday {
            user-select: none;
            position: absolute;
            transition: opacity 0.4s ease;
            top: 0;

            /*left: 0;*/
            /*width: 100%;*/
            left: 50%;
            transform: translateX(calc(-50% - 8px));
        }

        .chat-session-msgflow-mark-currentday-layout {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }

        .chat-session-msgflow-mark-currentday-layout p {
            background: var(--bg-less);
            font-size: 14px;
            margin: 8px 0;
            padding: 4px 8px;
            text-align: center;
        }

        .chat-session-msgflow-mark-loadhistory {
            user-select: none;
            position: absolute;
            transition: opacity 0.4s ease;

            left: 0;
            right: 0;
            /*left: 50%;*/
            /*transform: translateX(calc(-50% - 8px));*/
        }

        .chat-session-msgflow-mark-loadhistory-layout {
            display: flex;
            flex-direction: row;
            /*justify-content: center;*/
        }

        .chat-session-msgflow-mark-loadhistory-layout p {
            /*background: var(--bg-less);*/
            background: rgba(253, 25, 25, 0.1);
            font-size: 12px;
            margin: 0 0;
            padding: 4px 8px;
            text-align: center;
            flex-grow: 1;
        }

        .chat-session-msgflow-mark-checknew {
            user-select: none;
            position: absolute;
            transition: opacity 0.4s ease;

            left: 0;
            right: 0;
            bottom: 0;
        }

        .chat-session-msgflow-mark-checknew-layout {
            display: flex;
            flex-direction: row;
            /*justify-content: center;*/
        }

        .chat-session-msgflow-mark-checknew-layout p {
            /*background: var(--bg-less);*/
            background: rgba(253, 25, 25, 0.1);
            font-size: 12px;
            margin: 0 0;
            padding: 4px 8px;
            text-align: center;
            flex-grow: 1;
        }

        .chat-session-msgflow-mark-droparea {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;

            display: flex;
            flex-direction: row;
            gap: 8px;
            padding: 8px;
        }

        .chat-session-msgflow-mark-droparea-image {
            border: 2px rgba(25, 71, 253, 0.4) dashed;
            background: rgba(25, 71, 253, 0.12);
            color: rgba(25, 71, 253, 0.7);
            font-size: 20px;
            font-weight: bold;
            flex-grow: 1;
            display: grid;
            place-items: center;
        }

        .theme-dark .chat-session-msgflow-mark-droparea-image {
            border: 2px rgba(80, 114, 255, 0.5) dashed;
            background: rgba(80, 114, 255, 0.18);
            color: rgba(80, 114, 255, 0.8);
        }

        .chat-session-msgflow-mark-droparea-file {
            border: 2px rgba(253, 25, 25, 0.4) dashed;
            background: rgba(253, 25, 25, 0.12);
            color: rgba(253, 25, 25, 0.7);
            font-size: 20px;
            font-weight: bold;
            flex-grow: 1;
            display: grid;
            place-items: center;
        }

        .theme-dark .chat-session-msgflow-mark-droparea-file {
            border: 2px rgba(255, 80, 80, 0.4) dashed;
            background: rgba(255, 80, 80, 0.12);
            color: rgba(255, 80, 80, 0.7);
        }


        .chat-session-msgflow-btn-scroll2end {
            position: absolute;
            bottom: 20px;
            right: 32px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #69b1fa !important;
            color: white !important;
            border: none !important;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: bottom 0.1s ease;
        }

        .chat-session-msgflow-btn-scroll2end:hover {
            background-color: #85c1ff !important;
        }

        .chat-session-msgflow-btn-scroll2end:active {
            background-color: #65a3e3 !important;
        }

        .chat-session-msgflow-btn-scroll2end.hide {
            bottom: -60px;
        }

        .chat-batch-action-bar {
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: linear-gradient(135deg, #e6f0ff, #f0f6ff);
            border-bottom: 1px solid rgba(0, 123, 255, 0.2);
        }

        .chat-batch-action-bar.show {
            display: flex;
        }

        .chat-batch-action-bar-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-batch-action-bar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-batch-action-bar label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #1e3557;
        }

        .chat-batch-action-bar input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .chat-batch-action-bar button {
            padding: 6px 12px;
            font-size: 13px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chat-batch-action-bar .btn-select-all {
            background-color: #e6f0ff;
            color: #1e3557;
            border: 1px solid #93c5fd;
        }

        .chat-batch-action-bar .btn-select-all:hover {
            background-color: #d6e8ff;
        }

        .chat-batch-action-bar .btn-select-inverse {
            background-color: #f0f6ff;
            color: #1e3557;
            border: 1px solid #93c5fd;
        }

        .chat-batch-action-bar .btn-select-inverse:hover {
            background-color: #e6f0ff;
        }

        .chat-batch-action-bar .btn-delete-selected {
            background-color: #ff4d4f;
            color: white;
        }

        .chat-batch-action-bar .btn-delete-selected:hover {
            background-color: #ff7875;
        }

        .chat-batch-action-bar .btn-cancel-select {
            background-color: #f0f0f0;
            color: #333;
        }

        .chat-batch-action-bar .btn-cancel-select:hover {
            background-color: #e0e0e0;
        }

        .theme-dark .chat-batch-action-bar {
            background: linear-gradient(135deg, #1a3a5c, #2a4a6c);
            border-bottom-color: rgba(86, 172, 255, 0.3);
        }

        .theme-dark .chat-batch-action-bar label {
            color: #e0e0e0;
        }

        .theme-dark .chat-batch-action-bar .btn-select-all,
        .theme-dark .chat-batch-action-bar .btn-select-inverse {
            background-color: rgba(86, 172, 255, 0.2);
            border-color: rgba(86, 172, 255, 0.4);
            color: #e0e0e0;
        }

        .theme-dark .chat-batch-action-bar .btn-select-all:hover,
        .theme-dark .chat-batch-action-bar .btn-select-inverse:hover {
            background-color: rgba(86, 172, 255, 0.3);
        }

        .theme-dark .chat-batch-action-bar .btn-cancel-select {
            background-color: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        .chat-message-checkbox {
            display: none;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .chat-message-checkbox input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .chat-batch-mode .chat-message-checkbox {
            display: flex !important;
        }

        .chat-message-checkbox-disabled {
            display: none !important;
        }

        .chat-batch-mode .chat-message-checkbox.chat-message-checkbox-disabled {
            display: none !important;
        }

    </style>

    <!--èŠå¤©é¡µé¢ æ¶ˆæ¯-->
    <style>
        /* æ¶ˆæ¯å¤–å±‚å®¹å™¨ */
        .chat-message {
            display: flex;
            flex-direction: column;
            width: 100%;  /* <-- è¿™é‡Œæ˜¯å…³é”®é—®é¢˜ */
            margin: 4px 0;
        }




        ul .chat-message {
            margin-left: 0;
            margin-right: 0;
        }

        .chat-session-msgflow > .chat-message:first-of-type {
            margin-top: 10px;
        }

        .chat-session-msgflow > .chat-message:last-of-type {
            margin-bottom: 40px;
        }

        .chat-message-group {
            flex-grow: 1;
            display: flex;
            flex-direction: row;
        }

        /* æ¶ˆæ¯å†…å®¹å®¹å™¨ */
        .chat-message-content-container {
            flex-grow: 1;
            display: flex;
            flex-direction: row;
            margin: 1px 0;
            padding-right: 10%;
            gap: 2px;
            /*transition: background-color 3s, transform 3s;*/
        }


        .chat-message-content-container.active {
            transition: none !important;
            background-color: rgba(255, 255, 0, 0.35) !important;
        }

        .chat-message-content-container.highlight {
            background: linear-gradient(to right, #FFFF0088, transparent);
        }

        .sent-by-me .chat-message-content-container.highlight {
            background: linear-gradient(to left, #FFFF0088, transparent);
        }

        .unsent .chat-message-content-container {
            background: rgba(0, 0, 0, 0.07);
        }

        .align-right .chat-message-content-container {
            justify-content: right;
        }

        .sent-by-me .chat-message-content-container {
            padding-right: 0;
            padding-left: 10%;
        }

        .chat-message-content-container.sys-msg {
            padding-right: 0;
            padding-left: 0;
            justify-content: center;
        }

        .chat-message-group-header {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-message-group-header-row1 {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }

        .chat-message-group-header-row2 {
            display: flex;
            flex-direction: row;
        }

        .sent-by-me .chat-message-group-header-row2 {
            justify-content: right;
        }

        .chat-message-group-header-name {
            display: inline-block;
            margin: 0;
            padding: 2px 12px 1px 10px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            min-width: 20px;
        }

        .sent-by-me .chat-message-group-header .chat-message-group-header-name {
            padding: 2px 10px 1px 12px;
            text-align: right;
        }

        .chat-message-group-header-date {
            background: var(--bg-less);
            font-size: 14px;
            margin: 8px 0;
            padding: 4px 8px;
            text-align: center;
        }

        /* ğŸ”¥ æ¶ˆæ¯è¯é¢˜æ ‡ç­¾ */
        .chat-message-topic {
            display: inline-block;
            font-size: 11px;
            padding: 2px 8px;
            margin: 2px 4px;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chat-message-topic:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .chat-message-topic.empty {
            background: #9e9e9e;
            cursor: default;
        }

        .chat-message-topic.empty:hover {
            transform: none;
            box-shadow: none;
        }

        /* è¯é¢˜åˆ†éš”æ¡ */
        .chat-topic-divider {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 12px 0;
            padding: 8px 0;
        }

        .chat-topic-divider-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(0, 123, 255, 0.3), transparent);
            margin: 0 12px;
        }

        .chat-topic-divider-text {
            font-size: 12px;
            color: #1e90ff;
            font-weight: 500;
            white-space: nowrap;
            background: white;
            padding: 2px 10px;
            border-radius: 10px;
        }

        .theme-dark .chat-topic-divider-text {
            background: #3f3f3f;
        }

    </style>

    <!--èŠå¤©é¡µé¢ æ¶ˆæ¯å†…å®¹åŒºåŸŸ-->
    <style>
        .chat-message-content-rect {
            border-radius: 4px;
            display: flex;
            flex-direction: row;
            min-width: 40px;
            min-height: 20px;
            position: relative;
        }

        .sent-by-me .chat-message-content-rect {
            justify-content: right;
        }

        .chat-message-content-rect-mark-edited {
            border-top-right-radius: 4px;
            width: 8px;
            height: 8px;
            background: rgba(253, 25, 25, 0.8);
            clip-path: polygon(100% 0, 100% 100%, 0 0);
            position: absolute;
            right: 0;
            top: 0;
        }

        .sent-by-me .chat-message-content-rect-mark-edited {
            border-top-right-radius: 0;
            border-top-left-radius: 4px;
            clip-path: polygon(0 0, 100% 0, 0 100%);
            right: auto;
            left: 0;
        }


        .chat-mcr-text {
            padding: 6px;
        }

        .chat-mcr-text > span {
            white-space: pre-wrap;

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;
        }

        .chat-mcr-text > div:first-of-type {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .chat-mcr-image {
            padding: 6px;
        }

        .chat-mcr-image img {
            height: 40px;
            cursor: pointer;
        }

        .chat-mcr-image span:not(.red) {
            white-space: pre-wrap;

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            color: var(--c-thick-blue2);
            cursor: pointer;
            user-select: none;
            border: 0 transparent solid;
            border-bottom-width: 1px;
            font-size: 14px;
        }

        .chat-mcr-image span:hover {
            border-bottom-color: var(--c-thick-blue2);
        }


        .chat-mcr-file {
            padding: 6px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 2px;
        }

        .chat-mcr-file-icon {
            font-size: 32px;
            cursor: pointer;
            user-select: none;
        }

        .chat-mcr-file-icon.red {
            cursor: default;
        }

        .chat-mcr-file-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: start;
        }

        .chat-mcr-file-info-name {
            white-space: pre-wrap;

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;
        }

        .chat-mcr-file-info-others {
            display: flex;
            flex-direction: row;

            align-items: end;
        }

        .chat-mcr-file-info-size {
            font-size: 12px;
            color: var(--fc-least);
            white-space: nowrap;
        }

        .chat-mcr-file-status {
            white-space: pre-wrap;

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            color: var(--c-thick-blue2);
            user-select: none;
            font-size: 14px;

            margin-left: 4px;
        }

        .chat-mcr-sys {
            padding: 6px;
            display: flex;
            flex-direction: row;
            align-items: end;
        }

        .chat-mcr-sys span {
            white-space: pre-wrap;

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            font-size: 14px;
            color: var(--fc-less);
        }

        .chat-mcr-text span.red, .chat-mcr-text div.red, .chat-mcr-image span.red, .chat-mcr-file-info-name.red {
            color: red;
        }

    </style>

    <!--èŠå¤©é¡µé¢ æ¶ˆæ¯é™„åŠ å±æ€§-->
    <style>
        .chat-message-content-marks {
            display: flex;
            flex-direction: row;
            user-select: none;
            gap: 2px;
        }

        .sent-by-me .chat-message-content-marks {
            flex-direction: row-reverse;
        }

        .chat-message-content-mark {
            display: flex;
            flex-direction: row;
            align-items: end;

            font-size: 12px;
            color: var(--fc-least);
            white-space: nowrap;

            margin-bottom: 2px;
        }

        .chat-message-content-mark.noticing {
            color: #0650b0;
        }

        .theme-dark .chat-message-content-mark.noticing {
            color: #2d85ff;
        }

        .chat-mcm-send-status-text {
            color: #2563eb;
        }

        .chat-mcm-send-status-btn-retry {
            border: none;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            border-radius: 2px;
            color: #F44336;
            background: #69eefa66;
            font-weight: bold;
        }

        .chat-mcm-send-status-btn-retry:hover {
            background: #69eefabb;
        }

        .chat-mcm-send-status-btn-retry:active {
            background: #69eefa66;
        }

    </style>

    <!--èŠå¤©é¡µé¢ Markdown-->
    <style>

        .md-area-code-wrap {
            display: flex;
            position: relative;
            flex-direction: column;
            min-width: 10px;
        }

        .md-area-code {
            min-height: 30px;
            min-width: 100px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.05);
            border: 1px rgba(0, 0, 0, 0.15) solid;
            border-radius: 2px;
            margin: 0;
            padding: 1px;
            flex-grow: 1;
            cursor: text;

            scrollbar-width: thin;
            overflow-x: auto;
            overflow-y: auto;
            width: 100%;

            word-wrap: break-word;
            white-space: pre-wrap;
            word-break: break-all
        }

        .theme-dark .md-area-code {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px rgba(255, 255, 255, 0.15) solid;
        }

        .md-area-code-btn-copy {
            position: absolute;
            top: 1px;
            right: 1px;
            border: none;
        }

        .md-line {
            margin: 0;
        }

        .md-line-blockquote {
            background-color: rgba(25, 124, 253, 0.2);
            border: 0 rgba(25, 124, 253, 0.8) solid;
            border-left-width: 3px;
            display: flex;
            flex-direction: row;
            min-width: 60px;
            min-height: 30px;
            align-items: center;
            padding: 4px;
            padding-right: 8px;
            box-sizing: border-box;
        }

        .md-line-title {
            font-weight: bold;
        }

        .md-line-title[data-title-level="1"] {
            font-size: 30px;
            padding-top: 4px;
            padding-bottom: 4px;
        }

        .md-line-title[data-title-level="2"] {
            font-size: 24px;
            padding-top: 3px;
            padding-bottom: 3px;
        }

        .md-line-title[data-title-level="3"] {
            font-size: 20px;
            padding-top: 2px;
            padding-bottom: 2px;
        }

        .md-line-title[data-title-level="4"] {
            font-size: 16px;
            padding-top: 1px;
            padding-bottom: 1px;
        }

        .md-line-title[data-title-level="5"] {
            font-size: 13px
        }

        .md-line-title[data-title-level="6"] {
            font-size: 10px
        }

        span.md-text {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/
            /*display: inline;*/
            /*white-space: initial;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;
        }

        span.md-text-bold {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            font-weight: bold;
        }

        span.md-text-italic {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            font-style: italic;
        }

        span.md-text-underline {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            text-decoration: underline;
        }

        span.md-text-del {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            text-decoration: line-through;
        }

        span.md-text-code {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/
            /*display: inline;*/
            /*white-space: initial;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            background: rgba(255, 255, 255, 0.7);
            color: rgba(0, 0, 0, 0.9);
            font-size: 14px;
            border-radius: 3px;
            padding: 2px 4px;
            margin-left: 2px;
            margin-right: 2px;

            font-weight: normal;
            font-style: normal;
            text-decoration: none;
        }

        .theme-dark span.md-text-code {
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        span.md-text-at {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/
            /*display: inline;*/
            /*white-space: initial;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            /*background: rgba(0, 0, 0, 0.7);*/
            color: white;
            font-size: 14px;
            border-radius: 3px;
            padding: 2px 0 2px 0;
            margin-left: 0;
            /*margin-right: 2px;*/

            font-weight: bold;
        }

        span.md-text-cite {
            white-space: normal;
            /*word-wrap: normal;*/
            /*word-break: normal;*/
            /*overflow-wrap: normal;*/
            /*display: inline;*/
            /*white-space: initial;*/

            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: anywhere;

            background: rgba(255, 255, 255, 0.7);
            color: rgba(0, 0, 0, 0.7);
            font-size: 14px;
            border-radius: 3px;
            padding: 2px 4px 2px 3px;
            margin-left: 0;
            margin-right: 2px;

            text-decoration: underline;

        }

        .theme-dark span.md-text-cite {
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body class="">

<!---->

<header class="">
    <button id="header-btn-tostartpage" class="initiation_hidden">â¬…ï¸è¿”å›é¦–é¡µ</button>

    <button id="header-btn-startpage" class="hidden">ğŸ é¦–é¡µ</button>

    <button id="header-btn-mail" class="hidden">æ”¶å‘</button>
    <button id="header-btn-drive" class="hidden">ğŸ“ç½‘ç›˜</button>
    <button id="header-btn-chat" class="hidden">ğŸ’¬èŠå¤©</button>
    <button id="header-btn-forum" class="hidden">è®¨è®º</button>

    <button id="header-btn-more-left" class="menu-btn">&nbsp;</button>
    <span class="flex-grow"></span>
    <!--    <button id="header-btn-backend" class="">åå°é¢æ¿</button>-->
    <button id="header-btn-more-right" class="menu-btn">#</button>
</header>
<main>

    <section id="login-panel" class="">
        <span id="login-top-margin"></span>
        <div id="login-rect">
            <span id="login-tip-user" class="hidden"></span>
            <span id="login-tip-admin" class="hidden">æœåŠ¡ç®¡ç†å‘˜</span>

            <label id="login-input-account-label">
                è´¦å·ï¼š
                <input type="text" id="login-input-account">
            </label>

            <label>
                å¯†ç ï¼š
                <input type="text" id="login-input-password">
                <button type="button" class="clear-input-btn" data-target="login-input-password">æ¸…ç©º</button>
            </label>

            <button id="login-btn">ç™»å½•</button>
        </div>
    </section>



    <section id="apps-panel">
        <span id="apps-top-margin"></span>

        <div id="apps-rect">

            <!-- é€šçŸ¥ -->
            <div id="apps-notification" class="apps-item notification">
                <p class="apps-item-name">all_people_notice</p>
            </div>

            <div style="height: 50px;"></div>

            <!-- ç½‘ç›˜ + èŠå¤©ï¼ˆå·¦å³ï¼‰ -->
            <div class="apps-item-row">
                <div class="apps-item main-app" id="apps-item-drive">
                    <p class="apps-item-name">ğŸ“ç½‘ç›˜</p>
                </div>

                <div class="apps-item main-app" id="apps-item-chat">
                    <p class="apps-item-name">ğŸ’¬èŠå¤©</p>
                </div>
            </div>

            <!-- å…¶ä»– -->
            <div class="apps-item hidden" id="apps-item-forum">
                <p class="apps-item-name">è®¨è®º</p>
            </div>

        </div>
    </section>



    <section id="dashboard-mail">
        <div class="aside-left-wrap">
            <aside class="aside-left tiny-scrollbar">
                <button id="new-mail-btn">å‘ä¿¡</button>
                <nav>
                    <ol class="nav-buttons">
                        <!--                    <li>æ”¶ä»¶ç®±</li>-->
                    </ol>
                </nav>
            </aside>
        </div>
        <div class="aside-divider"></div>
        <aside class="aside-right">
        </aside>
    </section>

    <section id="dashboard-drive">
        <div class="aside-left-wrap">
            <aside class="aside-left tiny-scrollbar">
                <nav>
                    <ol class="nav-buttons">
                    </ol>
                </nav>
            </aside>
        </div>
        <div class="aside-divider"></div>
        <aside class="aside-right">
        </aside>
    </section>

    <section id="dashboard-chat">
        <div class="aside-left-wrap" style="width: 190px;">
            <aside class="aside-left tiny-scrollbar">
                <nav>
                    <p class="chat-contact-type">ç¾¤èŠï¼š</p>
                    <ol class="nav-buttons">
                    </ol>
                </nav>
               <nav>
                <div class="chat-contact-type chat-contact-type-private">
                    <span class="chat-contact-title">ç§èŠï¼š</span>
                    <input
                        type="text"
                        class="chat-contact-search"
                        placeholder="æœç´¢"
                    />
                </div>

                <ol class="nav-buttons chat-private-list">
                </ol>
            </nav>
            </aside>
            <div class="chat-contacts-mark-syncing"><p>æ­£åœ¨åŒæ­¥...</p></div>
        </div>
        <div class="aside-divider"></div>
        <aside class="aside-right">
        </aside>
    </section>

    <section id="dashboard-forum">
        <div class="aside-left-wrap">
            <aside class="aside-left tiny-scrollbar">
                <button id="new-discussion-btn">å‘å¸ƒä¸»é¢˜</button>
                <nav>
                    <ol class="nav-buttons">
                    </ol>
                </nav>
            </aside>
        </div>
        <div class="aside-divider"></div>
        <aside class="aside-right">
        </aside>
    </section>

    <section id="backend-panel">
        <div class="aside-left-wrap">
            <aside class="aside-left tiny-scrollbar">
                <nav>
                    <ol class="nav-buttons">
                    </ol>
                </nav>
            </aside>
        </div>
        <div class="aside-divider"></div>
        <aside class="aside-right">
        </aside>
    </section>

</main>
<footer>
</footer>

<!---->

<script>

    function update_attachment_list_item(msgattr) {
        const div = msgattr._attachment_list_item;
        if (!div) return;

        // æ–‡ä»¶å
        const nameEl = div.querySelector(".name");
        const fileName = msgattr.plain_file_name || msgattr.file_attr.name;
        nameEl.textContent = fileName;
        nameEl.title = fileName;

        // æ–‡ä»¶å¤§å°
        div.querySelector(".size").textContent = format_bytes(msgattr.file_attr.size);

        // ä¸‹è½½/ä¸Šä¼ çŠ¶æ€æ–‡å­—
        const statusEl = div.querySelector(".status");
        let progress = 0;

        if (!msgattr.is_sent) {
            statusEl.textContent = msgattr.upload_task ? msgattr.upload_task.backtask_status_text.textContent : "æ­£åœ¨ä¸Šä¼ ...";
            if (msgattr.upload_task) progress = msgattr.upload_task.progress_percent || 0;
        } else if (msgattr.download_task) {
            const task = msgattr.download_task;
            if (task.status === FloatBall.taskstatus.finished) {
                statusEl.textContent = "å·²å®Œæˆ";
                progress = 100;
            } else {
                statusEl.textContent = task.backtask_status_text.textContent;
                progress = task.progress_percent || 0;
            }
        } else {
            statusEl.textContent = "";
            progress = 0;
        }

        // æ›´æ–°è¿›åº¦æ¡
        const progressBar = div.querySelector(".progress-bar");
        progressBar.style.width = `${progress}%`;
    }



    // æ–‡ä»¶æ¶ˆæ¯ä¸‹è½½å¤ç”¨å‡½æ•°
    // ===== æ–‡ä»¶ä¸‹è½½å¤ç”¨é€»è¾‘ï¼ˆä¿æŒ FileMsg åŠŸèƒ½ï¼‰ =====
    function trigger_file_download(msgattr) {
        if (!msgattr._fileMsgInstance) return;
        msgattr._fileMsgInstance.e_mcr_icon.click(); // å¤ç”¨ FileMsg å†…éƒ¨ç‚¹å‡»é€»è¾‘
    }


    function showChatToast({ title, content, onClick }) {
        const container = document.getElementById("chat-toast-container");
        if (!container) return;

        const toast = document.createElement("div");
        toast.className = "chat-toast";

        toast.innerHTML = `
            <div class="sender">${title}</div>
            <div class="content">${content}</div>
        `;

        toast.onclick = () => {
            onClick && onClick();
            toast.remove();
        };

        container.appendChild(toast);

        // 5 ç§’è‡ªåŠ¨æ¶ˆå¤±
        setTimeout(() => {
            toast.remove();
        }, 5000);
    }

    function build_ai_teacher_prompt(text) {
        return `
    ä½ ç°åœ¨æ˜¯ä¸€ä½ã€æ–°æ‰‹å¯¼å¸ˆå‹ AI æ•™ç»ƒã€‘ï¼Œç›®æ ‡æ˜¯è®©å®Œå…¨æ²¡æœ‰åŸºç¡€çš„äººèƒ½å¤Ÿç†è§£ã€æ“ä½œå¹¶æŒæ¡é—®é¢˜ã€‚å‡è®¾æˆ‘å®Œå…¨ä¸æ‡‚ç›¸å…³èƒŒæ™¯ã€æœ¯è¯­æˆ–éšå«è§„åˆ™ã€‚

    è¯·ä¸¥æ ¼éµå¾ªä»¥ä¸‹è§„èŒƒå›ç­”ï¼š

    ã€è®²è§£ç»“æ„ã€‘
    1. **æ¦‚å¿µå±‚**  
       - å¯¹å‡ºç°çš„å…³é”®æœ¯è¯­æˆ–æ¦‚å¿µï¼Œç”¨ç”ŸåŠ¨æ•…äº‹ã€ç”Ÿæ´»ç±»æ¯”æˆ–å°æ¡ˆä¾‹è§£é‡Š  
       - å†è§£é‡ŠæŠ€æœ¯å«ä¹‰  
       - æŒ‡å‡ºå¸¸è§è¯¯åŒºå’Œå®¹æ˜“æ··æ·†çš„ç‚¹

    2. **åŸç†å±‚**  
       - æ¯ä¸ªæ­¥éª¤èƒŒåçš„åŸç†æˆ–åŸå›   
       - ä¸ºä»€ä¹ˆå¿…é¡»è¿™æ ·åšï¼Œè·³è¿‡ä¼šå‡ºç°ä»€ä¹ˆé—®é¢˜  
       - å¦‚æœæœ‰å¤šç§æ–¹æ³•ï¼Œè¯´æ˜é€‚åˆæ–°æ‰‹çš„æ¨èæ–¹æ³•åŠåŸå› 

    3. **æ“ä½œå±‚**  
       - è¯¦ç»†åˆ—å‡ºæ¯ä¸€æ­¥æ“ä½œ  
       - æ¯æ­¥åŒ…å«ï¼š
           1. **æ ‡é¢˜**ï¼ˆç®€çŸ­æè¿°ï¼‰
           2. **åšä»€ä¹ˆ**ï¼ˆå…·ä½“åŠ¨ä½œï¼‰
           3. **ä¸ºä»€ä¹ˆ**ï¼ˆæ“ä½œåŸå› /åŸç†ï¼‰
           4. **æ³¨æ„äº‹é¡¹/è¯¯åŒº**ï¼ˆå®¹æ˜“é”™çš„åœ°æ–¹ï¼‰
           5. **ç»“æœé¢„æœŸ**ï¼ˆåšå®Œåä¼šçœ‹åˆ°ä»€ä¹ˆï¼‰

    4. **æ‰©å±•å±‚ï¼ˆå¯é€‰ï¼‰**  
       - æä¾›è¿›é˜¶æŠ€å·§æˆ–å˜ä½“æ–¹æ³•  
       - ç»™å‡ºç†è§£èƒŒåçš„æ€è·¯ï¼Œå¸®åŠ©è¿ç§»åˆ°ç±»ä¼¼é—®é¢˜

    ã€è¡¨è¾¾é£æ ¼ã€‘
    - é¢å¯¹é¢è®²è§£çš„å£å»ï¼Œè€å¿ƒã€è½»æ¾  
    - å°½é‡ç”ŸåŠ¨ã€æœ‰ç”»é¢æ„Ÿ  
    - é¿å…åªåˆ—æ¸…å•æˆ–å…¬å¼åŒ–æŒ‡ä»¤

    ã€è¾“å‡ºæ ¼å¼ã€‘
    - åˆ†æ­¥ç¼–å· + å°æ ‡é¢˜ï¼Œä¾¿äºé˜…è¯»  
    - æ¯æ­¥ä¿æŒå®Œæ•´ç»“æ„ï¼ˆæ ‡é¢˜+åšä»€ä¹ˆ+ä¸ºä»€ä¹ˆ+æ³¨æ„äº‹é¡¹+ç»“æœï¼‰  
    - é‡åˆ°æ¦‚å¿µæ—¶ç©¿æ’æ•…äº‹ã€ç±»æ¯”æˆ–å°æ¡ˆä¾‹

    ã€é—®é¢˜å¦‚ä¸‹ã€‘
    ${text}
    `;
    }


    function showAiAlert(message) {
        const modal = document.getElementById("ai-alert-modal");
        const text = document.getElementById("ai-alert-text");
        const btn = document.getElementById("ai-alert-ok");

        if (!modal || !text || !btn) {
            console.error("AI å¼¹çª—å…ƒç´ æœªæ‰¾åˆ°ï¼");
            return;
        }

        text.textContent = message;
        modal.classList.remove("hidden");
        modal.classList.add("show");

        const closeModal = () => {
            modal.classList.remove("show");
            modal.classList.add("hidden");
            btn.removeEventListener("click", closeModal);
            document.removeEventListener("keydown", escHandler);
        };

        const escHandler = (e) => {
            if (e.key === "Escape") closeModal();
        };

        btn.addEventListener("click", closeModal);
        document.addEventListener("keydown", escHandler);
    }

    // ===== æ ‡é¢˜é—ªçƒ =====
    let titleTimer = null;
    let originalTitle = document.title;

    function startTitleFlash(text = "ğŸš¨ã€æ–°æ¶ˆæ¯ã€‘") {
        if (titleTimer) return; // é˜²æ­¢é‡å¤å¯åŠ¨
        titleTimer = setInterval(() => {
            document.title =
                document.title === originalTitle ? text : originalTitle;
        }, 800);
    }

    function stopTitleFlash() {
        if (!titleTimer) return;
        clearInterval(titleTimer);
        titleTimer = null;
        document.title = originalTitle;
    }

    // ===== ç³»ç»Ÿé€šçŸ¥ =====
    function notify(title, body) {
        if (!("Notification" in window)) return;

        if (Notification.permission === "granted") {
            new Notification(title, { body });
        } else if (Notification.permission !== "denied") {
            Notification.requestPermission();
        }
    }

    /*
    * æç¤ºéŸ³
    * */
    const soundBase64 = "data:audio/mp3;base64,//OEZAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAuAAAjQAAFBQsLEBAWFhsbISEhJiYsLDIyNzc9PUJCQkhITU1TU1lZXl5kZGRpaW9vdHR6eoCAhYWFi4uQkJaWm5uhoaGmpqyssrK3t729wsLCyMjNzdPT2dne3uTk5Onp7+/09Pr6//8AAAA5TEFNRTMuOTlyAW4AAAAALg8AABRAJAJAjgAAQAAAI0BgYyYFAAAAAAAAAAAAAAAAAAAA//OEZAAAAAGkAAAAAAAAA0gAAAAA6QQBAEHfB8Hwf+XBAEAx9APg+D/xOCAIHPhgHwfD/xOCAIfEAYB8H/yYIBj4IBgH3+XB94z5QEHB/1g+H/lAx6c5BB2XD//Lvg/EDigYieD5/+GIPy4fghBA5Plwf/lPB9+UDH/4IS7y4f//B+IHCQMScHz//D4CMYe4ts9xJhjYtavsPp5Slxb7+rZKPMlGefvaLU+38lox3Z1455mx04Q8P3z3BTN3XWNj//OERKsH9ALiAKAAAA3QAbgBQAAAGNrb3yMTaL//ciYyDlIUf3b/PWd3rM+Rmu0OxDvI6idvy7/bp78iL+VEQ1Yk+PkbuPraozCB0vDbOPmQ2/9T2+/b2e3/IW99dG9WktqTZ+f9CkCBQwwpBEcgeotCHoAQd5hC0MtN3YQze7xCH+bL8yDD0/d/40Qfdjy0O97rRzsy0SEe7rz7aKztyD2lNbJNOOhDa6aHRU51wy07x+h2VmXaeb7zuZjpRROd//OEZN8SPg72BMSYAKQEJe1BgzABnzqe2qUkC8ghf2Mz72zJ70lDnqZ1kYh6iPOkEU5s/dtPqkD9fZ7fv/+37//6lFv0G7Xca0Zsf/Q/tmD8HTRrEFOgGbZcdx+Bl+Pz6Pz8tBKOV5uUrBw/b4/nskFT6sI6P6X6BSEzhoMeJuGZA0AggJJeZ5HDaC6AX0EF2rN5EEgvItmQrcXGO86T455XQJ83ikQ0sUuThFhzxWgyhCJkmMuomDR1prNBZZuy//OEZGgZwhNHL8xQAAuoamG/gSgAiKEPFlmxuLgPF9FOptNzcvLSI93RIwniGEQIOTzHTculTqQL7s6mbqSHBL5pJt1m6i4USfojgRMya0Nl+t/TL9ZNv5025Ukmqv6aGq///+5iW/l8uGnM1foFxaai4xfdBFNzRA0oCBAAAgAnzAHDGg7Afg/B4AfgRvM/l3nF3JxkP/36f/0f0+c5cp/0fe4//////0r+gAgQrPRO7ST/fiGViEp8PfAjlW4B//OEZBYO6X1zL8e0AA4IGsb/iBACmQybjyQmGW50QkFdHsYEs0cOUSWINVlZqZGKQ/GJbWklMk0F0jU+kiSFE8kgX3psyh8RWX7x7tRfKLzno2WdOLdvMSz/PbJUj1lrUrU/o2//yTSV//Qb//c9/aWHsiyH+tochIhFta6i7W0bYYCjDKqANKPWou9SzqbShAtSirqRQ9Tzm+cy//V7uj/8t//hn//jfOo//9KdVcADAUxCrtm1rLdloLyoTSCP//OEZBEPJeNSu+2oAYwATrZXxxACeSD5Ctpb499RaOzEcl0//P/bEGS9B+zEWapg+Lo/ndZx1fnOcE45+9wugQRZNZE///o8RJL1Vr9SFDvNNNc03//9UC9JTW9UOdipCPVNNNMF5OxdGPJTnR1Odf/9Wm/p//Q1WqaSvtKNQA447fyEvY40Tk9hvpOhuDjlB2s1sdh763/M9f/+fxhq91SGoR/zn////X/9dPYqrAgDnkt1y929SKN2SNc9wGlu//OEZBINXKlnLwsLJQw5woVeC8RMNBJejHO1q3/Xe4klIgDMeTgYVbloidxOe3/918/bq64SRkE4YX9XKYfBweHjHI/VEX5ZUixrP+oG+BgoBBSHhxEqlrFBUJ/aSGPUSBYl8JHTrQaBUsCpKlxgAIFoAHxGLBFmBXxEOdsJIoEVwpro1N1b+b5lOVf9Xr/zN///7//hwgbfd+pb//By8ICckj1083MK//coYFwtjmY1e1GKOWvgGI0l6RX+Exde//OEZCEQCfFY32Wlb41pwpmWC8RK/IhSPLSckUlo2XQQdN0dJFfsky2/WMUo/mIbBIksutBTaSbKf2+yOHn9aIu6+joj3RP/3+oiHhUTVmuMAYw0woZ0JRR5iIe5a6FoX//+uow3/ojI91Yw9jIMU7iG/fnMAKm74YH8z+wEPcPfA9N2Pu1Wfqx/6/i0v9NWUmi80I36hhbdv///E5V/7P/yXHbvt////9P/1GKSkUPb2GUdzAZ08MlQHuMhgABg//OEZBYPFVlIAGzFegtJVrx+AU5e2FGZ2j4HAE6ytd7X43b65MmToEAEHgAg4OFrxo1yYWFp3vvf3u9gmT2CCD2TIGgNcR7tg+Hz0JkI2c56n/9qNt/oRv/8hzukhMhGoKDhryCAcDggAgEFDnwQh///+IAQd/9AlksfuvAhAf4N936KaifapfqppxpH/b/9v2EAToVCJ5Uf/f/yn/1CJ3IOM5Gl/VbGalS+3Zh1uZiyOGvzM0EqONkxYhSBhTjO//OEZBsM3V1MAG0NagrqtrS+OAXGU7QfjRUVqG5VFixgsU+NCGhpRRwfC16r2qzq6wpq6kq1B9KKJqySWiQn6T9T//+Yt///t/19Fv1FRLDmOqSraigSR50TFFzP//8S1EUDAXgf3xUXrUY/////sWofmf///0ChfmH/0+ntXoEAyCi/YEgU5Ap//uFlrAoLsdlm8263MVTh1bpCzAfQ0Q6YhVifl0MsMupSak07cCdVLXlJDxz7eqtl06moNgBQ//OEZDMMrVtlL0hndQwZwoY+DgRMnItVnlA///0r648JRzvmvNq1pputOa3/+lkHxKL/njokmlziQ49f//9qin5WdfLT3rLCAAfgUBOABwhIxiuDiIVO5XIgmjaj1emzGdV2b/a3+z/+lP+cv+//9P/1DduLip2pgABqh2rB+Mpx3TMJceXLyBkUEqzqzVK3UDQktoozyuI/bVRxkKWhygrIpRMRK3p3WzotvhT/yg7//1/mvU90/+////ZOl8Yh//OEZEgMdWtIy2yqbQvxTr5eKES6qN9ONyEXh+TGGI5504jdgNFqHMFtXrWPF2gtUMgApbbJrxcOwgLXwr4lCs7LowjXEyG1u2v/+/rKb+HNytbP87/O7lf/61OR///9CqCAnI5HsoB+fO87KXPlzpEkAGRS5YfWio4BQu5AWdSpn0a+6EYTCyrSIJOFo6ZGRfCr31DTxCorECmAeGjst3QZDb//MVObQ0iYRwsFzJ6siPYytWY2UREmEf//8ohc//OEZF8MiVtM320KXQxpwrpeKE6e071YmeXFQYTs1tv4GHm3wqIjBsO9+z/z2kybGARL/ml/upL+VN////0Db976kJpZb//////L15AIBddtd/Nx+WN+plyj1olkX8+KsMIm0kra14Qj3hrNVai74h6GCEG7Rx0VRCtq1zzs68bc4qE01V9A8Cnf/tq2538qSpvt+jOvm+v//6NNV+ehC50lbX/////+YbUwiQE6iAC/bbkAA+ulglhaUHWMrTNR//OEZHQMSbtZL2UKXQrpxo2eaIq+J1Ty2CJpfZRFzv+/pb3hhf1hbf///6jL/9SgQS2Sy7OgfvDUxYqPM5aYgVyJQPEsSMLAjTCWWsbPZvGf7iOA5NcYH0c1RQLS0cGXdGZiLTlXSfUaqhrJlTzADQnZepwHDxO/69tHp0eaQLtRa2TaxFHOmmb1//+rFf7IwlaHrikAB210a6ADnGMjrEwciVIN9eqtp2fYqc57scn/6rWr//3A9Ox6r///Vf0///OEZJEMnVVK360cAYzqeqJfRzgDdbdf///sXXqUACCQSCQkgAj5rb7+3rphz9kxhF7NQs6SAQRmNGixYyTQK2B2IQFDY5wuADdAAbnBjJ+IPSNBmw6cT6VTT5Bz5Bx8ClBySgVRjg1H7G6aYy4oMZMWMUiHoivEDICr8bAy5Ey6MuOM0KRFiLmRPECJT/00y+bnkzcnCbKyy6XTiTpf/mnst0EGTSdJ6ZwyRUbI//+tM0W6CFDJxBCgii5wyWii//OEZKMYthdQys1QAAfwsqm5ixACcI0R+IatN1///+yaaZo0uGlBaZcNG/ZSWkxw1p1Vm5fJ4uRAgsCgUAAUAAcfxk/NaF1K2osaCd9ukL/gx0H//4ZENY2AQ3GrJaE3jD63j0khwnyBxYQJYVyHgzXuvqviwQfEjjjpvVva+mabKhpxUKiQ1IXONGo8c6mDzmmfvU1lU2cJiTpVv811QZpqdXc45urfMNN///////+IREGxp3+7/J//qw0QAAog//OEZGgMhX1rL+ecAQwQUom/yxAACrYLP++Pg2Bk6qIMvHUfDUye61m3T+T9/HO8pb/7Oqr//0hz/+JP//q3f/0q2RDDm11v+l1MelljGPlTlb8g5THJKFaEe3rxO1ui2eWXDHT3pOdNsdSDmsAqJpKhOe3HUTUpWO2RTzmXSbvVjHopEX6sqLzeapMei/nPb1N5siOOm+nT/zlT///o4TQLWnfTzv/////tshN5dJoLio1AActEAwCFNyDE22Qs//OEZH4OBfNrLz1qa4wgcr5eAM4GYG/1H3MABMUmg4oj6jxEABf//oyydC//////yH////63bk3QAGxW/qLreOt3KWAoTef0ZJoYfWnjAKNMy5VQeBxg0OG3kCNBl+HsKrPXZ1++1Vr3OPcsZNfHw7Oi8dlJjqM2lZMM2EpM1pvdNWhqtW3WsxqOYT9jc1zTqKhRS6VN2R0alpx3tvfZJvd9+tOz///O4Mh8YYcj9UspKbo///2dXVvt3qdmHExp//OEZIgRjfVCz3FqbIvYUs5eAIoOE8WxE4PQAJbhbeBBykTWvFaBm9QeNCJ1MBZH958laNo9CNvu5FP/////4iR////+97QGWaAAHGo3bDZ3WedaU6vXapCTokyRsZgkyy16ktQNfL+s0et/eJZnPOoMSD6xJN+lIe/f/31uhUmrpvNSBFevXjy8WzsYgiFspPzI8e/EDX2qzKJKtXrLR7Ja/1P2uZO+bNu7JVRVrN///8RAtv7nyms4t292rbsw//OEZHcQCclK323lawzJZrpeOEba0IHvrOmKGPtkBWAA5Q5LsGL0dLa6hDRQn+nxwqWn//U+R5BP1Ln/6dpDyr/W5t7bf9H///6lHP////0yyvQQ5tLb/rs7aR6ewz1NikBBEIcLCK4BIwa2YSqPfJNLCyOzWa4izUrSzWhIFCEMwazCp4mOXvsTyR1s9NT6KWWhEzZlWZGe6IpEXRDT6Xmv81UrPqah2as37NTt0Xp//7oJQ+Ks//vb9f9fsVMb//OEZG4OhclW31DKZwza9r5eCcRH+7nQ5OtJjQACbBzX8UDm1TrxBoC+6POGOnwxP//bR+3yMc5aLSv5W6P/06t6fb//X////////ghNShCAQrrZb/rr2YuLNUYf0e1IgAyKiQoucLD0kXbXc0XuIq5hmeoxn8dtAqooCPB1/r39OlVTsX1/fOXqb10stKNumddzF9KVb7oh3/6ezvof///qaUBIbm3/o/9v/2UiwAgS22UAQD0qYbXUI2OPEX/q//OEZHELzXtXL0kHewra8rJeOAXL39db/qpw2cTBnlm2RGO3fp/+3v///8EMKhiAQ7tdd/ppzNEcxaKnF6KtjcBsDFKAzAXoX3ny3nVsS1KCtYrkJLvyp/+FSwFgj0yCbcDj1dnF1SjKxbaOYjHBuyy7yadUr0L5Wb1Rv/ZF+/n6bzaS///9BbHPk//rb//QAGJRZbQBQP/V8JA2PCkk++iz2v/0/82UbmsaOkTfl6mTU/r36////KFDzVUgAL2m//OEZJIMPXtVL0Uiawry9q2+OAvL5WgP//3NR+htTKdJQ70SwBwpMgMh0SAzIF2GM7h33eanGN5/7bUn0Wy6eC5ZY8QQW4O90/rnpRj0IuULb9WOOZCGqvzv61fLWpY412Uyq30Zyqsp7f//9Lf//91DyNAIVskkoYf+r0DYsaRCj+upZGO1Rs7/c95Efo7TTkf0Otp/f/9f/////8ElBCDm1tv+gH5iuZCWBpyBNgbIiy1hikDKArL05zKaOHRN//OEZK8MXXs6z21nbYq67pkcUAXmA2ZqFUWrozizLZ6LxIEPnn0z/TTyw+DoW6+eyWEeg98uzzSVeQXp2q7nN6kZvuht5fV5/GmdHu6///qYaPCAsQAhEnJvetR5s+ETNiae3XXFyW7umxaN/lIZvwaKRR55QQLWvJ2ccl0S/6P/////7GpwEK2x2/Vgd/9VP33KsVCk8sZIZOU89iwQKxkGXErzscoDRg4SV9LjXswu/qX5Ze2ir17P6sc0WEh5//OEZMwMFX1K300FbQxA4mUYBgQwRzPyoIjDgz536meLMLmLIcikOUYro/du8z/sj//66kXWv///GiAdAoDdw1u/AoH63pwIxSiGdm5KZCL/Mv8g0bxZkR3iISDAB9eOdEEJUElftf/////+oolMQU1FqqpAB2uXfV1/z/wzsM2i8UCr0LHUHtJMa9yIxXWSDJGPsWqQepO9k0RXeIzpobTvP1nb+cjmR7VOFxmVL0jkZfzHV+1XbUV6ngnxtf6p//OEZOUMIXtC32TFaQyBZqZeEEbao9Ften1//6///k6///+wWCGE32//S3/+oCAISja7cagXPo+FS68qo+rX/2UupnWDcgAKI22EK3cdDFNVB2+KkKlNG02Tc6qXf////9f/tTf///+VAI69IaE/j/KadRMHgijScxg2xRhgECRpg+JhlhYhEMSlxgoFhrgXwKDEu8j6OxYjVqPPTePditMwWrM9n/899rx0Og2l1abYY/F7frl3USUhDt7xxA+K//OEZPcMkXssj2zFbg+K9pZeAcQrskPW0SrbWayZvf0X7f2/T///p//6HGgw8e7am/1///tdGJAgMEw22/AoH99OBgJx07pqqKRQc/3LK+9HVnFpcYqhIycaqc1l2j7dGNPPPcM80seanzqWbv///8iAw1E4iL0C/3VfcqVsUk2rHDD62IniPA9FE3XZQhElvDBIfNHrdFlyXKVQcpWsbLT0dr5+5jr+G1sIox1DQ9IjHiFPtamgJyHBlOnRrFuZ//OEZP8O0X8YCXWFag8S+pJeOAvm+FKfVnVdlrS/0Rv9f/f//f27f//8wMCMM3//6P/6ggDwkloYf3eUaoCyzHBltnLjt7f//o9jh2NdGYoVaqXNOOYdVj2bRzXID5hs9B9aVbf6fu///9osMioqH+y7ekkkQ7KDL0VUMSk4a+KYw0GjzUQCEWCAWYwCxgyVII2gxMFpgMXZPkplXN3P/68cvNzIf9vCEGaqvVJW999dE5vodQ3sbrsepW0br06V//OEZPcNSX8cHnFiag56+nGcOAXmttX//+ifXRfvq17bf//slyEGECUIP//2yVXr9NYCYtG//4FA/9GzEPNfmHsiPr/zkTmc01mHSD40KkgNGrPQ9kKuUONYk6olDzjSJ3u31VL0R3u9v//14ppm9+tTwU8SAqy18vKYNP5xYFqaFuD7oDMJBxOQxSAzXE5DAK2kNN+98SpKhiQgodEvYEIsEnndc4NvzQzCCihGQIknGJa1lqtU0jf9m20z9rNv//OEZP0N3X8UBXEibA8K8o2+OAXnc/2/r2/rz7u2ms++3/M8KAgdFwbdxbtRT8hv1k6duLEYAAJm+RN5k9NADHccDm2iyeoHckN7lb32/v+mk6RIkRq0GFMQoARYywdiMAiakyWcTdvvdrR//93/8qCn/po0GTWtVJ+WIBk8LCAULvM24KwqBCqCTzTfAwTFiCY0CZzV+CQ2TRhmkf+1DFZwj4KAQqGrXJ8YzRZQgRFFZUzW56rVahB4UPLzMcQx//OEZP0OUX0QAHBleA+BAjWUDgRMLnRrg57r/p+qLrzqzZq+33u1/pf6/2v+iUPEAnCdyQOabvXmFbjh3oT4sOWrAAMUAb/gabM//bIrBT8t2T1qDKEXlIuYC2J27GXOuxUS1tL89j2iJh7///2fs2//Q7//67v7PjJMQU1FMy45OS4zqiriCQ9mzRoYedVhrtiJ/DFWXkoAcvPLEL1orHOEKVkXmLM/WpdqRW0fR3/r9hqyXc6kZzyPMwiWnq65//OEZPcPGX8OBXBnfA4BaoZeEBDqb1m0tL/9eyItUeTZJPd3L7+ntp////8waxPUL09C/+vwp7457i/R3GiR1WlCTvxL5QFLW7TDQ1b6f9QDcoop4FYysXdrGZb///////rUWCB7///0V/pqEiT4dzjr7u+TAWkdUwE8wADywCBkJmwLOWdRoFRKGn5jCyG/l8NUsmrKQdMVR3vHxunxUbEmgWcrtXU06MukPFc+9XfPl21RXdL87o3SdTTsrb7Z//OEZOYL7XkYCydlGgx4VigIC/BA3erGNdb6t2PffVp6aVzHmt864rDTDo7rATmLeFbCdF9ZvxjdRFjjf0Z0RMeTQsgDpGmRQlwQzJA9emtnof///onrpV0FepSmpKR9duqj7f3////b//2IYd7///1/9epMQU0YSyLIwXcVftM0owxzIl50hGGA3QFA4wQBCwQdwiDwLm7sVlkvqaipUZFbsfZfbKUoRHtXqtV02e0utasrEaXJ/vy0m66eq//+//OEZP8PUX0MBXEHfA4i9iQImAXE/v3/dzZF6c+f19HCwReZX+S0oW29DPSt+ou9qRrT/XBRu3YmDbCg7iQm3+rUvb6J5Fbm7o4wMaaLAkkZtH5hs8KX/o/9PlF9dtVX+3UN/9dn9VGjc7oqTEFNRTMuOTkOwbuFmcGTOE5YUJys9a6Qg5nsiniPA5Zc213KAeB7Grsrq4NfdkolN/VmjylbR8+93pMv+9Nn7/ZuQ5H0mrWxtdHS/9nVu1WzulPM//OEZPQMoXcOBCdlGg6Q5iQqDgpMsnSn21Tb4UYoe74fnGy8mo+wfJEggvQ1NsXUYIAeaZlmzRZvDL6klEEaWjpi6t6XdPTcnWtm8tP+CGmZXX9ySvT/d+z/i1X+v/sYj7nr6/i3uaq7ctlVTEFNRTMuOTkuM1VVVQynuRkAFR7MIfRxGr5CABARuDgoOqgUAphFArHQz9+X1624SFxiI9UnhTOyZCS4MARRInIgNYiNGs9LOPL0qUlMk5mxRZNJ//OEZPcM+XsOBR9iGg644iVqDgRMEWfUgOPz6D1ZVUCDhyLFgO1YsUVqXjzKzVjSLTUgIxCddayzXJsDjABxWYVe8VlRf7gwTuMZV9f4r002X+rjV7UR3Rf2M/S53/TY3uR6GN/1R3/9N38wTEFNRTMuOTkuZu/9HSuHbrvI1ti4MSFHpYQVCH7GAooHCS45rN6OL6RQFWOH7cMn2bZRdWQvBrMPQM2RTXJsydjXUvejWVDqlNHfsl7kInf3/0b6//OEZPINzHEKADNjKAvgVil0CnBAr+pv6Eo0y1o6LVvotK2e0U95uK0qVEKE9l+MaoSooapC2xVRAAEtoFD5ayxgWxcB9uOoQjBrZtfZ2dR+la+e0Wo79P9HUlzvQbUMR9iiKP/j/9v/SyrRTEFNNk4/Pg0BTNW4IEdynZKgRHbBMZ+yQCcp+nwv4UDOOZScC3poUmxgjOKBY4tQqclSD3GECy7oeegcgkHRPBprx0Y4KJL07SBd6qWTjUI12FFC//OEZPYN1XkKAGjCYgzQTiWMCh4kmF6UChpOwAgmLHVIHJCK6l3sWtcqs/YyoY6TettqlBFBnXaSWqxgGBbuuwW8l32voVx3il6Lf34ogX+imPEft193tN9jtF1HquUPJO6P3ntv+pCUM/UqTEFNRTMuOTkuM6qqqqqqqqowHBD88USOhEBFAoTDMw5UviS0mDSmBHPk9LBTUoOv8YIgleRUK/zAzrm/yf+r1q7zLCdk6PjC2+7+9WQ6aEFunp61//OEZPwN6C8KAGdZMA34VhgAMF4E+nVv6qCDy7kc2wgJHfYpb0GgPIMByT1Na63Qpo4IAO1mqkewd8Nc95U9IFkhzAA9FJnsWf06E05Ggc/r1/f7x/y7u/7Rliv9H4iei371jkUI7dSaenoqMbQTujU3MeF8DhFFoFotDZQ+zqQ3EopE6aQRcaBp4YmR4APWQOUTKUTZE82iDrQL0gdiZWW2OatC9QuoKxNvbZb1j7D7DPsP+q4yPCM7Mwtndyx7//OEZO4MAVEMBGwlbg5QUimUW0woAuyTeTMgdAcZNstvXOTmLL1Os9ScxYPq7qxPv4bf3XMSXVl1t/qZa2v/f+7HvPfOGAIm4w4o2zoMvXrGagDxXsX67HUI7kMr/27e1Vuj/7PZa+hDBdDk/+113W3T/9H6qkwB8g4Bvj8LUsJblyyRW6K9kR9AjwdOgbLGWFFWGsBrLKWh4yIdKzBpwBPOLtaIWHJpCQlPRYks5aSrxVAwUbzCX5Z6GNXtex5l//OEZP8QfLUMAG8mCowYTjm+SEoAq2yyRS8m9JxVJ44LDx9R/dFRWcXkYcRrGBXZQyqFtgFTh0NPHXPe5iK9NDh8UepSme+/2WaGL9a65dqVCpkauLd9ljVfopS/SRY/yQ8Z+1W96FIorZG1TEFNRTMuOTkuM1VVVVVVVVUOdNYh78E3zEsZAcGgG5RKpecY1IuMQZoKKCJC0jPuQv5nuc11BCsWa8wISouTeb8G3m3BV2wP3vq3pfW1ZG5ePEQK//OEZPQMPEkIAD4DQg9gThQAGA4gycYzTO1Ck2u9LoVF2GH1BQwFCZQcRawzNoMZ4SM1MfXXMPFHabbhAhanZ7sZtMIUa9b4vaxLE+5SytAxU5Hg4JCbaFrS+feteRWRZc5jbVfeLykhT6EKTEFNRaqqqoIAhDfC3jnyKtSi/BuAmZeXaHyQ5InLmmkIbNtwGBnjxYfYPFgdcFM2yPlRJ1MEZRWMxHmGXRUaYSbV1vreZLlUICqwuLTSlkccbNLf//OEZO4KRCcKFTwtAhHQThQiYJYkPPMRVwqoos69htJtyFvWSHvIQ8DItsndTvWGoFnoNXJmkJQUn0s++pHbC1GotY1E7xdtqK83lulJp8mZpizxh1jVuSiW+lLmvhdatu4mhVViqHs3VMVRTEFNRTMuOTkuM1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQoQQ25Y9HI3wZJLkrctanqL//OEZPgLyCcGADzLABFoThSiYM4kUZGeK7OzvXzHxvV8Wn//pr1JSrTq7fPECttGz//Tq5b0BgMnKIpCzadc1hWdQz0oe5ybO7q1ejR9Guv8S657Fjbbe1O6kdkpY9qv3Lt9Gz/Ia2cl241KTEFNRTMuOTkuM6qqqj5uQJcjx48ASoKzp4S3rbKxNtVU/LHiyzx3PfSVrOrOlVulpFEr4hLHtbuw6IsiS88JUcOeWArlHuVqf+wJHoUPVA1lTsSq//OEZLwGRAcZLxgCAA1gUhlsSEQIDqwpQwWDygsuRtW4ktSg6dePO1RE8jEqwEq7ho8t1pUFTqn8jxFUeEowGj2JTsl4KnVuEQVcVOyXUDS5EsSBqJXA1nm4aiVQFKuLCKIhLjw0lh0GhF66TEFNRTMuOTkuM6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//OEZPIJGALyuQQiABUwBdlAEEYAqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq";
    const soundPlayer = new Audio(soundBase64);
    soundPlayer.preload = "auto";
    soundPlayer.volume = 1;

    function playSound() {
        try {
            if (!soundPlayer.paused) return;
            soundPlayer.currentTime = 0;
            soundPlayer.play();
        } catch (e) {
        }
    }

</script>

<script>
    const checkin_version = null; // è¢«æœåŠ¡ç«¯æ–‡æœ¬æ›¿æ¢
    const checkin_version_number = null;
    const checkin_version_is_beta = null;
    const top_level_path = null;
    const appnames = null;
    const jumpto = null;
    const disallowed_upload = null;
    let logged_admin = false;
    let logged_user = null;


    const default_key = "C******";
    const decrypt_error_string = "è§£å¯†å¤±è´¥ï¼Œæ£€æŸ¥å¯†é’¥ååˆ·æ–°é¡µé¢ã€‚"
    const decrypt_processing_string = "æ­£åœ¨è§£å¯†ã€‚"

    let dragging_item = null;
    const full_width_space = "ã€€";

    function is_theme_dark() {
        return (localStorage.getItem("theme") === "dark");
    }

    // æŒ‰ä½altåæŸäº›å…ƒç´ è®¾ä¸ºæ–‡æœ¬å¯é€‰ // æ²¡ç”¨ä¸Š
    const elements_can_select_text_when_alt_pressed = [];
    elements_can_select_text_when_alt_pressed.add = (element) => {
        elements_can_select_text_when_alt_pressed.push(element);
        element.addEventListener('mousedown', (event) => {
            if (!event.altKey) event.preventDefault();
        });
    }
    elements_can_select_text_when_alt_pressed.remove = (element) => {
        const index = elements_can_select_text_when_alt_pressed.indexOf(element);
        if (index > -1) elements_can_select_text_when_alt_pressed.splice(index, 1);
    }
    document.addEventListener('keydown', (event) => {
        if (event.altKey) {
            for (const element of elements_can_select_text_when_alt_pressed) {
                element.style.userSelect = 'text';
                element.style.cursor = 'auto';
            }
        }
    });
    document.addEventListener('keyup', (event) => {
        if (!event.altKey) {
            for (const element of elements_can_select_text_when_alt_pressed) {
                element.style.userSelect = 'none';
                element.style.cursor = 'pointer';
            }
        }
    });


    function current_url() {
        return new URL(window.location.href);
    }

    function root_url() {
        let url = current_url();
        url.hash = "";
        url.pathname = `${top_level_path}`;
        [...url.searchParams.keys()].forEach(key => {
            url.searchParams.delete(key);
        });
        return url;
    }

    function join_path(url, ...subs) {
        url = new URL(url);
        if (subs.length === 0) return url;
        url.pathname = `${url.pathname.replace(/\/+$/, "")}/${subs.map(i => i.toString()).join("/")}`;
        return url;
    }

    function url_hash_json() {
        let d = {};
        try {
            let hash = current_url().hash.replace(/^#+/, "");
            hash = decodeURIComponent(hash);
            if (hash.length === 0) return d;
            const json = JSON.parse(hash);
            if (!form_field_checker.ffc_object(json)) throw new Error(`æ ¼å¼é”™è¯¯ï¼š${hash}`);
            Object.assign(d, json);
        } catch (e) {
            console.log(e);
        }
        return d;
    }

    function random_choice(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function delete_cookie(key, path = '/', domain) {
        let cookieStr = `${key}=; Max-Age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=${path}; SameSite=Strict`;
        if (domain) cookieStr += `; domain=${domain}`;
        document.cookie = cookieStr;
    }

    async function hash_password(text) {
        // å°†å­—ç¬¦ä¸²è½¬ä¸º Uint8Array
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        // è®¡ç®— SHA-256
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        // è½¬ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function pickBucket(str, arr) {
        if (!str) str = ""
        let hash = 0x811c9dc5
        for (let i = 0; i < str.length; i++) {
            hash ^= str.charCodeAt(i)
            hash = (hash * 0x01000193) >>> 0
        }
        return arr[hash % arr.length]
    }

    function saveFile_from_uint8array(totalArray, fileName) {
        let blob = new Blob([totalArray]);
        return saveFile_from_blob(blob, fileName);
    }

    function saveFile_from_blob(blob, fileName) {
        let a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function saveFile_from_text(result, fileName) {
        const encoder = new TextEncoder();
        const uint8Array = encoder.encode(result);
        saveFile_from_uint8array(uint8Array, fileName);
    }

    function saveFile_from_json(result, fileName) {
        saveFile_from_text(JSON.stringify(result), fileName);
    }

    function date_string_for_fileName() {
        return format_timestamp_utc8(parseInt(Date.now() / 1000), 'YYYY-MM-DD_HH-mm');
    }

    function getImgData(img, callback) {
        console.log(img.width, img.height)
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        // å°† img å†…å®¹ç»˜åˆ¶åˆ° canvas
        ctx.drawImage(img, 0, 0);
        // è·å– Base64
        // const base64 = canvas.toDataURL('image/png');

        // è·å– Blob
        canvas.toBlob(blob => {
            callback(blob);
        }, 'image/png');
    }

    function check_if_contains_file_in_drop_event(event) {
        let contains_file = false;
        for (let i = 0; i < event.dataTransfer.items.length; i++) {
            if (event.dataTransfer.items[i].kind === 'file') {
                contains_file = true;
                break;
            }
        }
        return contains_file;
    }

    const seconds_of_one_hour = 60 * 60;
    const seconds_of_eight_hours = 8 * seconds_of_one_hour;
    const seconds_of_one_day = 24 * seconds_of_one_hour;
    const seconds_of_hours = (hour) => seconds_of_one_hour * hour;
    const seconds_of_minutes = (minute) => 60 * minute;
    const seconds_of_days = (day) => seconds_of_hours(day * 24);

    function format_timestamp_utc8(timestamp, format = 'YYYY-MM-DD HH:mm') {
        if (!timestamp) return "æœªçŸ¥";
        const date = new Date((timestamp + seconds_of_eight_hours) * 1000);
        const map = {
            'YYYY': date.getUTCFullYear(),
            'MM': String(date.getUTCMonth() + 1).padStart(2, '0'),
            'DD': String(date.getUTCDate()).padStart(2, '0'),
            'HH': String(date.getUTCHours()).padStart(2, '0'),
            'mm': String(date.getUTCMinutes()).padStart(2, '0'),
            'ss': String(date.getUTCSeconds()).padStart(2, '0')
        };
        return format.replace(/YYYY|MM|DD|HH|mm|ss/g, matched => map[matched]);
    }

    function format_timestamp_utc(timestamp, format = 'YYYY-MM-DDTHH:mm:ssZ') {
        if (!timestamp) return "æœªçŸ¥";
        const date = new Date((timestamp) * 1000);
        const map = {
            'YYYY': date.getUTCFullYear(),
            'MM': String(date.getUTCMonth() + 1).padStart(2, '0'),
            'DD': String(date.getUTCDate()).padStart(2, '0'),
            'HH': String(date.getUTCHours()).padStart(2, '0'),
            'mm': String(date.getUTCMinutes()).padStart(2, '0'),
            'ss': String(date.getUTCSeconds()).padStart(2, '0')
        };
        return format.replace(/YYYY|MM|DD|HH|mm|ss/g, matched => map[matched]);
    }

    function format_timestamp_utc8_day(timestamp) {
        if (!timestamp) return "æœªçŸ¥";
        const l1 = format_timestamp_utc8(timestamp).split(" ");
        const l2 = format_timestamp_utc8(Date.now() / 1000).split(" ");
        if (l1[0] === l2[0]) return l1[1];
        return l1[0].slice(5);
    }

    function format_timestamp_utc8_day_time(timestamp) {
        if (!timestamp) return "æœªçŸ¥";
        const l1 = format_timestamp_utc8(timestamp).split(" ");
        return l1;
    }

    function format_bytes(bytes, sizes = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]) {
        if (!bytes) return "0 B";
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        let formattedSize = (bytes / Math.pow(1024, i)).toFixed(1);
        if (formattedSize % 1 === 0) formattedSize = parseInt(formattedSize);
        return `${formattedSize} ${sizes[i]}`;
    }

    function format_uploader(uploader) {
        return uploader === logged_user.uid ? "ä½ " : `${uploader}`;
    }

    function format_shared(attr) {
        // åˆ¤æ–­ç”±è°å…±äº«çš„ï¼Œåº”è¯¥å‘ä¸Šæ‰¾åˆ°énosetçš„å§ï¼Ÿ
        // if (attr.uploader !== logged_user.uid) return attr.shared ? `ç”±${attr.uploader}å…±äº«` : "";

        return attr.shared ? "å·²å…±äº«" : "";
    }

    function normalizeName(name) {
        if (!name) return name;
        name = name.replace(/[/\\:*?"<>\r\n\t\f]|^[\s]+|[\s]+$/g, '');
        if (/^\.*$/.test(name)) return ""; // ä¸èƒ½å…¨æ˜¯ç‚¹
        return name;
    }

    function normalizePassword(p) {
        if (!p) return p;
        p = p.replace(/\W+/g, '');
        return p;
    }

    function readFileAsync(file, type = "bytes") {
        // let text = new TextDecoder("utf-8", {fatal: true}).decode(data);
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                if (type === "bytes") {
                    resolve(reader.result); // arrayBuffer
                } else if (type === "text") {
                    let text = reader.result.replace(/^[\uFEFF\u200B\u0000-\u001F]+/, '');
                    resolve(text);
                }
            };
            reader.onerror = () => reject(reader.error);
            if (type === "bytes") {
                reader.readAsArrayBuffer(file);
            } else if (type === "text") {
                reader.readAsText(file);
            }
        });
    }

    async function getAllFilesFromDroppedFolder(entry) {
        const files = [];
        await traverseEntry(entry, [], files);
        return files;
    }

    async function traverseEntry(entry, pathArray = [], files = []) {
        return new Promise((resolve) => {
            if (entry.isFile) {
                entry.file(file => {
                    file.relativePath = [...pathArray, file.name];
                    files.push(file);
                    resolve();
                });
            } else if (entry.isDirectory) {
                const reader = entry.createReader();

                const readAll = () => {
                    reader.readEntries(async entries => {
                        if (entries.length === 0) {
                            resolve(); // done
                        } else {
                            for (const e of entries) {
                                await traverseEntry(e, [...pathArray, entry.name], files);
                            }
                            readAll(); // in case more entries exist
                        }
                    });
                };

                readAll();
            }
        });
    }

    function generateRandomString(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * chars.length);
            result += chars[randomIndex];
        }
        return result;
    }

    function isMobileDevice() {
        const ua = navigator.userAgent || navigator.vendor || window.opera;
        // æ‰‹æœºåˆ¤æ–­
        const isPhone = /Android|iPhone|iPod|Windows Phone/i.test(ua);
        // å¹³æ¿åˆ¤æ–­
        const isTablet = /iPad|Tablet|PlayBook|Silk/i.test(ua);
        return isPhone || isTablet;
    }

    const _isMobileDevice = isMobileDevice();

    function bindMenuForMobile(element, showMenu) {
        let pressTimer;
        element.addEventListener('pointerdown', event => {
            pressTimer = setTimeout(() => showMenu(event), 500);
        });
        element.addEventListener('pointerup', () => clearTimeout(pressTimer));
        element.addEventListener('pointermove', () => clearTimeout(pressTimer));
    }


    /*
    * è¯·æ±‚æ¨¡æ¿
    * */
    const net_fetcher = {
        nf_get: async (url, params, headers) => {
            const _url = new URL(url);
            if (params) {
                for (const key of Object.keys(params)) {
                    if (params[key] === undefined) continue;
                    _url.searchParams.set(key, params[key])
                }
            }
            return await fetch(_url, {
                method: "GET", headers: {
                    ...headers,
                },
            });
        },

        nf_delete: async (url, headers) => {
            return await fetch(url, {
                method: "DELETE", headers: {
                    ...headers,
                },
            });
        },

        nf_post_json: async (url, json, headers) => {
            return await fetch(url, {
                method: "POST", headers: {
                    ...headers,
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(json),
            });
        },

        nf_put_json: async (url, json, headers) => {
            return await fetch(url, {
                method: "PUT", headers: {
                    ...headers,
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(json),
            });
        },

    }


    /*
    * ç±»å‹æ£€æŸ¥
    * */
    const form_field_checker = {
        ffc_string: (value, allow_empty = false) => {
            return ((typeof value === "string") && ((!allow_empty && value.length > 0) || allow_empty))
        },

        ffc_string_int: (value) => {
            if (!(typeof value === "string")) return false;
            if (!/^\d+$/.test(value)) return false;
            return true;
        },

        ffc_string_date: (value) => {
            if (!(typeof value === "string")) return false;
            if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return false;
            return true;
        },

        ffc_string_datetime_utc: (value) => {
            if (!(typeof value === "string")) return false;
            if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/.test(value)) return false;
            return true;
        },

        ffc_bool: (value,) => {
            return ((typeof value === "boolean"))
        },

        ffc_int: (value, allow_great_than = -1) => {
            return ((typeof value === "number") && (value > allow_great_than))
        },

        ffc_array: (value, allow_empty = false) => {
            return (value instanceof Array) && ((!allow_empty && value.length > 0) || allow_empty)
        },

        ffc_object: (value,) => {
            return value !== null && typeof value === 'object' && value.constructor === Object;
        },

        ffc_known: (value, range) => {
            if (range instanceof Array) return range.includes(value);
            return range.hasOwnProperty(value);
        },

    }


    /*
    * åŠ è§£å¯†
    * */
    class Encryptors {
        constructor() {
            this.ors = [];
            this.is_creating = false;
        }

        static Encryptor = class {
            constructor(password) {
                this.password = password;
            }

            // console.log(JSON.stringify(Array.from(crypto.getRandomValues(new Uint8Array(16)))));
            static password_salt = new Uint8Array([123, 148, 39, 173, 6, 29, 41, 39, 216, 104, 177, 152, 227, 38, 73, 104]);

            async init() {
                this.password_key = await this.deriveKeyFromPassword(this.password, Encryptors.Encryptor.password_salt);
            }

            static str2bytes(str) {
                return new TextEncoder().encode(str);
            }

            static bytes2str(bytes) {
                return new TextDecoder().decode(bytes);
            }

            static bytesToBase64(bytes) {
                let binary = '';
                for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
                return btoa(binary);
            }

            static base64ToBytes(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return bytes;
            }

            async deriveKeyFromPassword(password, salt, keyLength = 16) {
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    Encryptors.Encryptor.str2bytes(password),
                    {name: 'PBKDF2'},
                    false,
                    ['deriveKey']
                );

                return crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt,
                        iterations: 1_000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    {name: 'AES-GCM', length: keyLength * 8},
                    false,
                    ['encrypt', 'decrypt']
                );
            }

            async encrypt(plainBytes) {
                const iv = crypto.getRandomValues(new Uint8Array(12));

                let encryptedBytes = await crypto.subtle.encrypt({name: 'AES-GCM', iv}, this.password_key, plainBytes);
                encryptedBytes = new Uint8Array(encryptedBytes);

                const c = new Uint8Array(iv.length + encryptedBytes.length);
                c.set(iv, 0);
                c.set(new Uint8Array(encryptedBytes), iv.length);

                return c;
            }

            async decrypt(encryptedBytes) {
                const iv = encryptedBytes.slice(0, 12);

                const decryptedBytes = await crypto.subtle.decrypt({
                    name: 'AES-GCM',
                    iv
                }, this.password_key, encryptedBytes.slice(12));
                return new Uint8Array(decryptedBytes);
            }
        }

        async create(password) {
            if (!form_field_checker.ffc_string(password)) return;
            const encryptor = new Encryptors.Encryptor(password);
            await encryptor.init();
            this.ors.push(encryptor);
        }

        async clear() {
            this.ors.length = 0;
        }

        async recreate_all(passwords = []) {
            this.is_creating = true;
            await this.clear();
            await this.create(passwords[0]);
            await this.create(default_key);
            for (const password of passwords.slice(1)) await this.create(password);
            this.is_creating = false;
            // console.log(this.ors);
        }

        async encrypt(plain) {
            if (form_field_checker.ffc_string(plain, true)) plain = Encryptors.Encryptor.str2bytes(plain);
            const encryptor = this.ors[0];
            return await encryptor.encrypt(plain);
        }

        async decrypt(cipherText, bare = false) {
            for (let i = 0; i < this.ors.length; i++) {
                const encryptor = this.ors[i];
                try {
                    const decrypted = await encryptor.decrypt(bare ? cipherText : Encryptors.Encryptor.base64ToBytes(cipherText));
                    return decrypted;
                } catch (e) {
                    if (i === this.ors.length - 1) throw e;
                }
            }
            throw new Error("æ²¡æœ‰æ³¨å†ŒEncryptorå¯¹è±¡ã€‚")
        }

        async encrypt2base64(plain) {
            return Encryptors.Encryptor.bytesToBase64(await this.encrypt(plain));
        }

        async decrypt2string(cipherText, bare = false) {
            return Encryptors.Encryptor.bytes2str(await this.decrypt(cipherText, bare));
        }

    }

    const encryptors = new Encryptors();


    /*
    * urlçš„hashé™„å¸¦çš„è®¾ç½®
    * */
    {
        const uhj = url_hash_json();

        let theme = localStorage.getItem("theme") || ""; // ä¸»é¢˜
        if (form_field_checker.ffc_string(uhj.theme, true)) {
            // if (theme.length === 0)
            theme = uhj.theme;
        }
        localStorage.setItem("theme", theme);
    }


    /*
    * é®ç½©
    * */
    class BlurMark {
        constructor(element) {
            this.element = element;
            this.filled = false;
            this.init();
        }

        init() {
            let html = `<div class="blur-mark" role="status" aria-live="polite" aria-label=""></div>`;
            this.element.classList.add("for-blur-mark");
            this.element.insertAdjacentHTML("beforeend", html);
            this.mark = this.element.querySelector(":scope > div.blur-mark:last-of-type");
            this.mark.classList.add("hidden")
        }

        show() {
            if (!this.filled)
                this.fill();
            this.mark.classList.remove("hidden")
        }

        hide() {
            this.mark.classList.add("hidden")
        }

        remove() {
            this.mark.classList.add("hidden")
            this.mark.remove();
            this.element.classList.remove(`for-blur-mark`);
        }

        fill() {
            this.filled = true;
        }

        increase_z() {
            this.mark.style.zIndex = (parseInt(window.getComputedStyle(this.mark).zIndex) + 1).toString();
        }

        is_visible() {
            return !this.mark.classList.contains("hidden");
        }
    }

    class LoadingMark extends BlurMark {
        constructor(element) {
            super(element)
        }

        fill() {
            let html = `
<div class="spinner-ring" aria-hidden="true"></div>
`;
            this.mark.insertAdjacentHTML("beforeend", html);
            this.mark.setAttribute("aria-label", "æ­£åœ¨åŠ è½½");
        }
    }

    class MessageMark extends BlurMark {

        static btnFlags = {
            close: 1,
            confirm: 2,
            _: 4,
        }

        static colors = {
            default: "default",

            red: "#FCD6D6",
            blue: "#E0F2FF",
            // green: "#DBFFE0",
            yellow: "#FFFCDE",
        }

        static colors__theme_dark = {
            red: "#625252",
            blue: "#555d64",
            // green: "#DBFFE0",
            yellow: "#656457",
        }

        constructor(element, message, btn_flags, color, close_callback, confirm_callback) {
            super(element)
            this.message = message;
            this.btn_flags = btn_flags;
            this.close_callback = close_callback;
            this.confirm_callback = confirm_callback;
            this.color = color;
        }

        fill() {
            let html = `
<div id="message-mark-dialog">
    <span id="message-mark-top-margin"></span>
    <div id="message-mark-rect">
        <p id="message-mark-text" class="">${this.message}</p>
        <div id="message-mark-btn-group"></div>
    </div>
    <span id="message-mark-bottom-margin"></span>
</div>
`;
            this.mark.insertAdjacentHTML("beforeend", html);

            this.rect = this.mark.querySelector(":scope div#message-mark-rect");
            this.rect.style.background = MessageMark.get_background_color.call(this);

            this.btn_group = this.mark.querySelector(":scope div#message-mark-btn-group");
            if (this.btn_flags & MessageMark.btnFlags.confirm) {
                this.btn_group.insertAdjacentHTML("beforeend", `<button class="message-mark-btn">ç¡®å®š</button>`);
                let btn = this.btn_group.querySelector(":scope button:last-of-type");
                btn.addEventListener("click", (event) => {
                    if (this.confirm_callback)
                        this.confirm_callback()
                    this.remove()
                });
            }
            if (this.btn_flags & MessageMark.btnFlags.close) {
                const _btn_text = (this.btn_flags & MessageMark.btnFlags.confirm) ? "å–æ¶ˆ" : "å…³é—­";
                this.btn_group.insertAdjacentHTML("beforeend", `<button class="message-mark-btn">${_btn_text}</button>`);
                let btn = this.btn_group.querySelector(":scope button:last-of-type");
                btn.addEventListener("click", (event) => {
                    if (this.close_callback)
                        this.close_callback()
                    this.remove()
                });
            }

        }

        static report(error, element = null, close_callback = null, confirm_callback = null, color = MessageMark.colors.red,) {
            if (error instanceof Error) {// æŸäº›å¼‚å¸¸ï¼Œé‡æ–°ç™»å½•
                const origin_close_callback = close_callback;
                close_callback = () => {
                    if (origin_close_callback) origin_close_callback();
                    checkin.check_exception_to_reload(error);
                };
            }
            const mm = new MessageMark(!element ? document.body : element, error instanceof Error ? `æŠ¥é”™ï¼š${error}` : error, MessageMark.btnFlags.close, color, close_callback, confirm_callback);
            mm.show();
            return mm;
        }

        static confirm(message, element = null, close_callback = null, confirm_callback = null, color = MessageMark.colors.yellow,) {
            const mm = new MessageMark(!element ? document.body : element, message, MessageMark.btnFlags.close | MessageMark.btnFlags.confirm, color, close_callback, confirm_callback);
            mm.show();
            return mm;
        }

        static get_background_color() {
            const colors = MessageMark.colors;
            let color;
            if (Object.values(colors).includes(this.color)) {
                color = this.color;
            } else {
                const cs = Object.keys(colors).filter((i) => {
                    return !["default", "red", "yellow"].includes(i)
                })
                color = colors[random_choice(cs)];
            }
            if (is_theme_dark()) {
                for (const [key, value] of Object.entries(colors)) {
                    if (value === color) {
                        color = MessageMark.colors__theme_dark[key];
                        break;
                    }
                }
            }
            return color;
        }
    }

    class FormMark extends BlurMark {

        constructor(element, form, confirm_callback) {
            super(element)
            this.form = form;
            this.confirm_callback = confirm_callback;

            if (!this.confirm_callback)
                throw new Error("ç¼ºå°‘å‚æ•° confirm_callback");
        }

        fill() {
            let html = `
<div id="form-mark-dialog">
    <span id="form-mark-top-margin"></span>
    <div id="form-mark-rect">
        <div id="form-mark-input-group"></div>
        <div id="form-mark-btn-group"></div>
    </div>
    <span id="form-mark-bottom-margin"></span>
</div>
`;
            this.mark.insertAdjacentHTML("beforeend", html);

            this.rect = this.mark.querySelector(":scope div#form-mark-rect");
            this.rect.style.background = MessageMark.get_background_color.call(this);

            // è¾“å…¥åŒºåŸŸ
            this.input_group = this.mark.querySelector(":scope div#form-mark-input-group");
            for (const formElement of this.form) {
                this.#add_input_element(formElement, this.input_group)
            }

            // æŒ‰é’®
            this.btn_group = this.mark.querySelector(":scope div#form-mark-btn-group");
            {
                this.btn_group.insertAdjacentHTML("beforeend", `<button class="form-mark-btn">ç¡®å®š</button>`);
                let btn = this.btn_group.querySelector(":scope button:last-of-type");
                btn.addEventListener("click", (event) => {
                    this.confirm_callback(this,)
                });
            }
            {
                this.btn_group.insertAdjacentHTML("beforeend", `<button class="form-mark-btn">å–æ¶ˆ</button>`);
                let btn = this.btn_group.querySelector(":scope button:last-of-type");
                btn.addEventListener("click", (event) => {
                    this.remove()
                });
            }
        }

        #add_input_element(row, input_group) {
            if (row.type === "title") {
                this.#add_input_element_title(row, input_group);
            } //
            else if (row.type === "textarea") {
                this.#add_input_element_textarea(row, input_group);
            } //
            else if (row.type === "linetext") {
                this.#add_input_element_linetext(row, input_group);
            } //
            else if (row.type === "combobox") {
                this.#add_input_element_combobox(row, input_group);
            } //
            else if (row.type === "groupbox") {
                this.#add_input_element_groupbox(row, input_group);
            } //
            else if (row.type === "multiselectbutton") {
                this.#add_input_element_multiselectbutton(row, input_group);
            } //
            else if (row.type === "date") {
                this.#add_input_element_date(row, input_group);
            } //
            else if (row.type === "button") {
                this.#add_input_element_button(row, input_group);
            } //
            else if (row.type === "custom") {
                this.#add_input_element_custom(row, input_group);
            } //
            else if (row.type === "number") {
                this.#add_input_element_number(row, input_group);
            }//
            else if (row.type === "noticing") {
                this.#add_input_element_noticing(row, input_group);
            }
        }

        #add_input_element_title(row, input_group) {
            let html = `
<label><span id="form-mark-input-title">${row.label}</span></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
        }

        #add_input_element_textarea(row, input_group) {
            let html = `
<label >${row.label}<textarea wrap="soft"></textarea></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > textarea");

            row.input_element.value = row.value;
            row.input_element.style.width = `${350}px`;
            row.input_element.style.height = `${256}px`;
        }

        #add_input_element_linetext(row, input_group) {
            let html = `
<label>${row.label}<input type="text"></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > input");

            row.input_element.value = row.value;
            row.input_element.placeholder = row.placeholder || "";

            // row.input_element.style.width = `fit-content`;
            // row.input_element.style.maxWidth = `300px`;
            row.input_element.style.width = `30ch`;
        }

        #add_input_element_combobox(row, input_group) {
            let html = `
<label>${row.label}<select></select></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > select");

            for (const optionsKey in row.options) {
                let html = `
<option value="${optionsKey}">${row.options[optionsKey]}</option>
`;
                row.input_element.insertAdjacentHTML("beforeend", html);
                const option = row.input_element.querySelector(":scope > option:last-of-type");
            }

            row.input_element.value = row.value;
        }

        #add_input_element_groupbox(row, input_group) {
            let html = `
<div class="form-mark-input-group"><label class="form-mark-input-group-title">${row.label}</label></div>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.input_group = input_group.querySelector(":scope > .form-mark-input-group:last-of-type");

            for (const formElement of row.form) {
                this.#add_input_element(formElement, row.input_group)
            }
        }

        #add_input_element_multiselectbutton(row, input_group) {
            let html = `
<label>${row.label}<button>${row.label_button}</button><span class="form-mark-input-multiselectbutton-value">${row.display}</span></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > button");
            row.input_element.addEventListener("click", (event) => {
                row.callback(event, this, row);
            });

            row.display_element = row.label_element.querySelector(":scope .form-mark-input-multiselectbutton-value");
        }

        #add_input_element_date(row, input_group) {
            let html = `
<label>${row.label}<input type="date"></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > input");

            row.input_element.value = format_timestamp_utc8(row.value ? row.value : (Date.now() / 1000) + (30 * seconds_of_one_day), "YYYY-MM-DD");
        }

        #add_input_element_button(row, input_group) {
            let html = `
<label>${row.label}<button>${row.label_button}</button></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > button");
            row.input_element.addEventListener("click", (event) => {
                row.callback(event, this, row);
            });
        }

        #add_input_element_custom(row, input_group) {
            let html = `
<!--<label>${row.label}-->
<div class="form-mark-input-custom"></div>
<!--</label>-->
`;
            input_group.insertAdjacentHTML("beforeend", html);
            // row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = input_group.querySelector(":scope > div:last-of-type");
            row.add_element(this, row);
        }

        #add_input_element_number(row, input_group) {
            let html = `
<label>${row.label}<input type="number"></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > input");

            row.input_element.value = row.value.toString();
            row.input_element.min = row.min.toString();
            row.input_element.max = row.max.toString();

            row.input_element.style.width = `30ch`;
        }

        #add_input_element_noticing(row, input_group) {
            let html = `
<label>${row.label}<span class="form-mark-input-noticing">${row.text}</span></label>
`;
            input_group.insertAdjacentHTML("beforeend", html);
            row.label_element = input_group.querySelector(":scope > label:last-of-type");
            row.input_element = row.label_element.querySelector(":scope > span");
        }

        collect_data(form = undefined) {
            if (!form) form = this.form;
            for (const row of form) {
                if (row.type === "textarea") {
                    row.value = row.input_element.value;
                } else if (row.type === "linetext") {
                    row.value = row.input_element.value;
                } else if (row.type === "combobox") {
                    row.value = row.input_element.value;
                } else if (row.type === "groupbox") {
                    this.collect_data(row.form);
                } else if (row.type === "date") {
                    let selected = row.input_element.value;
                    if (form_field_checker.ffc_string_date(selected)) {
                        selected = new Date(selected);
                        row.value = Math.floor(selected.getTime() / 1000) - seconds_of_eight_hours;
                    } else {
                        row.value = 0;
                    }
                } else if (row.type === "custom") {
                    row.collect_data(this, row);
                } else if (row.type === "number") {
                    row.value = parseInt(row.input_element.value);
                }
            }

        }

        static get_global_input(form, confirm_callback, parent_element) {
            const fm = new FormMark(parent_element ? parent_element : document.body, form, confirm_callback);
            fm.show();
            return fm;
        }

    }

    class ImageMark extends BlurMark {
        constructor(element) {
            super(element)

            this.file_name = null;
            this.file_data = null;

            this.scale = 1;
            this.originX = 0;
            this.originY = 0;
            this.startX = 0;
            this.startY = 0;
            this.isDragging = false;
            this.offsetX = 0;
            this.offsetY = 0;
        }

        fill() {
            if (is_theme_dark()) {
                this.mark.style.background = "rgba(255, 255, 255, 0.1)";
            } else {
                this.mark.style.background = "rgba(255, 255, 255, 0.7)";
            }
            let html = `
<div class="image-mark-rect">

<img src="" alt="" draggable="false">

<div class="image-mark-top-actions">
    <span class="image-mark-action-gap"></span>
    <button class="image-mark-top-actions-saveas">å¦å­˜ä¸º</button>
    <button class="image-mark-top-actions-close">âœ•</button>
</div>

<!--<div class="image-mark-bottom-actions">-->
<!--    <span class="image-mark-action-gap"></span>-->
<!--    <button class="image-mark-bottom-actions-"></button>-->
<!--</div>-->

</div>
`;
            this.mark.insertAdjacentHTML("beforeend", html);
            this.rect = this.mark.querySelector(":scope .image-mark-rect");
            this.e_img = this.rect.querySelector(":scope > img");

            this.e_top_action_close = this.rect.querySelector(":scope button.image-mark-top-actions-close");
            this.e_top_action_close.addEventListener("click", () => {
                this.file_name = null;
                this.file_data = null;
                URL.revokeObjectURL(this.tempurl);
                this.remove();
            });

            this.e_top_action_saveas = this.rect.querySelector(":scope button.image-mark-top-actions-saveas");
            this.e_top_action_saveas.addEventListener("click", () => {
                if (!this.file_name) return;
                // getImgData(this.e_img, (blob) => {
                //     saveFile_from_blob(blob, this.file_name);
                // });
                saveFile_from_uint8array(this.file_data, this.file_name);
            });


            {
                // æ»šè½®ç¼©æ”¾
                this.rect.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const rectBounds = this.rect.getBoundingClientRect();

                    // é¼ æ ‡ç›¸å¯¹äºå›¾ç‰‡å·¦ä¸Šè§’çš„ä½ç½®
                    const mouseX = event.clientX - rectBounds.left - this.offsetX;
                    const mouseY = event.clientY - rectBounds.top - this.offsetY;

                    const zoom = event.deltaY < 0 ? 1.1 : 0.9;
                    this.scale *= zoom;

                    // è°ƒæ•´ offsetï¼Œä½¿ç¼©æ”¾ä»¥é¼ æ ‡ä¸ºä¸­å¿ƒ
                    this.offsetX -= (mouseX) * (zoom - 1);
                    this.offsetY -= (mouseY) * (zoom - 1);

                    this.updateTransform();
                });

                // æŒ‰ä½æ‹–åŠ¨
                this.rect.addEventListener('mousedown', (event) => {
                    this.isDragging = true;
                    this.startX = event.clientX - this.offsetX;
                    this.startY = event.clientY - this.offsetY;
                });

                document.addEventListener('mousemove', (event) => {
                    if (!this.isDragging) return;
                    this.offsetX = event.clientX - this.startX;
                    this.offsetY = event.clientY - this.startY;
                    this.updateTransform();
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

            }

        }

        centerAndFit() {
            const rectW = this.rect.clientWidth;
            const rectH = this.rect.clientHeight;
            const imgW = this.e_img.naturalWidth;
            const imgH = this.e_img.naturalHeight;

            // è®¡ç®—é€‚åˆæ¯”ä¾‹
            if (imgW > rectW || imgH > rectH) {
                const scaleX = (rectW - 40) / imgW;
                const scaleY = (rectH - 40) / imgH;
                this.scale = Math.min(scaleX, scaleY);
            } else {
                this.scale = 1;
            }

            // å±…ä¸­ä½ç½®
            this.offsetX = (rectW - imgW * this.scale) / 2;
            this.offsetY = (rectH - imgH * this.scale) / 2;

            this.updateTransform();
        }

        updateTransform() {
            this.e_img.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.scale})`;
        }

        load_from_uint8array(file_name, file_data) {
            this.file_name = file_name;
            this.file_data = file_data;

            const blob = new Blob([this.file_data]);
            this.tempurl = URL.createObjectURL(blob);

            this.e_img.src = this.tempurl;
            this.e_img.onload = () => {
                this.centerAndFit();
                this.centerAndFit__timer = null;
                window.addEventListener('resize', () => {
                    if (!this.is_visible()) return;
                    if (this.centerAndFit__timer) clearTimeout(this.centerAndFit__timer);
                    this.centerAndFit__timer = setTimeout(() => {
                        this.centerAndFit();
                    }, 200);
                });
            };
        }
    }

    class BlankMark {
        constructor(element,) {
            this.element = element;
            this.filled = false;
            this.init();
        }

        init() {
            let html = `<div class="blank-mark" role="status" aria-live="polite" aria-label=""></div>`;
            this.element.classList.add("for-blank-mark");
            this.element.insertAdjacentHTML("beforeend", html);
            this.mark = this.element.querySelector(":scope > div.blank-mark:last-of-type");
            this.mark.classList.add("hidden")
        }

        show() {
            if (!this.filled)
                this.fill();
            this.mark.classList.remove("hidden")
        }

        remove() {
            this.mark.classList.add("hidden")
            this.mark.remove();
            this.element.classList.remove("for-blank-mark");
        }

        fill() {
            this.filled = true;
        }
    }

    class MenuMark extends BlankMark {
        constructor(element, color, emit_position, call_after_close) {
            super(element)
            this.color = color;
            this.emit_position = emit_position;
            this.call_after_close = call_after_close;
            this.items = [];
        }

        fill() {
            super.fill();
            let html = `
<div id="menu-mark-dialog">
    <div id="menu-mark-rect">
    </div>
</div>
`;
            this.mark.insertAdjacentHTML("beforeend", html);

            this.dialog = this.mark.querySelector(":scope div#menu-mark-dialog");
            this.dialog.addEventListener('click', (event) => {
                if (event.target !== this.dialog)
                    return;
                this.remove();
                if (this.call_after_close)
                    this.call_after_close();
            });

            this.rect = this.mark.querySelector(":scope div#menu-mark-rect");
            this.rect.style.background = MessageMark.get_background_color.call(this);

        }

        static exec(emit_position, items, call_after_close) {
            let mm = new MenuMark(document.body, MessageMark.colors.blue, emit_position, call_after_close);
            mm.fill();
            for (const item of items) {
                if (item.type === "button") {
                    mm.add_button(item);
                } else if (item.type === "section") {
                    mm.add_section(item);
                }
            }
            mm.show();
            mm.move_to();
            return mm;
        }

        move_to() {
            const menu = this.rect;
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            let x = this.emit_position.x;
            let y = this.emit_position.y;
            if (x + menuWidth > viewportWidth) {
                x = viewportWidth - menuWidth - 10;
            }
            if (y + menuHeight > viewportHeight) {
                y = viewportHeight - menuHeight;
            }
            menu.style.left = `${x + window.scrollX}px`;
            menu.style.top = `${y + window.scrollY}px`;
        }

        add_button(item) {
            let html = `<button class="menu-mark-action-btn">${item.text}</button>`;
            this.rect.insertAdjacentHTML("beforeend", html);
            let btn = this.rect.querySelector(":scope button:last-of-type");
            this.items.push(btn);

            if (item.disabled) {
                btn.setAttribute("disabled", "");
            } else {
                btn.addEventListener("click", (event) => {
                    if (item.callback)
                        item.callback();
                    this.remove();
                    if (this.call_after_close)
                        this.call_after_close();
                });
            }
        }

        add_section(item) {
            let html = `
<div class="menu-mark-action-section">
    <span class="menu-mark-action-section-text">${item.text}</span>
    <hr class="menu-mark-action-section-hr"/>
</div>
`;
            this.rect.insertAdjacentHTML("beforeend", html);
            let section = this.rect.querySelector(":scope div.menu-mark-action-section:last-child");
            if (item.text.length === 0) {
                section.querySelector(":scope span").classList.add("hidden")
                section.style.maxHeight = "3px";
            }
            this.items.push(section);
        }
    }

    function remove_simple_loading_mark(element) {
        if (element.simple_loading_mark) element.simple_loading_mark.remove();
        element.simple_loading_mark = new LoadingMark(element);
    }

    /*
    * æ ‘æ§ä»¶
    * */
    class TreeWidget {

        static clicking_direction = {
            header: 0,
            item: 1,
            blank: 2,
        }

        constructor(parent_element, headers, fill_menu, can_fold, as_item, can_click, align_right, item_margin_lr) {
            this.parent_element = parent_element;
            this.headers = headers;
            this.fill_menu = fill_menu;
            this.can_fold = can_fold; // bool | 2=always fold
            this.as_item = as_item; // ä½¿summaryæœ‰hoveræ•ˆæœ
            this.can_click = can_click;  // ä½¿summaryæœ‰activeæ•ˆæœ
            this.align_right = align_right; // å†…å®¹å³å¯¹é½
            this.item_margin_lr = item_margin_lr; // è‡ªå®šä¹‰å·¦å³ç¼©è¿›

            this.tree_headers = [];
            this.tree_items = [];
            this.header_btns = []

            this.init();
            this.init_headers();

        }

        init() {
            let html = `
<details class="tree-widget">
  <summary>
    <div class="tree-headers"></div>
  </summary>
<!--  <div class="tree-items-warp">-->
    <ul class="tree-items"></ul>
<!--  </div>-->
</details>
`;
            this.parent_element.classList.add("for-tree-widget");
            this.parent_element.insertAdjacentHTML("beforeend", html);
            this.details = this.parent_element.querySelector(":scope details.tree-widget:last-of-type");
            this.details.classList.add("hidden")
            this.summary = this.details.querySelector(":scope > summary");
            this.container_tree_headers = this.details.querySelector(":scope div.tree-headers");
            this.container_tree_items = this.details.querySelector(":scope ul");

            if (!this.can_fold) {
                this.details.open = true;
                this.details.addEventListener('toggle', (e) => {
                    if (!this.details.open) {
                        this.details.open = true;
                    }
                });
                this.summary.addEventListener('click', (e) => {
                    if (!this.header_btns.includes(e.target)) {
                        e.preventDefault();
                    }
                });
            } else if (this.can_fold === 2) {
                this.details.open = false;
                this.details.addEventListener('toggle', (e) => {
                    if (!this.details.open) {
                        this.details.open = false;
                    }
                });
                this.summary.addEventListener('click', (e) => {
                    if (!this.header_btns.includes(e.target)) {
                        e.preventDefault();
                    }
                });
            } else {
                this.summary.style.cursor = "pointer";
            }

            if (this.as_item) {
                this.summary.classList.add("as-item");

                if (this.can_click) {
                    this.summary.addEventListener('mousedown', (event) => {
                        if (!this.header_btns.includes(event.target)) {
                            this.summary.classList.add('hold')
                        }
                    });
                    this.summary.addEventListener('mouseup', (event) => {
                        if (!this.header_btns.includes(event.target)) {
                            this.summary.classList.remove('hold')
                        }
                    });
                    // this.summary.addEventListener('dragend', (event) => {
                    //     this.summary.classList.remove('hold')
                    // });
                }
            }

            if (this.align_right) {
                this.container_tree_items.classList.add("align-right");
                if (form_field_checker.ffc_int(this.item_margin_lr)) {
                    this.container_tree_items.style.paddingRight = `${this.item_margin_lr}px`;
                }
            } else {
                if (form_field_checker.ffc_int(this.item_margin_lr)) {
                    this.container_tree_items.style.paddingLeft = `${this.item_margin_lr}px`;
                }
            }


            const showMenu = (event) => {
                let items = [];
                let clicking_info = {};
                if (this.fill_menu) {
                    clicking_info = {
                        tree_widget: this, event,

                        tree_item: event.target.closest(".tree-item"),

                        summary: event.target.closest("summary"),
                        tree_header: event.target.closest(".tree-header"),
                    }
                    clicking_info.direction = clicking_info.summary ? TreeWidget.clicking_direction.header :
                        (clicking_info.tree_item ? TreeWidget.clicking_direction.item : TreeWidget.clicking_direction.blank);

                    items.push(...this.fill_menu(clicking_info));
                }

                if (items.length === 0)
                    return;
                event.preventDefault();

                let highlighted = false;
                if (clicking_info.direction === TreeWidget.clicking_direction.item) {
                    clicking_info.tree_item.classList.add("active");
                    highlighted = true;
                }

                let rect = clicking_info?.tree_item?.getBoundingClientRect();
                let position;
                if (rect) {
                    position = {x: rect.left, y: rect.top + rect.height,};
                } else {
                    rect = this.container_tree_headers.getBoundingClientRect();
                    position = {x: rect.left, y: event.clientY,};
                }

                // MenuMark.exec({x: event.clientX, y: event.clientY,}, items, () => {
                MenuMark.exec(position, items, () => {
                    if (highlighted) {
                        clicking_info.tree_item.classList.remove("active");
                    }
                });
            };

            // èœå•
            this.parent_element.addEventListener("contextmenu", event => showMenu(event));
            if (_isMobileDevice) bindMenuForMobile(this.parent_element, showMenu);

        }

        init_headers() {
            for (const header of this.headers) {
                let html = `
<span class="tree-header">${header.text}</span>
`;
                this.container_tree_headers.insertAdjacentHTML("beforeend", html);
                let tree_header = this.container_tree_headers.querySelector(":scope > span.tree-header:last-of-type");
                this.tree_headers.push(tree_header);

                header.element = tree_header;

                if (header.width === -1) {
                    tree_header.style.flexGrow = "1";
                } else {
                    tree_header.style.width = `${header.width}px`;
                }
            }
        }

        set_raw_header(html) {
            this.container_tree_headers.insertAdjacentHTML("beforeend", html);
            this.raw_header = this.container_tree_headers.querySelector(":scope > :first-child");
        }

        add_item(...attrs) {
            for (const attr of attrs) {
                let html = `<li class="tree-item"></li>`;
                this.container_tree_items.insertAdjacentHTML("beforeend", html);
                let tree_item = this.container_tree_items.querySelector(":scope > li.tree-item:last-of-type");
                this.tree_items.push(tree_item);

                tree_item.attr = attr;

                if (attr.clickable) {
                    tree_item.dataset.clickable = "true";
                    tree_item.addEventListener("click", (event) => {
                        attr.clickable(event);
                    });
                }

                this.update_item(tree_item);
            }
        }

        update_item(tree_item) {
            const item_columns = tree_item.querySelectorAll(":scope > span.tree-item-column, :scope > label.tree-item-column");
            for (const itemColumn of item_columns) itemColumn.remove();

            const attr = tree_item.attr;
            let c = 0;
            for (const column of attr.columns) {
                let header = this.headers[c];
                c++;
                let item_column;
                if (column.checkbox) {
                    let html = `<label class="tree-item-column"><input type="checkbox"></label>`;
                    tree_item.insertAdjacentHTML("beforeend", html);
                    item_column = tree_item.querySelector(":scope > label.tree-item-column:last-of-type");
                } else {
                    let html = `<span class="tree-item-column">${column.text}</span>`;
                    tree_item.insertAdjacentHTML("beforeend", html);
                    item_column = tree_item.querySelector(":scope > span.tree-item-column:last-of-type");
                }
                if (header.width === -1) {
                    item_column.style.flexGrow = "1";
                } else {
                    item_column.style.width = `${header.width}px`;
                }
                if (!column.selectable) {
                    item_column.style.userSelect = "none";
                }
                if (column.inactive) {
                    item_column.classList.add("column-mark-inactive")
                }
                if (column.highlight) {
                    item_column.classList.add("column-mark-highlight")
                }
            }
        }

        remove_item(tree_item) {
            tree_item.remove();
            this.tree_items.splice(this.tree_items.indexOf(tree_item), 1)
        }

        remove_all_items() {
            for (const treeItem of this.tree_items) {
                treeItem.remove();
            }
            this.tree_items.length = 0;
        }

        show() {
            this.details.classList.remove("hidden")

            window.addEventListener('resize', (event) => this.resize_container_tree_items());
            this.resize_container_tree_items()
        }

        remove() {
            this.details.classList.add("hidden")
            this.details.remove();
            this.parent_element.classList.remove("for-tree-widget");
        }

        resize_container_tree_items() {
            const summaryHeight = this.summary.offsetHeight;
            // const outerHeight = this.details.parentElement.clientHeight;
            this.container_tree_items.style.height = `calc(100% - ${summaryHeight}px)`;
        }
    }


    /*
    * æ‚¬æµ®çƒ
    * */
    class FloatBall {
        constructor(parent_element) {
            const html = `<div class="float-ball"></div>`;
            this.parent_element = parent_element;
            this.parent_element.insertAdjacentHTML("beforeend", html);
            this.ball = this.parent_element.querySelector(":scope > div.float-ball");
            this.ball.addEventListener("click", this.ballClicked.bind(this));
            this.dialog = new FloatBall.FloatBallDialogMark(document.querySelector("body"));
            this.setText();

            // â€”â€” æ–°å¢é è¾¹éšè—æ•ˆæœï¼ˆå»¶è¿Ÿå›å»ï¼‰ â€”â€” //
            let hideTimeout = null;

            this.ball.addEventListener('mouseenter', () => {
                // é¼ æ ‡é è¿‘ï¼Œæ˜¾ç¤ºæ‚¬æµ®çƒ
                this.ball.classList.add('show');
                // å¦‚æœä¹‹å‰æœ‰å»¶è¿Ÿéšè—ï¼Œå–æ¶ˆå®ƒ
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                    hideTimeout = null;
                }
            });

            this.ball.addEventListener('mouseleave', () => {
                // é¼ æ ‡ç¦»å¼€åå»¶è¿Ÿéšè—
                hideTimeout = setTimeout(() => {
                    this.ball.classList.remove('show');
                }, 2000); // å»¶è¿Ÿ 2 ç§’ï¼Œå¯æ ¹æ®éœ€æ±‚è°ƒæ•´
            });

            // æ‹–æ”¾
            this.ball.addEventListener('dragenter', (event) => {
                if (!dragging_item) return;
                event.preventDefault();
                this.ball.classList.add("drag-active");
            });
            this.ball.addEventListener('dragover', (event) => {
                if (!dragging_item) return;
                event.preventDefault();
                this.ball.classList.add("drag-active");
            });
            this.ball.addEventListener('dragleave', () => {
                if (!dragging_item) return;
                this.ball.classList.remove("drag-active");
            });
            this.ball.addEventListener('drop', async (event) => {
                if (!dragging_item) return;
                event.preventDefault();
                this.ball.classList.remove("drag-active");

                if (dragging_item.constructor?.name === TreeWidget.name && dragging_item.attr?.did) { // ç½‘ç›˜item
                    checkin.current_content_page.download(null, dragging_item);
                }

            });
        }

        setText(s) {
            if (s) {
                this.ball.textContent = s.toString();
            } else {
                this.ball.textContent = "â˜";
            }
        }

        setOpacity(i) {
            this.ball.style.opacity = `${i}`; // 0-1
        }

        show() {
            this.ball.classList.remove("hidden");
        }

        hide() {
            this.ball.classList.add("hidden");
        }

        ballClicked(event) {
            if (this.dialog.mark.classList.contains("hidden")) {
                this.showDialog();
            } else {
                this.hideDialog();
            }
        }

        showDialog() {
            this.dialog.show();
        }

        hideDialog() {
            this.dialog.hide();
        }


        static taskstatus = {
            waiting: "æ­£åœ¨æ’é˜Ÿ...",
            processing: "æ­£åœ¨{}...",
            finalizing: "æœ€ç»ˆé˜¶æ®µ...",
            failed: "{}å¤±è´¥ã€‚",
            finished: "{}å®Œæˆã€‚",
        }

        /*
        * ä»»åŠ¡å¯¹è±¡
        * */
        static tasktypes = (() => {
            class _ {
                constructor(task_container, callbacks) {
                    this.task_container = task_container;
                    this.callbacks = {
                        onfinished: null,
                        onfailed: null,
                        onprogress: null,
                        onwaiting: null,
                    };
                    if (callbacks) Object.assign(this.callbacks, callbacks);
                    this.filled = false;
                    this.backtask_btns = [];
                    this.status = null;
                    this.name = null;
                    this.args = {};
                    this.error_string = "";
                }

                init() {
                    const html = `<div class="backtask-rect">

<div class="backtask-content">
    <p class="backtask-name"></p>
    <div class="backtask-progress-bar">
        <div class="backtask-progress sliding-bar-animation"></div>
    </div>
    <p class="backtask-status-text"></p>
</div>

<div class="backtask-btns">
    <button class="backtask-btn-cancel"><i class="backtask-btnicon"></i></button>
    <button class="backtask-btn-retry"><i class="backtask-btnicon"></i></button>
</div>

</div>`;
                    this.task_container.insertAdjacentHTML("beforeend", html);
                    this.rect = this.task_container.querySelector(":scope > div.backtask-rect:last-of-type");

                    this.backtask_name = this.rect.querySelector(":scope .backtask-name");
                    this.backtask_status_text = this.rect.querySelector(":scope .backtask-status-text");
                    this.backtask_progress_bar = this.rect.querySelector(":scope div.backtask-progress-bar");
                    this.backtask_progress = this.rect.querySelector(":scope div.backtask-progress");
                    this.backtask_progress.classList.remove("sliding-bar-animation");

                    this.backtask_btn_cancel = this.rect.querySelector(":scope .backtask-btn-cancel");
                    this.backtask_btn_retry = this.rect.querySelector(":scope .backtask-btn-retry");
                    this.backtask_btns.push(this.backtask_btn_cancel);
                    this.backtask_btns.push(this.backtask_btn_retry);

                    this.backtask_btn_cancel.addEventListener("click", (event) => {
                        this.stop();
                    });
                    this.backtask_btn_retry.addEventListener("click", (event) => {
                        floatball.dialog.retryToStartTask(this);
                    });

                    this.rect.classList.add("hidden")
                }

                fill() {
                    this.filled = true;
                }

                show() {
                    if (!this.filled)
                        this.fill();
                    this.rect.classList.remove("hidden")
                }

                remove() {
                    this.rect.classList.add("hidden")
                    this.rect.remove();
                }

                set_name(s) {
                    this.name = s;
                    this.backtask_name.textContent = s;
                }

                set_args(i) {
                    Object.assign(this.args, i);
                }

                start() {
                    console.log("åå°ä»»åŠ¡ å¯åŠ¨", this);
                    this.update_status_text(FloatBall.taskstatus.processing);
                }

                stop() {
                    console.log("åå°ä»»åŠ¡ åœæ­¢", this);
                    // çŠ¶æ€æ”¹å˜åœ¨å›è°ƒå‡½æ•°é‡Œ
                    // this.update_status_text(FloatBall.taskstatus.failed);
                    // floatball.dialog.checkToStartTask();
                }

                update_progress(i) {
                    console.log("åå°ä»»åŠ¡ è¿›åº¦å˜åŒ–", `${i}%`);
                    if (i === -1) {
                        this.backtask_progress.style.width = `30%`;
                        this.backtask_progress.classList.add("sliding-bar-animation");
                    } else if (i === 100) {
                        this.backtask_progress.classList.remove("sliding-bar-animation");
                        this.backtask_progress.style.width = `${i}%`;
                    } else {
                        this.backtask_progress.classList.remove("sliding-bar-animation");
                        this.backtask_progress.style.width = `${i}%`;
                        if (this.status === FloatBall.taskstatus.processing) {
                            this.update_progress_text(i);
                            if (this.callbacks.onprogress) this.callbacks.onprogress();
                        }
                    }
                }

                update_progress_text(i) {
                }

                update_status_text(ts) {
                    this.status = ts;
                    this.backtask_btn_cancel.classList.add("hidden");
                    this.backtask_btn_retry.classList.add("hidden");

                    if (ts === FloatBall.taskstatus.waiting) {
                        this.backtask_btn_cancel.classList.remove("hidden");
                        this.update_progress(0);
                    } else if (ts === FloatBall.taskstatus.processing) {
                        this.backtask_btn_cancel.classList.remove("hidden");
                        this.update_progress(0);
                    } else if (ts === FloatBall.taskstatus.finalizing) {
                        this.backtask_btn_cancel.classList.remove("hidden");
                        this.update_progress(-1);
                    } else if (ts === FloatBall.taskstatus.finished) {
                        this.update_progress(100);
                        this.backtask_progress_bar.classList.add("hidden");
                    } else if (ts === FloatBall.taskstatus.failed) {
                        this.backtask_btn_retry.classList.remove("hidden");
                        this.update_progress(0);
                    }
                }

            }

            class Upload extends _ {
                constructor(task_container, callbacks) {
                    super(task_container, callbacks)
                    Object.assign(this.args, {
                        lstartindex: 0,
                        total: 0,
                        curr: 0,
                    })
                }

                fill() {
                    super.fill();
                }

                start() {
                    super.start();
                    this.core();
                }

                stop() {
                    super.stop();
                    if (this.status === FloatBall.taskstatus.waiting) {
                        this.error_string = "è¢«ç”¨æˆ·å–æ¶ˆ";
                        this.update_status_text(FloatBall.taskstatus.failed);
                        floatball.dialog.checkToStartTask();
                        return;
                    }
                    if (this.xhr) {
                        console.log(this.xhr, this.xhr.abort,);
                        this.xhr.abort();
                        this.xhr.canceled = true;
                    }
                }

                update_progress_text(i) {
                    super.update_progress_text(i);
                    this.backtask_status_text.textContent = this.status.replace("{}", "ä¸Šä¼ ") + `${i}%, ${format_bytes(this.args.curr)} / ${format_bytes(this.args.total)}`;
                }

                update_status_text(ts) {
                    super.update_status_text(ts);
                    if (ts === FloatBall.taskstatus.waiting) {
                        this.backtask_status_text.textContent = ts;
                        if (this.callbacks.onwaiting) this.callbacks.onwaiting();
                    } else if (ts === FloatBall.taskstatus.processing) {
                        this.backtask_status_text.textContent = ts.replace("{}", "ä¸Šä¼ ");
                    } else if (ts === FloatBall.taskstatus.finalizing) {
                        this.backtask_status_text.textContent = ts;
                    } else if (ts === FloatBall.taskstatus.finished) {
                        this.backtask_status_text.textContent = ts.replace("{}", "ä¸Šä¼ ");
                        if (this.callbacks.onfinished) this.callbacks.onfinished();
                    } else if (ts === FloatBall.taskstatus.failed) {
                        this.backtask_status_text.textContent = ts.replace("{}", "ä¸Šä¼ ") + this.error_string;
                        if (this.callbacks.onfailed) this.callbacks.onfailed();
                    }
                }

                async core() {
                    try {
                        if (!this.result1) {
                            this.result1 = await checkin.subviews.drive.new_file(this.name, this.args.file, this.args.current_path_item.attr.type === contentpages._drive.path_item_type.root ? undefined : this.args.current_path_item.attr.did);
                            // console.log(this.result1);
                        }

                        const callbacks = {
                            onprogress: (event) => {
                                if (event.lengthComputable) {
                                    const percentComplete = Math.round(((event.loaded + this.args.lstartindex) / (event.total + this.args.lstartindex)) * 100);
                                    this.args.total = event.total
                                    this.args.curr = event.loaded
                                    if (percentComplete === 100) {
                                        this.update_status_text(FloatBall.taskstatus.finalizing);
                                    } else {
                                        this.update_progress(percentComplete);
                                    }
                                }
                            },

                            onload: (event) => {
                                if (this.xhr.status === 200) {
                                    console.log("åå°ä»»åŠ¡ ä¸Šä¼  æˆåŠŸ", event);
                                    this.update_status_text(FloatBall.taskstatus.finished);
                                } else {
                                    console.error("åå°ä»»åŠ¡ ä¸Šä¼  å¤±è´¥", this.xhr.status, this.xhr.statusText, event);
                                    this.error_string = format_xhr_error_response(this.xhr);
                                    this.update_status_text(FloatBall.taskstatus.failed);
                                }
                                floatball.dialog.checkToStartTask();
                            },

                            onerror: (event) => {
                                console.error("åå°ä»»åŠ¡ ä¸Šä¼  è¯·æ±‚é”™è¯¯", event);
                                this.error_string = format_xhr_error_response(this.xhr);
                                this.update_status_text(FloatBall.taskstatus.failed);
                                floatball.dialog.checkToStartTask();
                            },

                            onabort: (event) => {
                                console.error("åå°ä»»åŠ¡ ä¸Šä¼  å–æ¶ˆ", event);
                                this.error_string = "è¢«ç”¨æˆ·å–æ¶ˆ";
                                this.update_status_text(FloatBall.taskstatus.failed);
                                floatball.dialog.checkToStartTask();
                                this.xhr.canceled = true;
                            },
                        }
                        this.xhr = await checkin.subviews.drive.upload(this.result1.did, this.args, callbacks);

                    } catch (error) {
                        console.error("åå°ä»»åŠ¡ ä¸Šä¼  å¼‚å¸¸", error);
                        this.error_string = error.toString();
                        this.update_status_text(FloatBall.taskstatus.failed);
                        floatball.dialog.checkToStartTask();
                        // MessageMark.report(error,);
                    }

                }
            }

            class Upload_ChatMessage extends Upload {
                constructor(task_container, callbacks) {
                    super(task_container, callbacks)
                    Object.assign(this.args, {})
                }

                async core() {
                    try {
                        const callbacks = {
                            onprogress: (event) => {
                                if (event.lengthComputable) {
                                    const percentComplete = Math.round(((event.loaded + this.args.lstartindex) / (event.total + this.args.lstartindex)) * 100);
                                    this.args.total = event.total
                                    this.args.curr = event.loaded
                                    if (percentComplete === 100) {
                                        this.update_status_text(FloatBall.taskstatus.finalizing);
                                    } else {
                                        this.update_progress(percentComplete);
                                    }
                                }
                            },

                            onload: (event) => {
                                if (this.xhr.status === 200) {
                                    console.log("åå°ä»»åŠ¡ ä¸Šä¼  æˆåŠŸ", event);
                                    this.update_status_text(FloatBall.taskstatus.finished);
                                } else {
                                    console.error("åå°ä»»åŠ¡ ä¸Šä¼  å¤±è´¥", this.xhr.status, this.xhr.statusText, event);
                                    this.error_string = format_xhr_error_response(this.xhr);
                                    this.update_status_text(FloatBall.taskstatus.failed);
                                }
                                floatball.dialog.checkToStartTask();
                            },

                            onerror: (event) => {
                                console.error("åå°ä»»åŠ¡ ä¸Šä¼  è¯·æ±‚é”™è¯¯", event);
                                this.error_string = format_xhr_error_response(this.xhr);
                                this.update_status_text(FloatBall.taskstatus.failed);
                                floatball.dialog.checkToStartTask();
                            },

                            onabort: (event) => {
                                console.error("åå°ä»»åŠ¡ ä¸Šä¼  å–æ¶ˆ", event);
                                this.error_string = "è¢«ç”¨æˆ·å–æ¶ˆ";
                                this.update_status_text(FloatBall.taskstatus.failed);
                                floatball.dialog.checkToStartTask();
                                this.xhr.canceled = true;
                            },
                        }
                        this.xhr = await checkin.subviews.chat.send_file(this.args, callbacks);

                    } catch (error) {
                        console.error("åå°ä»»åŠ¡ ä¸Šä¼  å¼‚å¸¸", error);
                        this.error_string = error.toString();
                        this.update_status_text(FloatBall.taskstatus.failed);
                        floatball.dialog.checkToStartTask();
                        // MessageMark.report(error,);
                    }

                }
            }

            class Download extends _ {
                constructor(task_container, callbacks) {
                    super(task_container, callbacks)
                    Object.assign(this.args, {
                        controller: null,

                        total: null,
                        curr: 0,
                        chunks: [],
                    })
                }

                fill() {
                    super.fill();
                }

                start() {
                    super.start();
                    this.core();
                }

                stop() {
                    super.stop();
                    if (this.status === FloatBall.taskstatus.waiting) {
                        this.error_string = "è¢«ç”¨æˆ·å–æ¶ˆ";
                        this.update_status_text(FloatBall.taskstatus.failed);
                        floatball.dialog.checkToStartTask();
                        return;
                    }
                    if (this.args.controller) {
                        console.log(this.args.controller, this.args.controller.abort,);
                        this.args.controller.abort();
                        this.args.controller.canceled = true;
                    }
                }

                update_progress_text(i) {
                    super.update_progress_text(i);
                    this.backtask_status_text.textContent = this.status.replace("{}", "ä¸‹è½½") + `${i}%, ${format_bytes(this.args.curr)} / ${format_bytes(this.args.total)}`;
                }

                update_status_text(ts) {
                    super.update_status_text(ts);
                    if (ts === FloatBall.taskstatus.waiting) {
                        this.backtask_status_text.textContent = ts;
                        if (this.callbacks.onwaiting) this.callbacks.onwaiting();
                    } else if (ts === FloatBall.taskstatus.processing) {
                        this.backtask_status_text.textContent = ts.replace("{}", "ä¸‹è½½");
                    } else if (ts === FloatBall.taskstatus.finalizing) {
                        this.backtask_status_text.textContent = ts;
                    } else if (ts === FloatBall.taskstatus.finished) {
                        this.backtask_status_text.textContent = ts.replace("{}", "ä¸‹è½½");
                        if (this.callbacks.onfinished) this.callbacks.onfinished();
                    } else if (ts === FloatBall.taskstatus.failed) {
                        this.backtask_status_text.textContent = ts.replace("{}", "ä¸‹è½½") + this.error_string;
                        if (this.callbacks.onfailed) this.callbacks.onfailed();
                    }
                }

                async core() {
                    try {

                        const callbacks = {
                            onprogress: () => {
                                let percentComplete = Math.round((this.args.curr / this.args.total) * 100);
                                if (percentComplete === 100) {
                                    this.update_status_text(FloatBall.taskstatus.finalizing);
                                } else {
                                    this.update_progress(percentComplete);
                                }
                            },

                            onload: () => {
                                console.log("åå°ä»»åŠ¡ ä¸‹è½½ æˆåŠŸ",);
                                this.update_status_text(FloatBall.taskstatus.finished);
                                floatball.dialog.checkToStartTask();
                            },

                        }
                        await checkin.subviews.drive.download(this.args.did, this.args, callbacks);

                    } catch (error) {
                        console.error("åå°ä»»åŠ¡ ä¸‹è½½ å¼‚å¸¸", error);
                        this.error_string = error.toString();
                        this.update_status_text(FloatBall.taskstatus.failed);
                        floatball.dialog.checkToStartTask();
                        // MessageMark.report(error,);
                    }

                }
            }

            class Download_ChatMessage extends Download {
                constructor(task_container, callbacks) {
                    super(task_container, callbacks)
                    Object.assign(this.args, {})
                }

                async core() {
                    try {

                        const callbacks = {
                            onprogress: () => {
                                let percentComplete = Math.round((this.args.curr / this.args.total) * 100);
                                if (percentComplete === 100) {
                                    this.update_status_text(FloatBall.taskstatus.finalizing);
                                } else {
                                    this.update_progress(percentComplete);
                                }
                            },

                            onload: () => {
                                console.log("åå°ä»»åŠ¡ ä¸‹è½½ æˆåŠŸ",);
                                this.update_status_text(FloatBall.taskstatus.finished);
                                floatball.dialog.checkToStartTask();
                            },

                        }
                        await checkin.subviews.chat.download(this.args, callbacks);

                    } catch (error) {
                        console.error("åå°ä»»åŠ¡ ä¸‹è½½ å¼‚å¸¸", error);
                        this.error_string = error.toString();
                        this.update_status_text(FloatBall.taskstatus.failed);
                        floatball.dialog.checkToStartTask();
                        // MessageMark.report(error,);
                    }

                }
            }

            return {Upload, Download, Upload_ChatMessage, Download_ChatMessage,};
        })()


        /*
        * å¼¹å‡ºçª—å£
        * */
        static FloatBallDialogMark = class extends BlurMark {
            constructor(element) {
                super(element)
                this.tab_btns = [];
                this.tab_contents = [];
                this.tasks = [];
            }

            fill() {
                super.fill();
                let html = `
<div id="floatball-mark-dialog">
    <span id="floatball-mark-top-margin"></span>
    <div id="floatball-mark-rect">
        <div class="floatball-mark-tabbar">
           <button id="floatball-mark-tab-settings">è®¾ç½®</button>
<!--           <button id="floatball-mark-tab-backtasks">åå°ä»»åŠ¡</button>-->
           <button id="floatball-mark-tab-backtasks__upload">ä¸Šä¼ </button>
           <button id="floatball-mark-tab-backtasks__download">ä¸‹è½½</button>
        </div>
        <div class="floatball-mark-tabcontent">

<!--è®¾ç½®-->
<div class="floatball-mark-tabcontent-settings">
<label>å½“å‰å¯†é’¥ï¼š<input type="text" id="fbm-settings-currentkey" style="width:200px;" placeholder="ç”¨äºåŠ è§£å¯†ï¼Œç•™ç©ºä½¿ç”¨é»˜è®¤"></label>
<label>å†å²å¯†é’¥ï¼š<textarea id="fbm-settings-legacykeys" style="width:200px;height:100px;" placeholder="æ›¾ç»ç”¨è¿‡çš„å¯†é’¥ï¼Œæ¯è¡Œä¸€ä¸ªï¼Œç”¨äºè§£å¯†å†å²æ¶ˆæ¯"></textarea></label>
</div>

<!--åå°ä»»åŠ¡-->
<div class="floatball-mark-tabcontent-backtasks">
</div>

<!---->
        </div>
    </div>
    <span id="floatball-mark-bottom-margin"></span>
</div>
`;
                this.mark.insertAdjacentHTML("beforeend", html);

                this.rect = this.mark.querySelector(":scope div#floatball-mark-rect");
                this.rect.style.background = MessageMark.get_background_color.call(this);

                this.dialog = this.mark.querySelector(":scope div#floatball-mark-dialog");
                this.dialog.addEventListener('click', (event) => {
                    if (event.target !== this.dialog)
                        return;
                    floatball.hideDialog();
                });

                // tab contents
                this.tab_content_settings = this.mark.querySelector(".floatball-mark-tabcontent-settings");
                this.tab_contents.push(this.tab_content_settings)

                this.tab_content_backtasks = this.mark.querySelector(".floatball-mark-tabcontent-backtasks");
                this.tab_contents.push(this.tab_content_backtasks)

                // tab buttons
                this.tab_btn_settings = this.mark.querySelector("#floatball-mark-tab-settings");
                this.tab_btn_settings.addEventListener('click', (event) => {
                    this.switchTab(this.tab_btn_settings);
                });
                this.tab_btns.push(this.tab_btn_settings)

                // this.tab_btn_backtasks = this.mark.querySelector("#floatball-mark-tab-backtasks");
                // this.tab_btn_backtasks.addEventListener('click', (event) => {
                //     this.switchTab(this.tab_btn_backtasks);
                // });
                // this.tab_btns.push(this.tab_btn_backtasks)

                this.tab_btn_backtasks__upload = this.mark.querySelector("#floatball-mark-tab-backtasks__upload");
                this.tab_btn_backtasks__upload.addEventListener('click', (event) => {
                    this.switchTab(this.tab_btn_backtasks__upload);
                });
                this.tab_btns.push(this.tab_btn_backtasks__upload)

                this.tab_btn_backtasks__download = this.mark.querySelector("#floatball-mark-tab-backtasks__download");
                this.tab_btn_backtasks__download.addEventListener('click', (event) => {
                    this.switchTab(this.tab_btn_backtasks__download);
                });
                this.tab_btns.push(this.tab_btn_backtasks__download)


                // è®¾ç½®
                this.e_settings_currentkey = this.tab_content_settings.querySelector(":scope #fbm-settings-currentkey");
                this.e_settings_legacykeys = this.tab_content_settings.querySelector(":scope #fbm-settings-legacykeys");

            }

            show() {
                if (encryptors.is_creating) return;

                this.element.classList.add("for-blur-mark");
                super.show()

                const _ = this.unfinishedTasks();
                if (_[FloatBall.tasktypes.Upload.name].length > 0) {
                    this.switchTab(this.tab_btn_backtasks__upload)
                    _[FloatBall.tasktypes.Upload.name][0].rect.scrollIntoView({behavior: 'smooth', block: 'center'});
                } else if (_[FloatBall.tasktypes.Download.name].length > 0) {
                    this.switchTab(this.tab_btn_backtasks__download)
                    _[FloatBall.tasktypes.Download.name][0].rect.scrollIntoView({behavior: 'smooth', block: 'center'});
                }

                if (!this.currentTab()) {
                    this.switchTab(this.tab_btn_settings)
                }

                this.loadSettings()
            }

            hide() {
                if (encryptors.is_creating) return;

                super.hide()
                // this.element.classList.remove("for-blur-mark");
                this.saveSettings()
            }

            switchTab(t) {
                for (const tabBtn of this.tab_btns) {
                    tabBtn.classList.remove("active");
                }
                t.classList.add("active");

                for (const tabContent of this.tab_contents) {
                    tabContent.classList.add("hidden");
                }

                if (t === this.tab_btn_settings) {
                    this.tab_content_settings.classList.remove("hidden")
                    // } else if (t === this.tab_btn_backtasks) {
                    //     this.tab_content_backtasks.classList.remove("hidden")
                } else if (t === this.tab_btn_backtasks__upload) {
                    this.tab_content_backtasks.classList.remove("hidden")
                    this.checkToHideTask();
                } else if (t === this.tab_btn_backtasks__download) {
                    this.tab_content_backtasks.classList.remove("hidden")
                    this.checkToHideTask();
                }
            }

            currentTab() {
                for (const tabBtn of this.tab_btns) {
                    if (tabBtn.classList.contains("active")) {
                        return tabBtn;
                    }
                }
                return null;
            }

            loadSettings() {
                const uhj = url_hash_json();


                const legacykeys = JSON.parse(localStorage.getItem("legacykeys")) || [];
                if (form_field_checker.ffc_array(uhj.legacykeys)) {
                    uhj.legacykeys.forEach(i => {
                        i = i.replace(/[\r\n]+/g, "");
                        if (!legacykeys.includes(i)) legacykeys.push(i);
                    });
                }
                let currentkey = localStorage.getItem("currentkey") || "";
                currentkey = currentkey.replace(/[\r\n]+/g, "");
                if (form_field_checker.ffc_string(uhj.currentkey)) {
                    uhj.currentkey = uhj.currentkey.replace(/[\r\n]+/g, "");
                    if (currentkey.length === 0) {
                        currentkey = uhj.currentkey;
                    } else {
                        if (!legacykeys.includes(currentkey)) legacykeys.unshift(currentkey);
                        if (!legacykeys.includes(uhj.currentkey)) legacykeys.unshift(uhj.currentkey);
                        currentkey = uhj.currentkey; // ç”¨æœ¬åœ°å­˜å‚¨é‡Œçš„åŠ å¯†å§ï¼Ÿä¸
                    }
                    this.e_settings_currentkey.value = currentkey;
                } else {
                    this.e_settings_currentkey.value = currentkey;
                }
                this.e_settings_legacykeys.value = legacykeys.join("\n");

            }

            saveSettings() {
                const currentkey = this.e_settings_currentkey.value.replace(/^[\s\f]+|[\s\f]+$/g, "");
                localStorage.setItem("currentkey", currentkey);

                let legacykeys = this.e_settings_legacykeys.value.split(/[\r\n]+/g).map((i) => {
                    return i.replace(/^[\s\f]+|[\s\f]+$/g, "");
                });
                legacykeys = legacykeys.reduce((acc, cur) => {
                    if (!acc.includes(cur) && cur.length > 0) acc.push(cur);
                    return acc;
                }, []);
                localStorage.setItem("legacykeys", JSON.stringify(legacykeys));

                encryptors.recreate_all([currentkey, ...legacykeys]);
            }

            addTask(t) {
                t.init();
                t.show();
                t.update_status_text(FloatBall.taskstatus.waiting);
                this.tasks.push(t);
            }

            checkToStartTask() {
                const ttmap = {
                    [FloatBall.tasktypes.Upload.name]: [],
                    [FloatBall.tasktypes.Download.name]: [],
                };
                for (const task of this.tasks) {
                    if (task.constructor.name.startsWith(FloatBall.tasktypes.Upload.name)) {
                        ttmap[FloatBall.tasktypes.Upload.name].push(task);
                    } else if (task.constructor.name.startsWith(FloatBall.tasktypes.Download.name)) {
                        ttmap[FloatBall.tasktypes.Download.name].push(task);
                    }
                }
                for (const ttmapKey in ttmap) {
                    const tlist = ttmap[ttmapKey];
                    let processing = false;
                    for (const tlistElement of tlist) {
                        if (tlistElement.status === FloatBall.taskstatus.processing || tlistElement.status === FloatBall.taskstatus.finalizing) processing = true;
                    }
                    if (!processing) {
                        for (const tlistElement of tlist) {
                            if (tlistElement.status === FloatBall.taskstatus.waiting) {
                                tlistElement.start();
                                break;
                            }
                        }
                    }
                }
                floatball.updateText();
            }

            retryToStartTask(t) {
                if (t.status === FloatBall.taskstatus.failed) {
                    console.log("åå°ä»»åŠ¡ é‡è¯•", t);
                    t.update_status_text(FloatBall.taskstatus.waiting);
                    this.checkToStartTask();
                }
            }

            checkToHideTask() {
                const current_tab = this.currentTab();
                if (current_tab === this.tab_btn_backtasks__upload) {
                    for (const task of this.tasks) {
                        if (task.constructor.name.startsWith(FloatBall.tasktypes.Upload.name)) {
                            task.rect.classList.remove("hidden");
                        } else {
                            task.rect.classList.add("hidden");
                        }
                    }
                } else if (current_tab === this.tab_btn_backtasks__download) {
                    for (const task of this.tasks) {
                        if (task.constructor.name.startsWith(FloatBall.tasktypes.Download.name)) {
                            task.rect.classList.remove("hidden");
                        } else {
                            task.rect.classList.add("hidden");
                        }
                    }
                }
            }

            checkToHide(task) {
                const current_tab = this.currentTab();
                if (current_tab === this.tab_btn_backtasks__upload) {
                    if (!task.constructor.name.startsWith(FloatBall.tasktypes.Upload.name)) {
                        task.rect.classList.add("hidden");
                    }
                } else if (current_tab === this.tab_btn_backtasks__download) {
                    if (!task.constructor.name.startsWith(FloatBall.tasktypes.Download.name)) {
                        task.rect.classList.add("hidden");
                    }
                } else {
                    task.rect.classList.add("hidden");
                }
            }

            unfinishedTasks() {
                const result = {};
                const ttmap = {
                    [FloatBall.tasktypes.Upload.name]: [],
                    [FloatBall.tasktypes.Download.name]: [],
                };
                for (const ttmapKey in ttmap) result[ttmapKey] = [];

                for (const task of this.tasks) {
                    if (task.constructor.name.startsWith(FloatBall.tasktypes.Upload.name)) {
                        ttmap[FloatBall.tasktypes.Upload.name].push(task);
                    } else if (task.constructor.name.startsWith(FloatBall.tasktypes.Download.name)) {
                        ttmap[FloatBall.tasktypes.Download.name].push(task);
                    }
                }
                for (const ttmapKey in ttmap) {
                    const tlist = ttmap[ttmapKey];
                    for (const tlistElement of tlist) {
                        if (tlistElement.status !== FloatBall.taskstatus.finished) result[ttmapKey].push(tlistElement);
                    }
                }
                return result;
            }

        }


        /*
        * æ›´æ–°çƒä¸Šçš„æ–‡æœ¬
        * */
        updateText() {
            const _ = this.dialog.unfinishedTasks();
            const unfinished_task_count = _[FloatBall.tasktypes.Upload.name].length + _[FloatBall.tasktypes.Download.name].length;
            if (unfinished_task_count > 0) {
                this.setText(unfinished_task_count);
                return;
            }

            this.setText();
        }

        look_upload_tasks(t) {
            this.showDialog();
            this.dialog.switchTab(this.dialog.tab_btn_backtasks__upload);
            if (t) t.rect.scrollIntoView({behavior: 'smooth', block: 'center'});
        }

        look_download_tasks(t) {
            this.showDialog();
            this.dialog.switchTab(this.dialog.tab_btn_backtasks__download);
            if (t) t.rect.scrollIntoView({behavior: 'smooth', block: 'center'});
        }
    }

    const floatball = new FloatBall(document.querySelector("main"));
    floatball.showDialog();
    floatball.hideDialog();
    floatball.hide();


    async function format_error_response(resp) {
        return `${resp.status} ${resp.url} ${await resp.text()}`;
    }

    function format_xhr_error_response(xhr) {
        try {
            return `${xhr.status} ${xhr._url} ${xhr.responseText}`;
        } catch (e) {
            const text = new TextDecoder('utf-8').decode(xhr.response);
            return `${xhr.status} ${xhr._url} ${text}`;
        }
    }

    /*
    * å‘èµ·è¯·æ±‚
    * */
    const subviews = (() => {
        class _ {
            constructor(client, api_path) {
                this.client = client;
                this.api_path = api_path;
            }

            api_url() {
                return join_path(root_url(), ...this.api_path);
            }
        }

        class Api extends _ {
            constructor(client) {
                super(client, ["api",]);
            }

            async auth(account, password) {
                let url = join_path(this.api_url(), "auth");
                let body = {account, password_hash: await hash_password(password),}
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }
        }

        class Admin extends _ {
            constructor(client) {
                super(client, ["admin", "api",]);
            }

            async auth(password) {
                let url = join_path(this.api_url(), "auth");
                let body = {password,}
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    // let d = await r.json();
                    // this.session_key = d.session_key; // æ”¹ä¸ºè®¾ç½®cookieså§
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_group_list() {
                let url = join_path(this.api_url(), "group", "list");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async new_group(form) {
                let url = join_path(this.api_url(), "group",);
                let body = [];
                for (const formElement of form) {
                    body.push({
                        gid: formElement["åç§°"],
                    })
                }
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async delete_group(gid) {
                let url = join_path(this.api_url(), "group", gid);
                let r = await net_fetcher.nf_delete(url,);
                if (r.status === 200) {
                    return
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_user_list() {
                let url = join_path(this.api_url(), "user", "list");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async new_user(form) {
                let url = join_path(this.api_url(), "user",);
                let body = [];
                for (const formElement of form) {
                    body.push(await this._form2json_user(formElement))
                }
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_user_attr(uid) {
                let url = join_path(this.api_url(), "user", uid);
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_group_attr(gid) {
                let url = join_path(this.api_url(), "group", gid);
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async _form2json_user(form, is_edit = false) {
                if (!is_edit && form["å¯†ç "].length === 0) throw new Error("å¯†ç ");
                const d = {
                    uid: form["åç§°"],
                    password_hash: form["å¯†ç "].length > 0 ? await hash_password(form["å¯†ç "]) : "",
                    disabled: form["åœç”¨"],
                    contact_any: form["å…è®¸ä¸»åŠ¨ä¸æ‰€æœ‰ç”¨æˆ·é€šä¿¡"],
                    manage_drive: form["å…è®¸ç®¡ç†æ‰€æœ‰ç”¨æˆ·çš„ç½‘ç›˜"],
                    free_space: form["å‚¨å­˜ç©ºé—´"],

                    groups: form["æ‰€å±ç»„"],
                    contact_groups: form["å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç»„é€šä¿¡"],
                    contact_users: form["å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç”¨æˆ·é€šä¿¡"],

                };
                return d;
            }

            async _form2json_group(form, is_edit = false) {
                const d = {
                    gid: form["åç§°"],
                };
                return d;
            }

            async edit_user(form, old_uid) {
                let url = join_path(this.api_url(), "user", old_uid);
                let body = await this._form2json_user(form, true);
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async edit_group(form, old_gid) {
                let url = join_path(this.api_url(), "group", old_gid);
                let body = await this._form2json_group(form, true);
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async delete_user(uid) {
                let url = join_path(this.api_url(), "user", uid);
                let r = await net_fetcher.nf_delete(url,);
                if (r.status === 200) {
                    return
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_disk_usage() {
                let url = join_path(this.api_url(), "service", "disk");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_activity(gid, date_utc) {
                let url;
                if (gid === null) {
                    url = join_path(this.api_url(), "activity");
                } else {
                    url = join_path(this.api_url(), "group", gid, "activity");
                }
                let params = {date: date_utc,};
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async drop_tables() {
                let url = join_path(this.api_url(), "service", "drop_tables",);
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    // let d = await r.json();
                    // return d;
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async clear_drive() {
                let url = join_path(this.api_url(), "service", "clear_drive",);
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    // let d = await r.json();
                    // return d;
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async backup() {
                let url = join_path(this.api_url(), "service", "backup",);
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async restore(json) {
                let url = join_path(this.api_url(), "service", "restore",);
                let body = {...json,};
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    // let d = await r.json();
                    // return d;
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_candidate_word_list() {
                let url = join_path(this.api_url(), "candidate_word", "list");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async add_candidate_word(word) {
                let url = join_path(this.api_url(), "candidate_word",);
                let body = word;
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async add_candidate_words(words) {
                let url = join_path(this.api_url(), "candidate_word",);
                let body = words;
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async edit_candidate_word(word, new_word) {
                let url = join_path(this.api_url(), "candidate_word", encodeURIComponent(word));
                let body = {word: new_word};
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async delete_candidate_word(word) {
                let url = join_path(this.api_url(), "candidate_word", encodeURIComponent(word));
                let r = await net_fetcher.nf_delete(url,);
                if (r.status === 200) {
                    return;
                }
                throw new Error(await format_error_response(r));
            }

            async reset_candidate_word_counts() {
                let url = join_path(this.api_url(), "candidate_word", "reset");
                let body = {};
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_all_people_notice_list() {
                let url = join_path(this.api_url(), "all_people_notice", "list");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async add_all_people_notice(content, enabled) {
                let url = join_path(this.api_url(), "all_people_notice",);
                let body = {content: content, enabled: enabled};
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async edit_all_people_notice(id, content, enabled) {
                let url = join_path(this.api_url(), "all_people_notice", id);
                let body = {content: content, enabled: enabled};
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async delete_all_people_notice(id) {
                let url = join_path(this.api_url(), "all_people_notice", id);
                let r = await net_fetcher.nf_delete(url,);
                if (r.status === 200) {
                    return;
                }
                throw new Error(await format_error_response(r));
            }

            async delete_user(uid) {
                let url = join_path(this.api_url(), "user", uid);
                let r = await net_fetcher.nf_delete(url,);
                if (r.status === 200) {
                    return;
                }
                throw new Error(await format_error_response(r));
            }

            async delete_group(gid) {
                let url = join_path(this.api_url(), "group", gid);
                let r = await net_fetcher.nf_delete(url,);
                if (r.status === 200) {
                    return;
                }
                throw new Error(await format_error_response(r));
            }

        }

        class Me extends _ {
            constructor(client) {
                super(client, ["me", "api",]);
                this.caches = {
                    contacts_any: null,
                    contacts_users: null,
                    contacts_groups: null,

                    contacted_users: null,
                    contacted_groups: null,
                }
            }

            async logout() {
                let url = join_path(this.api_url(), "logout");
                let body = {}
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_contacts_any() {
                if (this.caches.contacts_any !== null) return this.caches.contacts_any;
                let url = join_path(this.api_url(), "contacts");
                let params = {type: "any",}
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    this.caches.contacts_any = d;
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_contacts_users() {
                if (this.caches.contacts_users !== null) return this.caches.contacts_users;
                let url = join_path(this.api_url(), "contacts");
                let params = {type: "users",}
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    this.caches.contacts_users = d;
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_contacts_groups() {
                if (this.caches.contacts_groups !== null) return this.caches.contacts_groups;
                let url = join_path(this.api_url(), "contacts");
                let params = {type: "groups",}
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    this.caches.contacts_groups = d;
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_contacted_users() {
                if (this.caches.contacted_users !== null) return this.caches.contacted_users;
                let url = join_path(this.api_url(), "contacted");
                let params = {type: "users",}
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    this.caches.contacted_users = d;
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async fetch_contacted_groups() {
                if (this.caches.contacted_groups !== null) return this.caches.contacted_groups;
                let url = join_path(this.api_url(), "contacted");
                let params = {type: "groups",}
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    this.caches.contacted_groups = d;
                    return d;
                }
                throw new Error(await format_error_response(r));
            }
        }

        class Mail extends _ {
            constructor(client) {
                super(client, ["mail", "api",]);
            }
        }

        class Drive extends _ {
            constructor(client) {
                super(client, ["drive", "api",]);

                Drive.share_type_strings[Drive.share_type.noset] = "éšçˆ¶çº§";
                Drive.share_type_strings[Drive.share_type.noshare] = "ä¸å…±äº«";
                Drive.share_type_strings[Drive.share_type.readonly] = "å¯ä¸‹è½½";
                Drive.share_type_strings[Drive.share_type.readwrite] = "å¯ä¸‹è½½å¯ä¿®æ”¹";
            }

            static item_type = "drive"; // è¢«æœåŠ¡ç«¯æ–‡æœ¬æ›¿æ¢
            static share_type = "drive";
            static share_type_strings = {};

            async fetch_list(site, did,) {
                let url = join_path(this.api_url(), "list");
                let params = {site, did,}
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async new_folder(name, parent_did = undefined) {
                let url = join_path(this.api_url(), "new",);
                let body = {
                    "type": Drive.item_type.folder,
                    "name": await encryptors.encrypt2base64(name),
                    "name_encrypted": true,
                    "parent_did": parent_did,
                };
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async new_file(name, file, parent_did = undefined) {
                let url = join_path(this.api_url(), "new",);
                let body = {
                    "type": Drive.item_type.file,
                    "name": await encryptors.encrypt2base64(name),
                    "name_encrypted": true,
                    "parent_did": parent_did,
                    "size": file.size,
                };
                let r = await net_fetcher.nf_post_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async upload(did, feedbackargs, callbacks) {
                let url = join_path(this.api_url(), "upload",);

                url.searchParams.set("did", did);

                const xhr = new XMLHttpRequest();
                xhr._url = url;
                xhr.open("PUT", url, true);
                xhr.setRequestHeader("Content-Type", feedbackargs.file.type || "application/octet-stream");
                xhr.upload.onprogress = callbacks.onprogress;
                xhr.onload = callbacks.onload;
                xhr.onerror = callbacks.onerror;
                xhr.onabort = callbacks.onabort;

                // if (ti.udti_attr.session) {
                //     console.log(`bytes ${ti.udti_attr.lstartindex}-${ti.udti_attr.file.size - 1}/${ti.udti_attr.file.size}`)
                //     xhr.setRequestHeader("Content-Range", `bytes ${ti.udti_attr.lstartindex}-${ti.udti_attr.file.size - 1}/${ti.udti_attr.file.size}`);
                // }

                // if (ti.udti_attr.session) {
                //     xhr.send(ti.udti_attr.file.slice(ti.udti_attr.lstartindex));
                // } else {
                // xhr.send(file);
                // }


                const uint8 = new Uint8Array(await readFileAsync(feedbackargs.file));
                if (xhr.canceled) return callbacks.onabort();
                const encrypted = await encryptors.encrypt(uint8);
                feedbackargs.total = encrypted.length;
                if (xhr.canceled) return callbacks.onabort();
                xhr.send(encrypted);

                return xhr;
            }

            async download(did, feedbackargs, callbacks) {
                let url = join_path(this.api_url(), "item", did, "down");

                let response;
                let controller = new AbortController();
                feedbackargs.controller = controller;
                try {
                    response = await fetch(url, {
                        method: "GET",
                        headers: {"Range": `bytes=${feedbackargs.curr}-`},
                        signal: controller.signal
                    });
                } catch (e) {
                    throw e;
                }

                if (!response.ok && response.status !== 206) {
                    throw new Error(await format_error_response(response));
                }

                let reader = response.body.getReader();
                let contentLength = Number(response.headers.get("Content-Length")) || 0;
                console.log(`é¢„è®¡ä¸‹è½½`, format_bytes(contentLength));
                if (feedbackargs.total === null) feedbackargs.total = contentLength;

                while (true) {
                    let done, value;
                    try {
                        const _ = await reader.read();
                        value = _.value;
                        done = _.done;
                    } catch (e) {
                        throw e;
                    }
                    if (done) break;
                    feedbackargs.chunks.push(value);
                    feedbackargs.curr += value.length;
                    callbacks.onprogress();
                }
                console.log(`å·²è¯»å®Œ`, format_bytes(feedbackargs.curr), format_bytes(contentLength), format_bytes(feedbackargs.total), feedbackargs.curr === feedbackargs.total, feedbackargs.curr === contentLength);
                let totalArray = new Uint8Array(feedbackargs.curr);
                let offset = 0;
                for (let chunk of feedbackargs.chunks) {
                    totalArray.set(chunk, offset);
                    offset += chunk.length;
                }

                totalArray = await encryptors.decrypt(totalArray, true);

                saveFile_from_uint8array(totalArray, feedbackargs.name.split("/").at(-1));

                feedbackargs.chunks.length = 0;
                feedbackargs.curr = 0;

                callbacks.onload();

            }

            async rename(did, name,) {
                let url = join_path(this.api_url(), "item", did,);
                let body = {
                    "action": "rename",
                    "name": await encryptors.encrypt2base64(name),
                    "name_encrypted": true,
                };
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async move(did, parent_did, site) {
                let url = join_path(this.api_url(), "item", did,);
                let body = {
                    "action": "move",
                    "parent_did": parent_did,
                    "site": site,
                };
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    // let d = await r.json();
                    // return d;
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async trash(did,) {
                let url = join_path(this.api_url(), "item", did,);
                let body = {
                    "action": "trash",
                };
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    // let d = await r.json();
                    // return d;
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async restore(did,) {
                let url = join_path(this.api_url(), "item", did,);
                let body = {
                    "action": "restore",
                };
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    // let d = await r.json();
                    // return d;
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async delete(did,) {
                let url = join_path(this.api_url(), "item", did,);
                let r = await net_fetcher.nf_delete(url,);
                if (r.status === 200) {
                    // let d = await r.json();
                    // return d;
                    return true;
                }
                throw new Error(await format_error_response(r));
            }

            async share_get(did) {
                let url = join_path(this.api_url(), "item", did, "share");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async share_set(did, form) {
                let url = join_path(this.api_url(), "item", did, "share");
                let body = {...form};
                let r = await net_fetcher.nf_put_json(url, body);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async resolve(did) {
                let url = join_path(this.api_url(), "item", did, "resolve");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

        }

        class Chat extends _ {
            constructor(client) {
                super(client, ["chat", "api",]);
            }

            static receiver_type = "chat"; // è¢«æœåŠ¡ç«¯æ–‡æœ¬æ›¿æ¢

            async fetch_contacts() {
                let url = join_path(this.api_url(), "contacts");
                let r = await net_fetcher.nf_get(url,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async sync(ws_send, gid_args, uid_args) {
                let url = join_path(this.api_url(), "sync");
                let body = {
                    gids: gid_args,
                    uids: uid_args,
                };

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.sync;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async sync_one(contact_type, xxid, ceid) {
                let url = join_path(this.api_url(), "sync_one");
                let body = {
                    contact_type, ceid,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }
                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async act(ws_send, contact_type, xxid, ceid, activity_type,) {
                let url = join_path(this.api_url(), "act");
                let body = {
                    contact_type, ceid,
                    activity_type,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.act;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async members(contact_type, xxid,) {
                let url = join_path(this.api_url(), "members");
                let params = {contact_type,};
                if (contact_type === subviews.Chat.receiver_type.group) {
                    params.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    params.uid = xxid;
                }
                let r = await net_fetcher.nf_get(url, params);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async send_text(ws_send, contact_type, xxid, ceid, sender_rand, plain_text, topic = '') {
                let url = join_path(this.api_url(), "send");
                let body = {
                    contact_type, ceid,

                    sender_rand,
                    type: dashboardwrappers.ChatDashboardWrapper.message_type.text,
                    data_text: await encryptors.encrypt2base64(plain_text),
                    topic: topic,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.send;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async edit_text(ws_send, contact_type, xxid, ceid, message_id, plain_text,) {
                let url = join_path(this.api_url(), "edit");
                let body = {
                    contact_type, ceid,

                    message_id,
                    data_text: await encryptors.encrypt2base64(plain_text),
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.edit;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async revoke_message(ws_send, contact_type, xxid, ceid, message_id,) {
                let url = join_path(this.api_url(), "revoke");
                let body = {
                    contact_type, ceid,

                    message_id,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.revoke;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async batch_revoke(ws_send, contact_type, xxid, ceid, message_ids,) {
                let url = join_path(this.api_url(), "batch_revoke");
                let body = {
                    contact_type, ceid,

                    message_ids,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.batch_revoke;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async mark_read(ws_send, contact_type, xxid, ceid, message_ids,) {
                let url = join_path(this.api_url(), "mark_read");
                let body = {
                    contact_type, ceid,

                    message_ids,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.mark_read;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async send_file(feedbackargs, callbacks) {
                let url = join_path(this.api_url(), "send_file",);

                const xhr = new XMLHttpRequest();
                xhr._url = url;
                xhr.open("POST", url, true);
                xhr.responseType = 'arraybuffer';
                // xhr.setRequestHeader("Content-Type", "multipart/form-data"); // ä¸éœ€è¦æ‰‹åŠ¨è®¾ç½®
                xhr.upload.onprogress = callbacks.onprogress;
                xhr.onload = callbacks.onload;
                xhr.onerror = callbacks.onerror;
                xhr.onabort = callbacks.onabort;

                const uint8 = new Uint8Array(await readFileAsync(feedbackargs.msg.file));
                if (xhr.canceled) return callbacks.onabort();
                const encrypted = await encryptors.encrypt(uint8);
                feedbackargs.total = encrypted.length;
                if (xhr.canceled) return callbacks.onabort();

                const metadata = {
                    contact_type: feedbackargs.contact_type,
                    ceid: feedbackargs.ceid,

                    sender_rand: feedbackargs.msg.sender_rand,
                    type: feedbackargs.msg.type,

                    file_attr: {
                        "name": await encryptors.encrypt2base64(feedbackargs.msg.file.name),
                        "name_encrypted": true,
                        "size": feedbackargs.msg.file.size,
                    },
                }
                if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_image(feedbackargs.msg.type)) {
                    metadata.image_attr = feedbackargs.msg.image_attr;
                }

                if (feedbackargs.contact_type === subviews.Chat.receiver_type.group) {
                    metadata.gid = feedbackargs.xxid;
                } else if (feedbackargs.contact_type === subviews.Chat.receiver_type.user) {
                    metadata.uid = feedbackargs.xxid;
                }

                const blob = new Blob([encrypted], {type: "application/octet-stream"});
                const formData = new FormData();
                formData.append('file', blob, "filename");
                formData.append('metadata', JSON.stringify(metadata));

                xhr.send(formData);

                return xhr;
            }

            async download(feedbackargs, callbacks) {
                let url = join_path(this.api_url(), "download", feedbackargs.msg.id,);
                // let params = {id: feedbackargs.msg.id,};
                // for (const key of Object.keys(params)) url.searchParams.set(key, params[key]);

                let response;
                let controller = new AbortController();
                feedbackargs.controller = controller;
                try {
                    response = await fetch(url, {
                        method: "GET",
                        headers: {"Range": `bytes=${feedbackargs.curr}-`},
                        signal: controller.signal
                    });
                } catch (e) {
                    throw e;
                }

                if (!response.ok && response.status !== 206) {
                    throw new Error(await format_error_response(response));
                }

                let reader = response.body.getReader();
                let contentLength = Number(response.headers.get("Content-Length")) || 0;
                console.log(`é¢„è®¡ä¸‹è½½`, format_bytes(contentLength));
                if (feedbackargs.total === null) feedbackargs.total = contentLength;

                while (true) {
                    let done, value;
                    try {
                        const _ = await reader.read();
                        value = _.value;
                        done = _.done;
                    } catch (e) {
                        throw e;
                    }
                    if (done) break;
                    feedbackargs.chunks.push(value);
                    feedbackargs.curr += value.length;
                    callbacks.onprogress();
                }
                console.log(`å·²è¯»å®Œ`, format_bytes(feedbackargs.curr), format_bytes(contentLength), format_bytes(feedbackargs.total), feedbackargs.curr === feedbackargs.total, feedbackargs.curr === contentLength);
                let totalArray = new Uint8Array(feedbackargs.curr);
                let offset = 0;
                for (let chunk of feedbackargs.chunks) {
                    totalArray.set(chunk, offset);
                    offset += chunk.length;
                }

                totalArray = await encryptors.decrypt(totalArray, true);

                feedbackargs.plain_file_data = totalArray;

                feedbackargs.chunks.length = 0;
                feedbackargs.curr = 0;

                callbacks.onload();

            }

            async load(ws_send, contact_type, xxid, ceid, last_msgattr) {
                let url = join_path(this.api_url(), "load");
                let body = {
                    contact_type, ceid,
                    last_message_id: last_msgattr ? last_msgattr.id : null,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.load;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async load_history(ws_send, contact_type, xxid, ceid, first_msgattr) {
                let url = join_path(this.api_url(), "load_history");
                let body = {
                    contact_type, ceid,
                    first_message_id: first_msgattr ? first_msgattr.id : null,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.load_history;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async read(ws_send, contact_type, xxid, ceid, visible_msgattr) {
                let url = join_path(this.api_url(), "read");
                let body = {
                    contact_type, ceid,
                    visible_message_id: visible_msgattr.id,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.read;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async sync_message(ws_send, contact_type, xxid, ceid, message_ids) {
                let url = join_path(this.api_url(), "sync_message");
                let body = {
                    contact_type, ceid,
                    message_ids,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.sync_message;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async clear(ws_send, contact_type, xxid, ceid, old_than_hours,) {
                let url = join_path(this.api_url(), "clear");
                let body = {
                    contact_type, ceid,

                    hours: old_than_hours,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.clear;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

            async forward(ws_send, contact_type, xxid, ceid, message_id, to,) {
                let url = join_path(this.api_url(), "forward");
                let body = {
                    contact_type, ceid,

                    message_id,
                    to,
                };
                if (contact_type === subviews.Chat.receiver_type.group) {
                    body.gid = xxid;
                } else if (contact_type === subviews.Chat.receiver_type.user) {
                    body.uid = xxid;
                }

                if (ws_send) {
                    body.action = dashboardwrappers.ChatDashboardWrapper.ws_action_type.forward;
                    return ws_send({url, body});
                }

                let r = await net_fetcher.nf_post_json(url, body,);
                if (r.status === 200) {
                    let d = await r.json();
                    return d;
                }
                throw new Error(await format_error_response(r));
            }

        }

        return {Api, Admin, Me, Mail, Drive, Chat};
    })()


    function checkIfElementVisible(container, child) {
        const el = child;
        const rect = el.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        // åˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨å®¹å™¨å¯è§†èŒƒå›´å†…
        if (rect.bottom > containerRect.top && rect.top < containerRect.bottom) {
            // if (rect.top >= containerRect.top && rect.bottom <= containerRect.bottom) { // å®Œå…¨å¯è§
            return true;
        }
        return false;
    }

    function findLastVisibleElement(container, children) {
        // ä»åå‘å‰éå†
        for (let i = children.length - 1; i >= 0; i--) {
            if (checkIfElementVisible(container, children[i])) return children[i];
        }
        return null; // å¦‚æœæ²¡æœ‰å¯è§å…ƒç´ 
    }

    /*
    * é¢æ¿å³ä¾§ å†…å®¹
    * */
    const contentpages = (() => {
        class _ {
            constructor(client, panel, li) {
                this.client = client;
                this.panel = panel;
                this.li = li; // mainaction
                this.aside_right = panel.querySelector(":scope .aside-right");
                this.closed = false;
            }

            close_page() {
                this.li.classList.remove("active")
                this.loading_mark.remove()
                this.container.remove()
                this.closed = true;
            }

            open_page() {
                this.li.classList.add("active")
                let html = `<div></div>`;
                this.aside_right.insertAdjacentHTML("beforeend", html);
                this.container = this.aside_right.querySelector(":scope div:last-of-type");

                this.loading_mark = new LoadingMark(this.aside_right);

            }

            remove_loading_mark() {
                this.loading_mark.remove();
                this.loading_mark = new LoadingMark(this.aside_right);
            }
        }

        class _drive extends _ {
            constructor(client, panel, li) {
                super(client, panel, li);
                this.drive_path_items = [];
                this.drive_items = [];
            }

            close_page() {
                super.close_page();
            }

            open_page() {
                super.open_page();

                let html = `
<div class="drive-rect">
<div class="drive-header"><button class="drive-header-btn-close">â®Œ</button><div class="drive-path"></div></div>
<div class="drive-actions">
    <label class="checkbox"><input type="checkbox"></label>
    <button class="drive-action-btn no-width">${full_width_space}</button>
    <button class="drive-action-btn" id="dab-upload">ä¸Šä¼ æ–‡ä»¶<input type="file" class="hidden"></button>
    <button class="drive-action-btn" id="dab-newfolder">æ–°å»ºæ–‡ä»¶å¤¹</button>
    <button class="drive-action-btn hidden-btn" id="dab-batch-trash">ç§»åˆ°åƒåœ¾æ¡¶</button>
    <button class="drive-action-btn hidden-btn" id="dab-batch-restore">ç§»å‡ºåƒåœ¾æ¡¶</button>
    <button class="drive-action-btn hidden-btn" id="dab-batch-delete">æ°¸ä¹…åˆ é™¤</button>
</div>
<div class="drive-items-wrap">
    <p class="hidden">æ­¤å¤„æ²¡æœ‰æ–‡ä»¶ã€‚</p>
    <div class="drive-items"></div>
</div>
</div>
`;
                this.container.insertAdjacentHTML("beforeend", html);
                this.drive_rect = this.container.querySelector(":scope div.drive-rect");
                this.drive_path = this.drive_rect.querySelector(":scope div.drive-path");
                this.drive_actions = this.drive_rect.querySelector(":scope div.drive-actions");
                this.element_drive_items_wrap = this.drive_rect.querySelector(":scope div.drive-items-wrap");
                this.element_drive_items_nothings_tip = this.drive_rect.querySelector(":scope div.drive-items-wrap > p");
                this.element_drive_items = this.drive_rect.querySelector(":scope div.drive-items");

                // è¿”å›é”®
                this.element_header_btn_close = this.drive_rect.querySelector(":scope button.drive-header-btn-close");
                this.element_header_btn_close.addEventListener("click", (event) => {
                    this.client.close_content_page();
                });

                // å¤šé€‰æ¡†
                this.selecting_checkbox = this.drive_actions.querySelector(":scope > label.checkbox:first-of-type");
                this.selecting_checkbox_input = this.selecting_checkbox.querySelector(":scope > input");
                const cb = this.selecting_checkbox_input;
                this.selecting_checkbox.state = 0; // 0 æœªé€‰ä¸­, 1 å·²é€‰ä¸­, 2 ä¸ç¡®å®š
                this.selecting_checkbox.addEventListener("click", (event) => {
                    this.selecting_checkbox.state = (this.selecting_checkbox.state + 1) % 2;
                    cb.checked = this.selecting_checkbox.state === 1;
                    cb.indeterminate = this.selecting_checkbox.state === 2;

                    if (cb.checked) {
                        for (const driveItem of this.drive_items) {
                            driveItem.raw_header.selecting_checkbox.state = 1;
                            driveItem.raw_header.selecting_checkbox_input.checked = true;
                            driveItem.raw_header.selecting_checkbox_input.indeterminate = false;
                        }
                    } else if (cb.indeterminate) {
                        for (const driveItem of this.drive_items) {
                            driveItem.raw_header.selecting_checkbox.state = 2;
                            driveItem.raw_header.selecting_checkbox_input.checked = false;
                            driveItem.raw_header.selecting_checkbox_input.indeterminate = true;
                        }
                    } else {
                        for (const driveItem of this.drive_items) {
                            driveItem.raw_header.selecting_checkbox.state = 0;
                            driveItem.raw_header.selecting_checkbox_input.checked = false;
                            driveItem.raw_header.selecting_checkbox_input.indeterminate = false;
                        }
                    }
                    this.switch_action_btns__batch();
                });
                cb.checked = false;
                cb.indeterminate = false;

                // æŒ‰é’® ä¸Šä¼ æ–‡ä»¶
                this.drive_action_btn_upload = this.drive_actions.querySelector(":scope button#dab-upload");
                this.drive_action_btn_upload__input = this.drive_action_btn_upload.querySelector(":scope > input");
                this.drive_action_btn_upload.addEventListener("click", (event) => {
                    this.drive_action_btn_upload__input.click();
                });
                this.drive_action_btn_upload__input.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        let name = normalizeName(file.name);
                        if (!name) return;
                        for (let disallowedUploadElement of disallowed_upload) {
                            if (name.endsWith(disallowedUploadElement)) {
                                MessageMark.report(`ä¸å…è®¸ä¸Šä¼ ï¼š${disallowedUploadElement}`);
                                return;
                            }
                        }
                        for (let itemElement of this.drive_items) {
                            if (name === this.get_item_display_name(itemElement)) {
                                MessageMark.report(`åç§°é‡å¤â€œ${name}â€ã€‚`);
                                return;
                            }
                        }
                        const task = this.add_upload_task(file);
                        floatball.look_upload_tasks(task);
                    }
                });

                // æŒ‰é’® æ–°æ–‡ä»¶å¤¹
                this.drive_action_btn_newfolder = this.drive_actions.querySelector(":scope button#dab-newfolder");
                this.drive_action_btn_newfolder.addEventListener("click", (event) => {
                    this.new_folder();
                });

                // æŒ‰é’® æ‰¹é‡æ“ä½œ
                this.drive_action_btn_batch_trash = this.drive_actions.querySelector(":scope button#dab-batch-trash");
                this.drive_action_btn_batch_trash.addEventListener("click", (event) => {
                    this.movetotrash_batch();
                });
                this.drive_action_btn_batch_restore = this.drive_actions.querySelector(":scope button#dab-batch-restore");
                this.drive_action_btn_batch_restore.addEventListener("click", (event) => {
                    this.restore_batch();
                });
                this.drive_action_btn_batch_delete = this.drive_actions.querySelector(":scope button#dab-batch-delete");
                this.drive_action_btn_batch_delete.addEventListener("click", (event) => {
                    this.delete_batch();
                });

                // æ‹–æ‹½ä¸Šä¼ 
                this.element_drive_items_wrap.addEventListener('dragenter', (event) => {
                    if (dragging_item) return;
                    if (this.current_path_item().attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    event.preventDefault();
                    this.element_drive_items_wrap.classList.add("drag-active");
                });
                this.element_drive_items_wrap.addEventListener('dragover', (event) => {
                    if (dragging_item) return;
                    if (this.current_path_item().attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'copy';
                    this.element_drive_items_wrap.classList.add("drag-active");
                });
                this.element_drive_items_wrap.addEventListener('dragleave', () => {
                    if (dragging_item) return;
                    if (this.current_path_item().attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    this.element_drive_items_wrap.classList.remove("drag-active");
                });
                this.element_drive_items_wrap.addEventListener('drop', async (event) => {
                    if (dragging_item) return;
                    if (this.current_path_item().attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    event.preventDefault();
                    this.element_drive_items_wrap.classList.remove("drag-active");
                    const dataTransferItems = event.dataTransfer.items;
                    const validFiles = [];
                    const validFolders = [];
                    for (let i = 0; i < dataTransferItems.length; i++) {
                        const item = dataTransferItems[i];
                        const entry = item.webkitGetAsEntry && item.webkitGetAsEntry();
                        // console.log(item, entry);
                        if (item.kind === 'file') {
                            if (entry && entry.isDirectory) {
                                // validFolders.push(entry);
                            } else {
                                const file = item.getAsFile();
                                // console.log(file,);
                                if (file) {
                                    validFiles.push(file);
                                }
                            }
                        }
                    }
                    if (validFolders.length > 0) {
                        for (const entry of validFolders) {
                            const files = await getAllFilesFromDroppedFolder(entry);
                            for (const file of files) {
                                // console.log(file.relativePath, file);
                                file.relativePath.pop()
                                validFiles.push(file);
                            }
                        }
                        // return;
                    }
                    let files = [];
                    if (validFiles.length > 0) {
                        for (const file of validFiles) {
                            let can = true;

                            let name = normalizeName(file.name);
                            if (!name) can = false;

                            if (!can) {
                                // continue;
                                return;
                            }

                            for (let disallowedUploadElement of disallowed_upload) {
                                if (name.endsWith(disallowedUploadElement)) {
                                    MessageMark.report(`ä¸å…è®¸ä¸Šä¼ ï¼š${disallowedUploadElement}`);
                                    can = false;
                                    break;
                                }
                            }

                            if (!can) {
                                // continue;
                                return;
                            }

                            // if (root_attr.max_upload_size > 0 && file.size >= root_attr.max_upload_size * 1024 * 1024) {
                            //     alert(`å•æ–‡ä»¶å¤§å°é™åˆ¶ä¸º${root_attr.max_upload_size}MBã€‚`);
                            //     can = false;
                            //     // continue;
                            //     return;
                            // }

                            if (file.relativePath && file.relativePath.length > 0) {
                            } else {
                                for (let itemElement of this.drive_items) {
                                    if (name === this.get_item_display_name(itemElement)) {
                                        MessageMark.report(`åç§°é‡å¤â€œ${name}â€ã€‚`);
                                        can = false;
                                        break;
                                    }
                                }
                            }

                            if (!can) {
                                // continue;
                                return;
                            }

                            files.push(file)
                        }
                    }
                    if (files.length > 0) {
                        MessageMark.confirm(`${files.length}ä¸ªæ–‡ä»¶ï¼Œå¼€å§‹ä¸Šä¼ ï¼Ÿ`, null, null, () => {
                            let first_task = null;
                            for (const file of files) {
                                // console.log(file, file.relativePath, file.formated_name)
                                const task = this.add_upload_task(file);
                                if (!first_task) first_task = task;
                            }
                            floatball.look_upload_tasks(first_task);
                        }, MessageMark.colors.blue)
                    }
                });


                this.add_top_level_path_item()

                this.refresh();
            }

            static path_item_type = {
                root: 0, folder: 1,
            }

            add_top_level_path_item() {
                const name = this.li.bindmap.text;
                const attr = {
                    type: _drive.path_item_type.root,
                };
                this.add_path_item(name, attr);
            }

            add_path_item(name, attr) {
                let html = `
<div class="drive-path-item">
<span class="drive-path-item-slash">/</span>
<button class="drive-path-item-btn">${name}</button>
</div>
`;
                this.drive_path.insertAdjacentHTML("beforeend", html);
                const path_item = this.drive_path.querySelector(":scope div.drive-path-item:last-of-type");
                path_item.attr = attr;

                const path_item_btn = path_item.querySelector(":scope .drive-path-item-btn");
                path_item_btn.addEventListener("click", (event) => {
                    this.remove_back_path_items(path_item);
                    // this.switch_action_btns__root(path_item);
                    // this.fetch_list(path_item);
                    this.refresh();
                });

                path_item_btn.addEventListener('drop', (event) => {
                    if (!dragging_item) return;
                    if (path_item === this.drive_path_items[this.drive_path_items.length - 1]) return;
                    if (path_item.attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    const station_element = event.target.closest(".drive-path-item-btn");
                    if (!station_element) return;
                    path_item_btn.classList.remove("active");
                    // const d = JSON.parse(event.dataTransfer.getData("application/json"));
                    if (path_item.attr.type === _drive.path_item_type.root) {
                        this.move(dragging_item, undefined, path_item);
                    } else {
                        this.move(dragging_item, path_item);
                    }
                });
                path_item_btn.addEventListener('dragover', (event) => {
                    if (!dragging_item) return;
                    if (path_item === this.drive_path_items[this.drive_path_items.length - 1]) return;
                    if (path_item.attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    const station_element = event.target.closest(".drive-path-item-btn");
                    if (!station_element) return;
                    event.preventDefault();
                    path_item_btn.classList.add("active");
                });
                path_item_btn.addEventListener('dragenter', (event) => {
                    if (!dragging_item) return;
                    if (path_item === this.drive_path_items[this.drive_path_items.length - 1]) return;
                    if (path_item.attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    const station_element = event.target.closest(".drive-path-item-btn");
                    if (!station_element) return;
                    event.preventDefault();
                    path_item_btn.classList.add("active");
                });
                path_item_btn.addEventListener('dragleave', (event) => {
                    if (!dragging_item) return;
                    if (path_item === this.drive_path_items[this.drive_path_items.length - 1]) return;
                    if (path_item.attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") return;
                    const station_element = event.target.closest(".drive-path-item-btn");
                    if (!station_element) return;
                    event.preventDefault();
                    path_item_btn.classList.remove("active");
                });

                this.drive_path_items.push(path_item);
            }

            fetch_list(path_item) {
                this.loading_mark.show();
                this.remove_all_items()

                this.element_drive_items_nothings_tip.classList.add("hidden");

                this.selecting_checkbox.state = 0;
                this.selecting_checkbox_input.checked = false;
                this.selecting_checkbox_input.indeterminate = false;

                this.client.subviews.drive.fetch_list(this.constructor.name, path_item.attr.type === _drive.path_item_type.root ? undefined : path_item.attr.did,)
                    .then(result => {
                        if (this.closed) return;
                        if (result.length === 0) this.element_drive_items_nothings_tip.classList.remove("hidden");
                        for (const resultElement of result) this.add_item(resultElement);
                        this.remove_loading_mark();
                    }).catch(error => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            add_item(attr) {
                const tree_headers = [];

                let can_click = attr.type === subviews.Drive.item_type.folder;
                if (this.constructor.name === contentpages.dashboard_drive.trashcan.name) can_click = false;

                const item = new TreeWidget(this.element_drive_items, tree_headers, null, 2, true, can_click)
                item.attr = attr;
                const html = `<div class="drive-item">
<label class="checkbox"><input type="checkbox"></label>
<i class="drive-item-icon"></i>
<div class="drive-item-info">
<!--    <a href="" target="_self" onclick="event.preventDefault();" draggable="false">-->
        <p class="drive-item-info-name"></p>
        <div class="drive-item-info-others"></div>
<!--    </a>-->
</div>
<div class="drive-item-actions">
    <button class="drive-item-action drive-item-action-more"><i class="drive-item-action-icon-more"></i></button>
</div>
</div>`;
                item.set_raw_header(html);
                item.show();

                // // aæ ‡ç­¾
                // item.e_atag = item.raw_header.querySelector(":scope div.drive-item-info > a");

                const e_icon = item.raw_header.querySelector(":scope i.drive-item-icon");
                if (attr.type === subviews.Drive.item_type.file) {
                    e_icon.classList.add("drive-item-icon-file")
                } else if (attr.type === subviews.Drive.item_type.folder) {
                    e_icon.classList.add("drive-item-icon-folder")
                }


                // æ‹–æ‹½
                if (this.current_path_item().attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") {
                } else {
                    item.summary.draggable = "true";
                }
                if (attr.type === subviews.Drive.item_type.folder) {
                    item.summary.addEventListener('drop', (event) => {
                        if (!dragging_item) return;
                        const station_element = event.target.closest("summary");
                        if (!station_element || item === dragging_item) return;
                        item.summary.classList.remove("active");
                        // const d = JSON.parse(event.dataTransfer.getData("application/json"));
                        this.move(dragging_item, item);
                    });
                    item.summary.addEventListener('dragover', (event) => {
                        if (!dragging_item) return;
                        const station_element = event.target.closest("summary");
                        if (!station_element || item === dragging_item) return;
                        event.preventDefault();
                        item.summary.classList.add("active");
                    });
                    item.summary.addEventListener('dragenter', (event) => {
                        if (!dragging_item) return;
                        const station_element = event.target.closest("summary");
                        if (!station_element || item === dragging_item) return;
                        event.preventDefault();
                        item.summary.classList.add("active");
                    });
                    item.summary.addEventListener('dragleave', (event) => {
                        if (!dragging_item) return;
                        if (event.target.nodeName === "#text") return;
                        const station_element = event.target.closest("summary");
                        if (!station_element || item === dragging_item) return;
                        event.preventDefault();
                        item.summary.classList.remove("active");
                    });
                }
                item.summary.addEventListener('dragstart', (event) => {
                    if (event.target.tagName !== "SUMMARY") {
                        return;
                    }
                    dragging_item = item;
                    // event.dataTransfer.setData("application/json", JSON.stringify());
                    event.dataTransfer.effectAllowed = 'move';
                });
                item.summary.addEventListener('dragend', (event) => {
                    dragging_item = null;
                    item.summary.classList.remove('hold')
                });


                // å±•ç¤ºæ•°æ®
                this.update_item(item);
                const e_info_others = item.raw_header.querySelector(":scope div.drive-item-info-others");
                {
                    const html = `<span>${format_timestamp_utc8(attr.uploaded_time)}</span>`;
                    e_info_others.insertAdjacentHTML("beforeend", html,);
                }
                if (attr.type === subviews.Drive.item_type.file) {
                    const html = `<span>ç”±${format_uploader(attr.uploader)}ä¸Šä¼ </span>`;
                    e_info_others.insertAdjacentHTML("beforeend", html,);
                } else if (attr.type === subviews.Drive.item_type.folder) {
                    const html = `<span>ç”±${format_uploader(attr.uploader)}åˆ›å»º</span>`;
                    e_info_others.insertAdjacentHTML("beforeend", html,);
                }
                if (attr.type === subviews.Drive.item_type.file) {
                    const html = `<span>${format_bytes(attr.size)}</span>`;
                    e_info_others.insertAdjacentHTML("beforeend", html,);
                }
                {
                    const html = `<span class="drive-item-info-others-share">${format_shared(attr)}</span>`;
                    e_info_others.insertAdjacentHTML("beforeend", html,);
                    item.e_info_others_share = e_info_others.querySelector(":scope > span:last-of-type");
                }

                // å¤é€‰æ¡†
                item.raw_header.selecting_checkbox = item.raw_header.querySelector(":scope > label.checkbox:first-of-type");
                item.raw_header.selecting_checkbox_input = item.raw_header.selecting_checkbox.querySelector(":scope > input");

                const cb = item.raw_header.selecting_checkbox_input;
                item.raw_header.selecting_checkbox.state = 0;
                item.raw_header.selecting_checkbox.addEventListener("click", (event) => {
                    item.raw_header.selecting_checkbox.state = (item.raw_header.selecting_checkbox.state + 1) % 2;
                    cb.checked = item.raw_header.selecting_checkbox.state === 1;
                    cb.indeterminate = item.raw_header.selecting_checkbox.state === 2;
                    this._update_selecting_checkbox_state();
                });
                cb.checked = false;
                cb.indeterminate = false;

                item.header_btns.push(item.raw_header.selecting_checkbox, item.raw_header.selecting_checkbox_input)


                // ç‚¹å‡»
                if (item.can_click) {
                    item.summary.addEventListener('click', (e) => {
                        if (item.header_btns.includes(e.target)) return;
                        this.into_folder(item);
                    });
                }


                // æŒ‰é’®
                item.raw_header.action_more = item.raw_header.querySelector(":scope button.drive-item-action-more");
                item.raw_header.action_more.addEventListener("click", (event) => {
                    const rect = event.target.getBoundingClientRect();
                    const items = [];
                    items.push(
                        {type: "button", text: "ä¸‹è½½", callback: event => this.download(event, item),},
                        {type: "section", text: "",},
                        {type: "button", text: "é‡å‘½å", callback: event => this.rename(event, item),},
                        {type: "button", text: "å…±äº«è®¾ç½®", callback: event => this.sharesettings(event, item),},
                        {type: "section", text: "",},
                        {type: "button", text: "ç§»åˆ°åƒåœ¾æ¡¶", callback: event => this.movetotrash(event, item),},
                        {type: "button", text: "æ°¸ä¹…åˆ é™¤", callback: event => this.delete(event, item),},
                    );
                    if (this.current_path_item().attr.type === _drive.path_item_type.root && this.constructor.name === "root") {
                        items[2].disabled = true;
                        items[3].disabled = true;
                        items[5].disabled = true;
                        items[6].disabled = true;
                    }
                    if (this.constructor.name === contentpages.dashboard_drive.trashcan.name) {
                        items[5].text = "ç§»å‡ºåƒåœ¾æ¡¶";
                        items[5].callback = event => this.restore(event, item);
                    }

                    if (item.attr.type === subviews.Drive.item_type.folder) {
                        items[0].text = "ä¸‹è½½æ–‡ä»¶å¤¹";
                    }

                    item.summary.classList.add("active");
                    MenuMark.exec({x: rect.left, y: rect.top + rect.height,}, items, () => {
                        item.summary.classList.remove("active");
                    });
                });
                item.header_btns.push(item.raw_header.action_more);


                this.drive_items.push(item);

                return item;

            }

            update_item(item,) {
                const e_info_name = item.raw_header.querySelector(":scope p.drive-item-info-name");
                if (item.attr.name_encrypted) {
                    e_info_name.textContent = decrypt_processing_string;
                    // this.update_item_atag(item);
                    encryptors.decrypt2string(item.attr.name).then(result => {
                        e_info_name.textContent = result;
                        item.attr.plain_name = result;
                        // this.update_item_atag(item);
                    }).catch(error => {
                        e_info_name.classList.add("red");
                        e_info_name.textContent = decrypt_error_string;
                        item.attr.plain_name = decrypt_error_string;
                        // this.update_item_atag(item);
                    });
                } else {
                    e_info_name.textContent = item.attr.name;
                }

                if (item.e_info_others_share) item.e_info_others_share.textContent = format_shared(item.attr);
            }

            update_item_atag(item,) {
                // å› ä¸‹è½½åè¿˜è¦è§£å¯†ï¼Œç”¨aæ ‡ç­¾ä¸è¡Œ
                if (item.attr.type === subviews.Drive.item_type.folder) return;
                const url = join_path(this.client.subviews.drive.api_url(), "item", item.attr.did, "down", encodeURIComponent(this.get_item_display_name(item)));
                item.e_atag.href = url.href;
            }

            get_item_display_name(item) {
                return item.attr.plain_name ? item.attr.plain_name : item.attr.name;
            }

            remove_all_items() {
                for (const driveItem of this.drive_items) {
                    driveItem.remove();
                }
                this.drive_items.length = 0;
                this._update_selecting_checkbox_state();
            }

            remove_item(item) {
                item.remove();
                this.drive_items.splice(this.drive_items.indexOf(item), 1);
                this._update_selecting_checkbox_state();
            }

            get_selected_items() {
                const items = [];
                for (const driveItem of this.drive_items) {
                    if (driveItem.raw_header.selecting_checkbox.state === 1) {
                        items.push(driveItem);
                    }
                }
                return items;
            }

            _update_selecting_checkbox_state() {
                let checked_count = this.get_selected_items().length;
                if (checked_count === 0) {
                    this.selecting_checkbox.state = 0;
                    this.selecting_checkbox_input.checked = false;
                    this.selecting_checkbox_input.indeterminate = false;
                } else if (checked_count === this.drive_items.length) {
                    this.selecting_checkbox.state = 1;
                    this.selecting_checkbox_input.checked = true;
                    this.selecting_checkbox_input.indeterminate = false;
                } else {
                    this.selecting_checkbox.state = 2;
                    this.selecting_checkbox_input.checked = false;
                    this.selecting_checkbox_input.indeterminate = true;
                }
                this.switch_action_btns__batch();
            }

            current_path_item() {
                return this.drive_path_items[this.drive_path_items.length - 1];
            }

            into_folder(item) {
                const name = this.get_item_display_name(item);
                const attr = {
                    type: _drive.path_item_type.folder,
                    did: item.attr.did,

                    name: item.attr.name,
                    plain_name: item.attr.plain_name,
                };
                this.add_path_item(name, attr);
                this.refresh();
            }

            remove_back_path_items(item) {
                for (let i = this.drive_path_items.length - 1; i > -1; i--) {
                    if (item !== this.drive_path_items[i]) {
                        this.drive_path_items[i].remove();
                        this.drive_path_items.splice(i, 1);
                    } else {
                        break;
                    }
                }
            }

            new_folder() {
                let form = [
                    {type: "title", label: "æ–°å»ºæ–‡ä»¶å¤¹ï¼š"},
                    {type: "linetext", label: "åç§°", value: "",},
                ];

                const confirm_callback = (fm,) => {
                    fm.collect_data();

                    try {
                        let name = normalizeName(form[1].value);
                        if (!form_field_checker.ffc_string(name)) throw new Error("åç§°æ— æ•ˆã€‚");

                        for (let itemElement of this.drive_items) {
                            if (name === this.get_item_display_name(itemElement)) {
                                MessageMark.report(`åç§°é‡å¤â€œ${name}â€ã€‚`);
                                return;
                            }
                        }

                        // fm.remove();
                        this._new_folder(fm, name);

                    } catch (e) {
                        MessageMark.report(e, fm.rect)
                    }

                }

                FormMark.get_global_input(form, confirm_callback)
            }

            _new_folder(fm, name) {
                const path_item = this.current_path_item();
                // this.loading_mark.show();
                fm.loading_mark = new LoadingMark(fm.rect);
                fm.loading_mark.show();
                this.client.subviews.drive.new_folder(name, path_item.attr.type === _drive.path_item_type.root ? undefined : path_item.attr.did)
                    .then(result => {
                        if (this.closed) return;
                        this.element_drive_items_nothings_tip.classList.add("hidden");
                        if (!this.loading_mark.is_visible()) {
                            const item = this.add_item(result);
                            item.summary.scrollIntoView({behavior: 'smooth', block: 'nearest'});
                        }
                        // this.remove_loading_mark();
                        fm.loading_mark.remove();
                        fm.remove();
                    }).catch(error => {
                    if (this.closed) return;
                    // this.remove_loading_mark();
                    fm.loading_mark.remove();
                    MessageMark.report(error, fm.rect);
                });
            }

            refresh() {
                if (this.loading_mark.is_visible()) return;
                const path_item = this.current_path_item();
                this.switch_action_btns__root(path_item);
                this.fetch_list(path_item);
            }

            switch_action_btns__root(path_item) {
                if (path_item.attr.type === _drive.path_item_type.root && this.constructor.name !== "myspace") {
                    for (const string of ["hidden",]) {
                        this.drive_action_btn_upload.classList.add(string);
                        this.drive_action_btn_newfolder.classList.add(string);
                    }
                } else {
                    for (const string of ["hidden",]) {
                        this.drive_action_btn_upload.classList.remove(string);
                        this.drive_action_btn_newfolder.classList.remove(string);
                    }
                }
            }

            switch_action_btns__batch() {
                const path_item = this.current_path_item();
                const selected_items = this.get_selected_items();
                if (selected_items.length > 0) {
                    this.drive_action_btn_upload.classList.add("hidden-btn");
                    this.drive_action_btn_newfolder.classList.add("hidden-btn");

                    if (this.constructor.name === contentpages.dashboard_drive.trashcan.name) {
                        this.drive_action_btn_batch_trash.classList.add("hidden-btn");
                        this.drive_action_btn_batch_restore.classList.remove("hidden-btn");
                    } else {
                        this.drive_action_btn_batch_trash.classList.remove("hidden-btn");
                        this.drive_action_btn_batch_restore.classList.add("hidden-btn");
                    }
                    this.drive_action_btn_batch_delete.classList.remove("hidden-btn");


                    if (path_item.attr.type === _drive.path_item_type.root && this.constructor.name === contentpages.dashboard_drive.root.name) {
                        this.drive_action_btn_batch_trash.classList.add("hidden-btn");
                        this.drive_action_btn_batch_restore.classList.add("hidden-btn");
                        this.drive_action_btn_batch_delete.classList.add("hidden-btn");
                    }

                } else {
                    this.drive_action_btn_upload.classList.remove("hidden-btn");
                    this.drive_action_btn_newfolder.classList.remove("hidden-btn");

                    this.drive_action_btn_batch_trash.classList.add("hidden-btn");
                    this.drive_action_btn_batch_restore.classList.add("hidden-btn");
                    this.drive_action_btn_batch_delete.classList.add("hidden-btn");
                }
            }

            add_upload_task(file) {
                const t = new FloatBall.tasktypes.Upload(floatball.dialog.tab_content_backtasks, {
                    onfinished: () => {
                        if (this.closed) return;
                        if (t.args.current_path_item === this.current_path_item()) this.refresh();
                    },
                });
                floatball.dialog.addTask(t);
                t.set_name(normalizeName(file.name));
                t.set_args({
                    file,
                    current_path_item: this.current_path_item(),
                });
                floatball.dialog.checkToStartTask();
                floatball.dialog.checkToHide(t);
                return t;
            }

            download(event, item) {
                if (item.attr.type === subviews.Drive.item_type.folder) {
                    this.download_folder(item);
                } else {
                    const t = new FloatBall.tasktypes.Download(floatball.dialog.tab_content_backtasks);
                    floatball.dialog.addTask(t);
                    t.set_name(normalizeName(this.get_item_display_name(item)));
                    t.set_args({
                        type: this.constructor, // æ²¡ç”¨ä¸Šï¼Œè®°ç€å¹²å˜›
                        did: item.attr.did,
                        name: normalizeName(this.get_item_display_name(item)),
                    });
                    floatball.dialog.checkToStartTask();
                    floatball.dialog.checkToHide(t);

                    floatball.look_download_tasks(t);

                }
            }

            download_folder(item) {
                this.loading_mark.show();
                this.client.subviews.drive.resolve(item.attr.did)
                    .then(result => {
                        if (this.closed) return;
                        this._download_folder(item, result.tree).then(result => {
                            this.remove_loading_mark();
                        }).catch((error) => {
                            if (this.closed) return;
                            this.remove_loading_mark()
                            MessageMark.report(error);
                        });
                    }).catch(error => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            async _download_folder(element_item, tree) {
                const items = [tree,];
                const func = (item, parent) => {
                    item.parent = parent;
                    items.push(item);
                    if (item.type === subviews.Drive.item_type.folder) item.children.map(i => func(i, item));
                };
                if (tree.type === subviews.Drive.item_type.folder) tree.children.map(i => func(i, tree));

                const tasks = [];
                items.forEach(item => {
                    if (item.name_encrypted) {
                        const p = new Promise((resolve, reject) => {
                            encryptors.decrypt2string(item.name).then(result => {
                                item.name = result;
                                resolve(null);
                            }).catch(error => {
                                item.name = decrypt_error_string;
                                resolve(null);
                            });
                        });
                        tasks.push(p);
                    }
                });
                await Promise.allSettled(tasks);

                const file_items = items.filter(item => item.type === subviews.Drive.item_type.file);
                const size = file_items.reduce((total, i) => total + i.size, 0);

                MessageMark.confirm(`åŒ…å«${file_items.length}ä¸ªæ–‡ä»¶ï¼Œ${format_bytes(size)}ï¼Œå¼€å§‹ä¸‹è½½ï¼Ÿ`, null, null, () => {
                    let t;
                    file_items.forEach(item => {
                        t = new FloatBall.tasktypes.Download(floatball.dialog.tab_content_backtasks);
                        floatball.dialog.addTask(t);

                        const path = [];
                        const func = (item) => {
                            path.push(normalizeName(item.name));
                            if (item.parent) func(item.parent);
                        };
                        func(item);
                        path.reverse();

                        t.set_name(path.join("/"));
                        t.set_args({
                            type: this.constructor, // æ²¡ç”¨ä¸Šï¼Œè®°ç€å¹²å˜›
                            did: item.did,
                            name: normalizeName(item.name),
                        });
                        floatball.dialog.checkToStartTask();
                        floatball.dialog.checkToHide(t);
                    });
                    if (t) floatball.look_download_tasks(t);

                },)
            }

            rename(event, item) {
                const origin_name = this.get_item_display_name(item);
                let form = [
                    {type: "title", label: "é‡å‘½åï¼š"},
                    {type: "linetext", label: "åç§°", value: origin_name,},
                ];

                const confirm_callback = (fm,) => {
                    fm.collect_data();

                    try {
                        let name = normalizeName(form[1].value);
                        if (!form_field_checker.ffc_string(name)) throw new Error("åç§°æ— æ•ˆã€‚");

                        if (name === origin_name) {
                            fm.remove();
                            return;
                        }

                        // fm.remove();
                        this._rename(event, item, fm, name);

                    } catch (e) {
                        MessageMark.report(e, fm.rect)
                    }

                }

                FormMark.get_global_input(form, confirm_callback)
            }

            _rename(event, item, fm, name) {
                fm.loading_mark = new LoadingMark(fm.rect);
                fm.loading_mark.show();
                this.client.subviews.drive.rename(item.attr.did, name,)
                    .then(result => {
                        if (this.closed) return;
                        item.attr.name = result.name;
                        this.update_item(item);
                        fm.loading_mark.remove();
                        fm.remove();
                    }).catch(error => {
                    if (this.closed) return;
                    fm.loading_mark.remove();
                    MessageMark.report(error, fm.rect);
                });
            }

            move(dragging_item, item, root_path_item) {
                let name1 = this.get_item_display_name(dragging_item);
                let name2;
                if (root_path_item) {
                    for (const mainaction of this.panel.mainactions[0].lis) {
                        if (mainaction.pagetype.name === this.constructor.name) {
                            name2 = mainaction.text;
                            break;
                        }
                    }
                } else {
                    name2 = this.get_item_display_name(item);
                }

                MessageMark.confirm(`ç§»åŠ¨â€œ${name1}â€åˆ°â€œ${name2}â€ï¼Ÿ`, null, null, () => {
                    this._move(dragging_item, item, root_path_item);
                },)
            }

            _move(dragging_item, item, root_path_item) {
                this.loading_mark.show();
                this.client.subviews.drive.move(dragging_item.attr.did,
                    root_path_item ? undefined : item.attr.did,
                    root_path_item ? this.constructor.name : undefined)
                    .then(result => {
                        if (this.closed) return;
                        this.remove_item(dragging_item);
                        this.remove_loading_mark();
                    }).catch(error => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            sharesettings(event, item) {
                this.loading_mark.show();
                this.client.subviews.drive.share_get(item.attr.did)
                    .then(result => {
                        if (this.closed) return;
                        this._sharesettings(event, item, result);
                        this.remove_loading_mark();
                    }).catch(error => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            _sharesettings(event, item, result1) {

                const share__group_user = (args, event, fm, row) => {
                    const callback2 = (result) => {
                        let form2 = [
                            {type: "title", label: args.label},
                            {
                                type: "custom", label: "",
                                add_element: (fm, row_custom) => {
                                    row_custom.subs = [];
                                    for (const resultElement of result) {
                                        let html = `<div class="fmic-item fmic-item-sharesettings"><label><input type="checkbox">${resultElement[args.xxid]}</label><select></select></div>`;
                                        row_custom.input_element.insertAdjacentHTML("beforeend", html);
                                        const column = row_custom.input_element.querySelector(":scope > .fmic-item:last-of-type");
                                        column.options = {
                                            [subviews.Drive.share_type.readonly]: subviews.Drive.share_type_strings[subviews.Drive.share_type.readonly],
                                            [subviews.Drive.share_type.readwrite]: subviews.Drive.share_type_strings[subviews.Drive.share_type.readwrite],
                                        };
                                        const checkbox = column.querySelector(":scope input");
                                        const select = column.querySelector(":scope select");

                                        row_custom.subs.push({
                                            attr: resultElement,
                                            column,
                                            checkbox,
                                            select,
                                        })

                                        checkbox.addEventListener("change", (event) => {
                                            select.disabled = !checkbox.checked;
                                        });

                                        for (const optionsKey in column.options) {
                                            let html = `<option value="${optionsKey}">${column.options[optionsKey]}</option>`;
                                            select.insertAdjacentHTML("beforeend", html);
                                            const option = select.querySelector(":scope > option:last-of-type");
                                        }
                                        const current_selecting = form_field_checker.ffc_array(row.value, true) ? row.value : row.origin;
                                        let attr;
                                        for (const i of current_selecting) {
                                            if (i[args.xxid] === resultElement[args.xxid]) {
                                                attr = i;
                                                break;
                                            }
                                        }
                                        if (attr) {
                                            select.value = attr.share_type;
                                            checkbox.checked = true;
                                            select.disabled = false;
                                        } else {
                                            checkbox.checked = false;
                                            select.disabled = true;
                                        }
                                    }
                                },
                                collect_data: (fm, row_custom) => {
                                    const map = [];
                                    for (const sub of row_custom.subs) {
                                        if (!sub.checkbox.checked) continue;
                                        let share_type = sub.select.value;
                                        if (!form_field_checker.ffc_string_int(share_type)) throw new Error("å…±äº«ç±»å‹");
                                        share_type = parseInt(share_type, 10);
                                        if (!form_field_checker.ffc_known(share_type, sub.column.options)) throw new Error("å…±äº«ç±»å‹");
                                        map.push({[args.xxid]: sub.attr[args.xxid], share_type});
                                    }
                                    row_custom.value = map;
                                },
                            },
                        ];

                        const confirm_callback = (fm,) => {
                            fm.collect_data();

                            try {
                                // let x = normalizeName(form[1].value);
                                // if (!form_field_checker.ffc_string(x)) throw new Error("");
                                row.value = form2[1].value;
                                fm.remove();
                                args.confirm_callback();
                            } catch (e) {
                                MessageMark.report(e, fm.rect)
                            }

                        }
                        FormMark.get_global_input(form2, confirm_callback, fm.mark)
                    }

                    fm.loading_mark = new LoadingMark(fm.rect);
                    fm.loading_mark.show();
                    this.client.subviews.me[args.func1]()
                        .then(result => {
                            if (this.closed) return;
                            callback2(result);
                            fm.loading_mark.remove();
                        }).catch(error => {
                        if (this.closed) return;
                        fm.loading_mark.remove();
                        MessageMark.report(error, fm.rect);
                    });

                }

                let form = [
                    {type: "title", label: "å…±äº«è®¾ç½®ï¼š"},
                    {
                        type: "groupbox", label: "å…±äº«ç»™ï¼š", form: [
                            {
                                type: "combobox",
                                label: "æ‰€æœ‰ç”¨æˆ·",
                                options: subviews.Drive.share_type_strings,
                                value: result1.any.toString(),
                            },
                            {
                                type: "multiselectbutton",
                                label: "ç‰¹å®šç»„",
                                label_button: "ç®¡ç†",
                                display: `${result1.groups.length}ä¸ªï¼›${result1.groups.map(i => i.gid).join("ã€")}`,
                                origin: result1.groups,
                                callback: (event, fm, row) => {
                                    share__group_user({
                                        label: "å…±äº«ç»™ç‰¹å®šç»„ï¼š",
                                        xxid: "gid",
                                        func1: "fetch_contacts_groups",
                                        confirm_callback: () => {
                                            if (form_field_checker.ffc_array(row.value, true)) row.display_element.textContent = `${row.value.length}ä¸ªï¼›${row.value.map(i => i.gid).join("ã€")}`;
                                        },
                                    }, event, fm, row);
                                },
                            },
                            {
                                type: "multiselectbutton",
                                label: "ç‰¹å®šç”¨æˆ·",
                                label_button: "ç®¡ç†",
                                display: `${result1.users.length}äººï¼›${result1.users.map(i => i.uid).join("ã€")}`,
                                origin: result1.users,
                                callback: (event, fm, row) => {
                                    share__group_user({
                                        label: "å…±äº«ç»™ç‰¹å®šç”¨æˆ·ï¼š",
                                        xxid: "uid",
                                        func1: "fetch_contacts_users",
                                        confirm_callback: () => {
                                            if (form_field_checker.ffc_array(row.value, true)) row.display_element.textContent = `${row.value.length}äººï¼›${row.value.map(i => i.uid).join("ã€")}`;
                                        },
                                    }, event, fm, row);
                                },
                            },
                        ]
                    },
                    {
                        type: "groupbox", label: "å…¬å…±é“¾æ¥ï¼ˆå¯¹äºéæ³¨å†Œç”¨æˆ·ï¼‰ï¼š", form: [
                            {
                                type: "combobox",
                                label: "æ‰€æœ‰è®¿å®¢",
                                options: subviews.Drive.share_type_strings,
                                value: result1.public.toString(),
                            },
                            {
                                type: "date",
                                label: "é“¾æ¥æœ‰æ•ˆæœŸè‡³",
                                value: result1.public_expiration,
                            },
                            {
                                type: "linetext",
                                label: "è®¿é—®å¯†ç ",
                                value: result1.public_pass,
                                placeholder: "æ— ",
                            },
                            {
                                type: "button",
                                label: "",
                                label_button: "å¤åˆ¶é“¾æ¥",
                                callback: (event, fm, row) => {
                                    const url = join_path(root_url(), "drive", "shared", item.attr.type === subviews.Drive.item_type.folder ? "folder" : "file", item.attr.did);
                                    navigator.clipboard.writeText(url.href);
                                },
                            },
                        ]
                    },
                ];

                const confirm_callback = (fm,) => {
                    fm.collect_data();

                    try {
                        let share_any_type = form[1].form[0].value;
                        if (!form_field_checker.ffc_string_int(share_any_type)) throw new Error("æ‰€æœ‰ç”¨æˆ·");
                        share_any_type = parseInt(share_any_type, 10);
                        if (!form_field_checker.ffc_known(share_any_type, subviews.Drive.share_type_strings)) throw new Error("æ‰€æœ‰ç”¨æˆ·");

                        let share_groups = form[1].form[1].value;
                        if (share_groups === undefined) share_groups = form[1].form[1].origin;
                        let share_users = form[1].form[2].value;
                        if (share_users === undefined) share_users = form[1].form[2].origin;

                        let share_public_type = form[2].form[0].value;
                        if (!form_field_checker.ffc_string_int(share_public_type)) throw new Error("æ‰€æœ‰è®¿å®¢");
                        share_public_type = parseInt(share_public_type, 10);
                        if (!form_field_checker.ffc_known(share_public_type, subviews.Drive.share_type_strings)) throw new Error("æ‰€æœ‰è®¿å®¢");

                        let public_expiration = form[2].form[1].value;
                        if (!form_field_checker.ffc_int(public_expiration)) throw new Error("é“¾æ¥æœ‰æ•ˆæœŸè‡³");

                        let public_pass = normalizePassword(form[2].form[2].value);
                        if (!form_field_checker.ffc_string(public_pass, true)) throw new Error("è®¿é—®å¯†ç ");


                        const put_form = {
                            any: share_any_type,
                            groups: share_groups,
                            users: share_users,
                            public: share_public_type,
                            public_expiration: public_expiration,
                            public_pass: public_pass,
                        }

                        this.__sharesettings(event, item, fm, put_form);

                    } catch (e) {
                        MessageMark.report(e, fm.rect)
                    }

                }

                FormMark.get_global_input(form, confirm_callback)
            }

            __sharesettings(event, item, fm, form) {
                fm.loading_mark = new LoadingMark(fm.rect);
                fm.loading_mark.show();
                this.client.subviews.drive.share_set(item.attr.did, form)
                    .then(result => {
                        if (this.closed) return;
                        item.attr.shared = result.shared;
                        this.update_item(item);
                        fm.loading_mark.remove();
                        fm.remove();
                    }).catch(error => {
                    if (this.closed) return;
                    fm.loading_mark.remove();
                    MessageMark.report(error, fm.rect);
                });
            }

            movetotrash(event, item) {
                let name = this.get_item_display_name(item);
                MessageMark.confirm(`ç§»åˆ°åƒåœ¾æ¡¶â€œ${name}â€ï¼Ÿ`, null, null, () => {
                    this._movetotrash(event, item);
                },)
            }

            _movetotrash(event, item) {
                this.loading_mark.show();
                this.client.subviews.drive.trash(item.attr.did)
                    .then(result => {
                        if (this.closed) return;
                        this.remove_item(item);
                        this.remove_loading_mark();
                    }).catch(error => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            movetotrash_batch() {
                const selected_items = this.get_selected_items();
                if (selected_items.length === 0) return;
                MessageMark.confirm(`ç§»åˆ°åƒåœ¾æ¡¶â€œ${selected_items.length}â€é¡¹ï¼Ÿ`, null, null, () => {
                    this._movetotrash_batch(selected_items);
                },)
            }

            _movetotrash_batch(items) {
                this.loading_mark.show();

                const promises = [];
                for (const item of items) promises.push(this.client.subviews.drive.trash(item.attr.did))
                const p = Promise.all(promises)
                p.then((result) => {
                    if (this.closed) return;
                    for (const item of items) this.remove_item(item);
                    this.remove_loading_mark();
                }).catch((error) => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            restore(event, item) {
                let name = this.get_item_display_name(item);
                MessageMark.confirm(`ç§»å‡ºåƒåœ¾æ¡¶â€œ${name}â€ï¼Ÿ`, null, null, () => {
                    this._restore(event, item);
                },)
            }

            _restore(event, item) {
                this.loading_mark.show();
                this.client.subviews.drive.restore(item.attr.did)
                    .then(result => {
                        if (this.closed) return;
                        this.remove_item(item);
                        this.remove_loading_mark();
                    }).catch(error => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            restore_batch() {
                const selected_items = this.get_selected_items();
                if (selected_items.length === 0) return;
                MessageMark.confirm(`ç§»å‡ºåƒåœ¾æ¡¶â€œ${selected_items.length}â€é¡¹ï¼Ÿ`, null, null, () => {
                    this._restore_batch(selected_items);
                },)
            }

            _restore_batch(items) {
                this.loading_mark.show();

                const promises = [];
                for (const item of items) promises.push(this.client.subviews.drive.restore(item.attr.did))
                const p = Promise.all(promises)
                p.then((result) => {
                    if (this.closed) return;
                    for (const item of items) this.remove_item(item);
                    this.remove_loading_mark();
                }).catch((error) => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            delete(event, item) {
                let name = this.get_item_display_name(item);
                MessageMark.confirm(`æ°¸ä¹…åˆ é™¤â€œ${name}â€ï¼Ÿ`, null, null, () => {
                    this._delete(event, item);
                },)
            }

            _delete(event, item) {
                this.loading_mark.show();
                this.client.subviews.drive.delete(item.attr.did)
                    .then(result => {
                        if (this.closed) return;
                        this.remove_item(item);
                        this.remove_loading_mark();
                    }).catch(error => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }

            delete_batch() {
                const selected_items = this.get_selected_items();
                if (selected_items.length === 0) return;
                MessageMark.confirm(`æ°¸ä¹…åˆ é™¤â€œ${selected_items.length}â€é¡¹ï¼Ÿ`, null, null, () => {
                    this._delete_batch(selected_items);
                },)
            }

            _delete_batch(items) {
                this.loading_mark.show();

                const promises = [];
                for (const item of items) promises.push(this.client.subviews.drive.delete(item.attr.did))
                const p = Promise.all(promises)
                p.then((result) => {
                    if (this.closed) return;
                    for (const item of items) this.remove_item(item);
                    this.remove_loading_mark();
                }).catch((error) => {
                    if (this.closed) return;
                    this.remove_loading_mark()
                    MessageMark.report(error);
                });
            }
        }

        class _chat extends _ {
            constructor(client, panel, li) {
                super(client, panel, li);
                this.previous_activity_attr = {
                    type: dashboardwrappers.ChatDashboardWrapper.activity_type.none,
                    sent_time: 0,
                    is_sending: false,
                }

                this.timer__fetch_unread_msgs = null;
                this.interval__fetch_unread_msgs = 7500;
                this.interval__fetch_unread_msgs__ws = 4500;
                this.is_processing__fetch_unread_msgs = false;

                this.timer__update_read_progress = null;
                this.interval__update_read_progress = 2000;

                this.is_processing__load_history = false;
            }

            close_page() {
                this.save_draft_text();
                if (this.li.bindmap.draft_text.length > 0) {
                    this.update_activity(dashboardwrappers.ChatDashboardWrapper.activity_type.none);
                }
                super.close_page();

                this.stop_timer__fetch_unread_msgs();
                this.stop_timer__update_read_progress();
                if (this.e_msgflow_mark_currentday__timer) {
                    clearTimeout(this.e_msgflow_mark_currentday__timer);
                    this.e_msgflow_mark_currentday__timer = null;
                }
                if (this.e_msgflow__scroll_timer) {
                    clearTimeout(this.e_msgflow__scroll_timer);
                    this.e_msgflow__scroll_timer = null;
                }
                if (this.e_msgflow__load_history_timer) {
                    clearTimeout(this.e_msgflow__load_history_timer);
                    this.e_msgflow__load_history_timer = null;
                }
                if (this.e_msgflow__checknew_timer) {
                    clearTimeout(this.e_msgflow__checknew_timer);
                    this.e_msgflow__checknew_timer = null;
                }
            }

            open_page() {
                super.open_page();
                let html = `
<div class="chat-session-rect">

<div class="chat-session-header">
    <button class="chat-session-header-btn-close">â®Œ</button>
    <div class="chat-session-header-info">
        <span class="chat-session-header-info-name">${this.li.bindmap.text}</span>
        <span class="chat-session-header-info-status">æ­£åœ¨åŠ è½½...</span>
        <div class="chat-session-header-info-clickmark"></div>
    </div>
    <div class="chat-session-header-actions">
        <button class="chat-session-header-action-more">â‹¯</button>
    </div>
</div>

<!-- ğŸ”¥ è¯é¢˜ç­›é€‰æ  -->
<div class="chat-topic-filter-bar hidden">
    <span class="chat-topic-filter-label">è¯é¢˜ç­›é€‰:</span>
    <select class="chat-topic-filter-select">
        <option value="">å…¨éƒ¨æ¶ˆæ¯</option>
    </select>
    <button class="chat-topic-filter-clear" title="æ¸…é™¤ç­›é€‰">âœ•</button>
</div>

<div class="chat-batch-action-bar">
    <div class="chat-batch-action-bar-left">
        <label>
            <input type="checkbox" class="chat-batch-select-all">
            å…¨é€‰
        </label>
        <button class="btn-select-inverse">åé€‰</button>
    </div>
    <div class="chat-batch-action-bar-right">
        <span class="chat-batch-count">å·²é€‰0æ¡</span>
        <button class="btn-delete-selected">åˆ é™¤é€‰ä¸­</button>
        <button class="btn-cancel-select">å–æ¶ˆ</button>
    </div>
</div>

<div class="chat-session-msgflow-wrap">
    <div class="chat-session-msgflow"></div>
    <div class="chat-session-msgflow-mark-currentday"><div class="chat-session-msgflow-mark-currentday-layout"><p></p></div></div>
    <div class="chat-session-msgflow-mark-loadhistory"><div class="chat-session-msgflow-mark-loadhistory-layout"><p>æ­£åœ¨æ£€æŸ¥æ˜¯å¦æœ‰æ›´å¤šå†å²æ¶ˆæ¯...</p></div></div>
    <div class="chat-session-msgflow-mark-checknew"><div class="chat-session-msgflow-mark-checknew-layout"><p>æ­£åœ¨æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ¶ˆæ¯...</p></div></div>
    <div class="chat-session-msgflow-mark-onlineusers"></div>
    <div class="chat-session-msgflow-mark-droparea hidden">
        <div class="chat-session-msgflow-mark-droparea-image">ä¸Šä¼ å›¾ç‰‡</div>
        <div class="chat-session-msgflow-mark-droparea-file">ä¸Šä¼ æ–‡ä»¶</div>
    </div>
    <button class="chat-session-msgflow-btn-scroll2end hidden" title="æ»šåŠ¨åˆ°åº•éƒ¨">âˆ¨</button>
</div>

<div class="chat-session-inputarea">
    <div class="chat-session-inputarea-othertypes">
        <button class="chat-session-inputarea-othertypes-image">
            <input type="file" class="hidden" accept="image/*">å›¾ç‰‡
        </button>
        <button class="chat-session-inputarea-othertypes-file">
            <input type="file" class="hidden">æ–‡ä»¶
        </button>
        <!-- ğŸ”¥ æ–°å¢ï¼šå€™é€‰è¯æŒ‰é’® -->
		<button class="chat-session-inputarea-othertypes-candidates">
		    å€™é€‰è¯
		</button>
        <button class="chat-session-inputarea-othertypes-write">
            âœï¸å†™å­—
        </button>
        <button
            class="chat-session-inputarea-othertypes-ai"
            title="è®© AI ç”¨é€šä¿—çš„æ–¹å¼ä¸€æ­¥ä¸€æ­¥æ•™ä½ è§£å†³é—®é¢˜ï¼Œå¿«æ·é”®ctrl+shift+å›è½¦">
            ğŸ¤– AIå’¨è¯¢
        </button>

    </div>

    <!-- ğŸ”¥ è¯é¢˜é€‰æ‹©å™¨ -->
    <div class="chat-topic-selector hidden">
        <label>ğŸ“ è¯é¢˜:</label>
        <select class="chat-topic-select">
            <option value="">é—²èŠ</option>
        </select>
        <input type="text" class="chat-topic-new-input hidden" placeholder="æ–°è¯é¢˜...">
        <button class="chat-topic-new-btn hidden">åˆ›å»º</button>
        <button class="chat-topic-add-btn" title="åˆ›å»ºæ–°è¯é¢˜">+ æ–°è¯é¢˜</button>
    </div>

    <!-- ç¼–è¾‘æ¶ˆæ¯æç¤º -->
    <div class="chat-session-inputarea-tip-editing hidden">
        <span>ç¼–è¾‘æ¶ˆæ¯ï¼š</span>
        <button>å–æ¶ˆ</button>
    </div>

    <div class="chat-session-inputarea-candidates hidden"></div>

    <!-- flex å®¹å™¨ï¼šè¾“å…¥æ¡† + å‘é€æŒ‰é’® -->
    <div class="chat-session-inputarea-textarea-row">
        <textarea class="chat-session-inputarea-textarea" placeholder="è¯·åœ¨æ¡†é‡Œè¾“å…¥æ¶ˆæ¯ï¼Œå¹¶æŒ‰å›è½¦æˆ–ç‚¹å‡»å‘é€ï¼ˆæŒ‰ctrl+ç©ºæ ¼é”®åˆ‡æ¢ä¸­æ–‡è¾“å…¥æ³•ï¼Œè¾“å…¥ä¸­æ–‡ï¼‰..." spellcheck="false"></textarea>
        <button class="chat-session-inputarea-sendbtn">>>>ç‚¹å‡»å‘é€<<<</button>
    </div>
</div>

<!-- ğŸ”¥ åŠå±å€™é€‰è¯é¢æ¿ -->
<div class="chat-candidate-panel hidden">
    <div class="chat-candidate-panel-header">
		<button class="chat-candidate-panel-prev">â† ä¸Šä¸€é¡µ</button>
		<!-- ğŸ”¥ ä¸­é—´æ·»åŠ ç­›é€‰è¾“å…¥æ¡† -->
    	<input type="text" class="chat-candidate-panel-filter" placeholder="ç­›é€‰å€™é€‰è¯â€¦">
		<button class="chat-candidate-panel-next">ä¸‹ä¸€é¡µ â†’</button>
		<button class="chat-candidate-panel-close">âœ•</button>
	</div>
    <div class="chat-candidate-panel-body"></div>
</div>

<!-- âœï¸ å†™å­—ç™½æ¿ -->
<div class="chat-writeboard hidden">
    <div class="chat-writeboard-mask"></div>
    <div class="chat-writeboard-panel">
        <div class="chat-writeboard-header">
            <span class="chat-writeboard-title">âœï¸ å†™å­—ç™½æ¿</span>
            <button class="chat-writeboard-close">âœ•</button>
        </div>

        <canvas class="chat-writeboard-canvas"></canvas>

        <div class="chat-writeboard-actions">
            <label class="brush-size">
                âœï¸ ç²—ç»†
                <input type="range"
                       class="chat-writeboard-size"
                       min="1"
                       max="40"
                       value="4">
            </label>
            <button class="chat-writeboard-clear">ğŸ—‘ æ¸…ç©º</button>
            <button class="chat-writeboard-eraser">ğŸ§½ æ©¡çš®æ“¦</button>
            <button class="chat-writeboard-confirm">âœ” ç¡®å®š</button>
        </div>
    </div>
</div>
<!-- AIå’¨è¯¢å¼¹çª— -->
<div id="ai-alert-modal" class="ai-alert-modal hidden">
    <div class="ai-alert-content">
        <p id="ai-alert-text"></p>
        <button id="ai-alert-ok">çŸ¥é“äº†</button>
    </div>
</div>


</div>
`;

                this.container.insertAdjacentHTML("beforeend", html);
                this.chat_rect = this.container.querySelector(":scope div.chat-session-rect");
                this.e_header_info = this.container.querySelector(":scope div.chat-session-header-info");
                this.e_header_info_clickmark = this.container.querySelector(":scope div.chat-session-header-info-clickmark");
                this.e_header_info_name = this.container.querySelector(":scope span.chat-session-header-info-name");
                this.e_header_info_status = this.container.querySelector(":scope span.chat-session-header-info-status");

                this.e_header_actions = this.container.querySelector(":scope div.chat-session-header-actions");

                this.e_batch_action_bar = this.container.querySelector(":scope div.chat-batch-action-bar");
                this.e_batch_select_all = this.container.querySelector(":scope input.chat-batch-select-all");
                this.e_batch_count = this.container.querySelector(":scope span.chat-batch-count");
                this.e_batch_btn_select_inverse = this.container.querySelector(":scope button.btn-select-inverse");
                this.e_batch_btn_delete = this.container.querySelector(":scope button.btn-delete-selected");
                this.e_batch_btn_cancel = this.container.querySelector(":scope button.btn-cancel-select");

                this.init_batch_action_bar();

                // ğŸ”¥ è¯é¢˜ç­›é€‰æ 
                this.e_topic_filter_bar = this.container.querySelector(":scope div.chat-topic-filter-bar");
                this.e_topic_filter_select = this.container.querySelector(":scope select.chat-topic-filter-select");
                this.e_topic_filter_clear = this.container.querySelector(":scope button.chat-topic-filter-clear");
                // å½“å‰ç­›é€‰çš„è¯é¢˜
                this.current_topic_filter = '';

                // è¯é¢˜ç­›é€‰äº‹ä»¶
                if (this.e_topic_filter_select) {
                    this.e_topic_filter_select.addEventListener("change", (e) => {
                        this.current_topic_filter = e.target.value;
                        this.apply_topic_filter();
                    });
                }

                // æ¸…é™¤ç­›é€‰
                if (this.e_topic_filter_clear) {
                    this.e_topic_filter_clear.addEventListener("click", () => {
                        this.current_topic_filter = '';
                        if (this.e_topic_filter_select) {
                            this.e_topic_filter_select.value = '';
                        }
                        this.apply_topic_filter();
                    });
                }

                this.e_msgflow = this.container.querySelector(":scope div.chat-session-msgflow");
                this.e_msgflow_wrap = this.container.querySelector(":scope div.chat-session-msgflow-wrap");

                this.e_msgflow_mark_onlineusers = this.container.querySelector(":scope div.chat-session-msgflow-mark-onlineusers");
                this.e_msgflow_mark_onlineusers.classList.add("hidden");
                remove_simple_loading_mark(this.e_msgflow_mark_onlineusers);

                // æŸ¥çœ‹åœ¨çº¿æˆå‘˜
                if (this.is_group()) {
                    this.e_header_info_clickmark.addEventListener("click", (event) => {
                        if (this.e_msgflow_mark_onlineusers.classList.contains("hidden")) {
                            this.fetch_online_users();
                        } else {
                            this.e_msgflow_mark_onlineusers.classList.add("hidden");
                        }
                    });
                } else {
                    this.e_header_info_clickmark.classList.add("hidden");
                }
                this.e_msgflow.addEventListener("click", (event) => {
                    this.e_msgflow_mark_onlineusers.classList.add("hidden");
                });

                // headerå³ä¾§æŒ‰é’®
                this.e_header_action_more = this.e_header_actions.querySelector(":scope button.chat-session-header-action-more");
                this.e_header_action_more.addEventListener("click", (event) => {
                    const rect = this.e_header_action_more.getBoundingClientRect();
                    const items = [];

                    items.push(
                        {
                            type: "button", text: "å¯¼å‡ºèŠå¤©è®°å½•(ä¸å¸¦å›¾ç‰‡)", callback: event => {
                                this.output_msgs(false);
                            },
                        },
                        {
                            type: "button", text: "å¯¼å‡ºèŠå¤©è®°å½•(å›¾ç‰‡æ–‡ä»¶å¤¹)", callback: event => {
                                this.output_msgs(true);
                            },
                        },
                        {type: "section", text: "",},
                        {
                            type: "button", text: "æ‰¹é‡åˆ é™¤", callback: event => {
                                this.enter_batch_mode();
                            },
                        },
                        {
                            type: "button", text: "æ¸…ç†æ¶ˆæ¯", callback: event => {
                                this.clear_msgs();
                            },
                        },
                    );

                    MenuMark.exec({x: rect.left, y: rect.top + rect.height,}, items, () => {
                    });
                });

                // è§†å£é¦–æ¡æ¶ˆæ¯æ—¥æœŸ
                this.e_msgflow_mark_currentday = this.container.querySelector(":scope div.chat-session-msgflow-mark-currentday");
                this.e_msgflow_mark_currentday_p = this.e_msgflow_mark_currentday.querySelector(":scope p");
                this.e_msgflow_mark_currentday__timer = null;
                this.show_currentday_mark();

                // æ­£åœ¨åŠ è½½ å†å²å’Œè·æ–°
                this.e_msgflow_mark_loadhistory = this.container.querySelector(":scope div.chat-session-msgflow-mark-loadhistory");
                this.e_msgflow_mark_loadhistory_p = this.e_msgflow_mark_loadhistory.querySelector(":scope p");
                this.e_msgflow_mark_checknew = this.container.querySelector(":scope div.chat-session-msgflow-mark-checknew");
                this.e_msgflow_mark_checknew_p = this.e_msgflow_mark_checknew.querySelector(":scope p");
                this.change_loading_status__loadhistory();
                this.change_loading_status__checknew();

                // æ‰˜æ”¾æç¤º
                this.e_msgflow_mark_droparea = this.container.querySelector(":scope div.chat-session-msgflow-mark-droparea");
                this.e_msgflow_mark_droparea_image = this.container.querySelector(":scope div.chat-session-msgflow-mark-droparea-image");
                this.e_msgflow_mark_droparea_file = this.container.querySelector(":scope div.chat-session-msgflow-mark-droparea-file");
                this.e_msgflow_mark_droparea.addEventListener("click", (event) => {
                    this.e_msgflow_mark_droparea.classList.add("hidden");
                });

                // æ»šåŠ¨åˆ°æœ«å°¾æŒ‰é’®
                const showThreshold = 200;
                let is_auto_scrolling = false;
                let is_moving = false;
                this.e_msgflow_btn_scroll2end = this.container.querySelector(":scope button.chat-session-msgflow-btn-scroll2end");
                this.e_msgflow_btn_scroll2end.addEventListener('click', () => {
                    is_auto_scrolling = true;
                    this.e_msgflow_btn_scroll2end.classList.add('hide');
                    this.e_msgflow.scrollTo({
                        top: this.e_msgflow.scrollHeight,
                        behavior: 'smooth'
                    });
                    setTimeout(() => {
                        is_auto_scrolling = false;
                    }, 500);
                });

                // å½“é¡µé¢æœªæ»šåŠ¨åˆ°åº•éƒ¨æ—¶æ˜¾ç¤ºæŒ‰é’®
                const check_scroll_to_end = () => {
                    if (!is_auto_scrolling && !is_moving) {
                        const scrollTop = this.e_msgflow.scrollTop;
                        const scrollHeight = this.e_msgflow.scrollHeight;
                        const clientHeight = this.e_msgflow.clientHeight;
                        if (scrollTop + clientHeight < scrollHeight - showThreshold) {
                            this.e_msgflow_btn_scroll2end.classList.remove('hidden');
                            if (this.e_msgflow_btn_scroll2end.classList.contains("hide")) {
                                // this.e_msgflow_btn_scroll2end.classList.remove('hide');
                                setTimeout(() => {
                                    is_moving = true;
                                    this.e_msgflow_btn_scroll2end.classList.remove('hide');
                                }, 0);
                            }
                            is_moving = true;
                        } else {
                            if (!this.e_msgflow_btn_scroll2end.classList.contains("hide")) {
                                this.e_msgflow_btn_scroll2end.classList.add('hide');
                            }
                            is_moving = true;
                        }
                        setTimeout(() => {
                            is_moving = false;
                            if (this.e_msgflow_btn_scroll2end.classList.contains("hide")) {
                                this.e_msgflow_btn_scroll2end.classList.add('hidden');
                            }
                        }, 200);
                    }
                };

                // æ»šåŠ¨æ¡
                this.e_msgflow__load_history_timer = null;
                this.e_msgflow__checknew_timer = null;
                this.e_msgflow__checknew_timer__enabled = false; // é¿å…åœ¨æ‰“å¼€é¡µé¢æ—¶é‡å¤è¯·æ±‚
                this.e_msgflow__checknew_timer__last_emit_time = Date.now(); // é¿å…åœ¨å‘é€æ¶ˆæ¯ç­‰æ—¶çš„è‡ªåŠ¨æ»šåŠ¨ï¼Œå¯¼è‡´é‡å¤è¯·æ±‚
                this.e_msgflow.addEventListener('wheel', (event) => {
                    this.check_scroll_position_to_load(event);
                });
                this.e_msgflow__scroll_timer = null;
                this.e_msgflow.addEventListener('scroll', (event) => {
                    this.check_scroll_position_to_load(event);

                    clearTimeout(this.e_msgflow__scroll_timer);
                    this.e_msgflow__scroll_timer = setTimeout(() => {
                        if (this.closed) return;

                        check_scroll_to_end();

                        // æ‰¾åˆ°é¦–ä¸ªå¯è§å…ƒç´ 
                        const container = this.e_msgflow;
                        const items = this.li.bindmap.msgs.filter(i => i.msgobj.is_header()).map(i => i.msgobj.msgelement);
                        let firstVisible = null
                        const observer = new IntersectionObserver((entries) => {
                            // è¿‡æ»¤å‡ºå½“å‰å¯è§çš„å…ƒç´ 
                            const visibleItems = entries
                                .filter(entry => entry.isIntersecting)
                                // .sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top)
                                .sort((a, b) => a.id - b.id)

                            if (visibleItems.length > 0) {
                                firstVisible = visibleItems[0].target
                                this.show_currentday_mark(firstVisible.msgobj.msgattr);
                            }
                        }, {
                            root: container, // æŒ‡å®šæ»šåŠ¨å®¹å™¨
                            threshold: 0.01  // å…ƒç´ åªè¦éœ²å‡ºæ¥ä¸€ç‚¹ç‚¹å°±ç®—å¯è§
                        })
                        items.forEach(item => observer.observe(item))
                    }, 150);
                })


                // å…³é—­
                this.e_header_btn_close = this.container.querySelector(":scope button.chat-session-header-btn-close");
                this.e_header_btn_close.addEventListener("click", (event) => {
                    this.client.close_content_page();
                });

                // æ–‡æœ¬è¾“å…¥
                this.e_inputarea_textarea = this.container.querySelector(".chat-session-inputarea-textarea");
                
                // AIå’¨è¯¢
                this.e_ai_teacher_btn = this.container.querySelector(
                    ".chat-session-inputarea-othertypes-ai"
                );


               // 1ï¸âƒ£ å…ˆç»‘å®šå¿«æ·é”®ï¼Œç‹¬ç«‹äºç‚¹å‡»äº‹ä»¶
                this.e_inputarea_textarea.addEventListener("keydown", (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === "Enter") {
                        this.e_ai_teacher_btn.click();
                    }
                });

                // 2ï¸âƒ£ ç‚¹å‡» AI å’¨è¯¢æŒ‰é’®
                this.e_ai_teacher_btn.addEventListener("click", () => {
                    const userText = this.e_inputarea_textarea.value.trim();

                    if (!userText) {
                        showAiAlert("ğŸ¤– è¾“å…¥æ¡†æ²¡æœ‰è¾“å…¥é—®é¢˜ï¼Œè¯·åœ¨è¾“å…¥æ¡†å…ˆè¾“å…¥ä½ çš„é—®é¢˜ï¼Œç„¶å AI è€å¸ˆæ‰èƒ½å¸®ä½ è®²è§£å“¦ï¼");
                        return;
                    }

                    const prompt = build_ai_teacher_prompt(userText);
                    const encodedPrompt = encodeURIComponent(prompt);

                    // è·³è½¬ AI å’¨è¯¢é¡µé¢
                    window.open(`https://chatgpt.com/?q=${encodedPrompt}`, "_blank");
                });


				// =============================
				// ğŸ”¥ åŠå±å€™é€‰è¯ï¼šDOM å¼•ç”¨
				// =============================
				this.e_candidate_btn = this.container.querySelector(
					".chat-session-inputarea-othertypes-candidates"
				);

				this.e_candidate_panel = this.container.querySelector(
					".chat-candidate-panel"
				);

				this.e_candidate_panel_body = this.container.querySelector(
					".chat-candidate-panel-body"
				);

				this.e_candidate_panel_close = this.container.querySelector(
					".chat-candidate-panel-close"
				);


				// ğŸ”¹ åŠå±å€™é€‰è¯ DOM
				this.e_candidate_panel_body = this.container.querySelector(".chat-candidate-panel-body");
				this.e_candidate_prev = this.container.querySelector(".chat-candidate-panel-prev");
				this.e_candidate_next = this.container.querySelector(".chat-candidate-panel-next");
				this.e_candidate_filter = this.container.querySelector(".chat-candidate-panel-filter");

				// ğŸ”¹ æ›´æ–°æŒ‰é’®çŠ¶æ€å‡½æ•°
				const updateCandidateButtons = () => {
					const body = this.e_candidate_panel_body;
					this.e_candidate_prev.disabled = body.scrollTop <= 0;
					this.e_candidate_next.disabled = body.scrollTop + body.clientHeight >= body.scrollHeight;
				};

				


				// ğŸ”¹ ç¿»é¡µæŒ‰é’®
				const scrollStep = 150;
				this.e_candidate_prev.addEventListener("click", () => {
					this.e_candidate_panel_body.scrollBy({ top: -scrollStep, behavior: 'smooth' });
				});
				this.e_candidate_next.addEventListener("click", () => {
					this.e_candidate_panel_body.scrollBy({ top: scrollStep, behavior: 'smooth' });
				});

				// ğŸ”¹ æ»šåŠ¨äº‹ä»¶
				this.e_candidate_panel_body.addEventListener("scroll", updateCandidateButtons);

				// ğŸ”¹ æ‰“å¼€é¢æ¿æŒ‰é’®
				this.e_candidate_btn.addEventListener("click", () => {
					this.render_candidate_panel(this.commonPhrases);
					this.e_candidate_panel.classList.remove("hidden");
					updateCandidateButtons();
				});



                // è‡ªåŠ¨é«˜åº¦
                this.e_inputarea_textarea.addEventListener('input', () => {
                    this.e_inputarea_textarea.style.height = 'auto';
                    this.e_inputarea_textarea.style.height =
                        `${this.e_inputarea_textarea.scrollHeight}px`;
                });

                // focus / blur
                this.e_inputarea_textarea.addEventListener('focus', () => {
                    if (this.client.dashboard_chat.wrapper.is_active()) {
                        floatball.setOpacity(0.7);
                    }
                });
                this.e_inputarea_textarea.addEventListener('blur', () => {
                    floatball.setOpacity(1);
                });



                 // =============================
                // ğŸ”¥ æ–°å¢ï¼šå€™é€‰è¯é€»è¾‘
                // =============================
                // =============================
                // ç±»åˆå§‹åŒ–æ—¶
                // å€™é€‰è¯å®¹å™¨
                this.e_inputarea_candidates = this.container.querySelector(".chat-session-inputarea-candidates");

                // é¼ æ ‡æ‚¬åœæ—¶å°†å‚ç›´æ»šè½®è½¬æ¢ä¸ºæ°´å¹³æ»šåŠ¨
                if (this.e_inputarea_candidates) {
                    this.e_inputarea_candidates.addEventListener('wheel', (event) => {
                        if (this.e_inputarea_candidates.scrollWidth > this.e_inputarea_candidates.clientWidth) {
                            event.preventDefault();
                            this.e_inputarea_candidates.scrollLeft += event.deltaY * 2;
                        }
                    }, { passive: false });
                }


                
                // =============================
                // ğŸ”¥ è¯é¢˜é€‰æ‹©å™¨é€»è¾‘
                // =============================
                this.e_topic_selector = this.container.querySelector(".chat-topic-selector");
                this.e_topic_select = this.container.querySelector(".chat-topic-select");
                this.e_topic_new_input = this.container.querySelector(".chat-topic-new-input");
                this.e_topic_new_btn = this.container.querySelector(".chat-topic-new-btn");
                
                console.log("è¯é¢˜é€‰æ‹©å™¨å…ƒç´ :", this.e_topic_selector, this.e_topic_select);
                
                // æ”¶é›†å½“å‰ä¼šè¯ä¸­çš„è¯é¢˜
                this.current_topics = [''];  // é»˜è®¤ä¸ºç©ºï¼ˆé—²èŠï¼‰
                
                // æ˜¾ç¤ºè¯é¢˜é€‰æ‹©å™¨ï¼ˆä»…ç¾¤èŠæ—¶æ˜¾ç¤ºï¼‰
                this.update_topic_selector_visibility = () => {
                    if (!this.e_topic_selector) {
                        console.log("è¯é¢˜é€‰æ‹©å™¨æœªæ‰¾åˆ°");
                        return;
                    }
                    try {
                        const {contact_type} = this.current_contact_xxid();
                        if (contact_type === subviews.Chat.receiver_type.group) {
                            this.e_topic_selector.classList.remove("hidden");
                            console.log("æ˜¾ç¤ºè¯é¢˜é€‰æ‹©å™¨ - ç¾¤èŠ");
                        } else {
                            this.e_topic_selector.classList.add("hidden");
                            console.log("éšè—è¯é¢˜é€‰æ‹©å™¨ - ç§èŠ");
                        }
                    } catch (e) {
                        console.error("è¯é¢˜é€‰æ‹©å™¨åˆå§‹åŒ–é”™è¯¯:", e);
                    }
                };
                
                // åˆ·æ–°è¯é¢˜ä¸‹æ‹‰åˆ—è¡¨
                this.refresh_topic_list = () => {
                    if (!this.e_topic_select) {
                        console.log("è¯é¢˜ä¸‹æ‹‰æ¡†æœªæ‰¾åˆ°");
                        return;
                    }
                    const currentVal = this.e_topic_select.value;
                    this.e_topic_select.innerHTML = '';
                    
                    // æ·»åŠ "é—²èŠ"é€‰é¡¹
                    const defaultOpt = document.createElement('option');
                    defaultOpt.value = '';
                    defaultOpt.textContent = 'ğŸ“ é—²èŠ';
                    this.e_topic_select.appendChild(defaultOpt);
                    
                    // æ·»åŠ å·²æœ‰è¯é¢˜
                    this.current_topics.forEach(topic => {
                        if (topic) {
                            const opt = document.createElement('option');
                            opt.value = topic;
                            opt.textContent = '# ' + topic;
                            this.e_topic_select.appendChild(opt);
                        }
                    });
                    
                    // æ¢å¤é€‰ä¸­å€¼
                    if (this.current_topics.includes(currentVal)) {
                        this.e_topic_select.value = currentVal;
                    }
                };
                
                // æ·»åŠ æ–°è¯é¢˜
                this.add_topic = () => {
                    const newTopic = this.e_topic_new_input.value.trim();
                    if (newTopic && !this.current_topics.includes(newTopic)) {
                        this.current_topics.push(newTopic);
                        this.refresh_topic_list();
                        this.e_topic_select.value = newTopic;
                    }
                    this.e_topic_new_input.value = '';
                    this.e_topic_new_input.classList.add("hidden");
                    this.e_topic_new_btn.classList.remove("hidden");
                    this.e_topic_select.classList.remove("hidden");
                };
                
                // ç‚¹å‡»"æ–°è¯é¢˜"æŒ‰é’®
                if (this.e_topic_new_btn) {
                    this.e_topic_new_btn.addEventListener("click", () => {
                        this.e_topic_select.classList.add("hidden");
                        this.e_topic_new_btn.classList.add("hidden");
                        this.e_topic_new_input.classList.remove("hidden");
                        this.e_topic_new_input.focus();
                    });
                }
                
                // è¾“å…¥æ–°è¯é¢˜åæŒ‰å›è½¦åˆ›å»º
                if (this.e_topic_new_input) {
                    this.e_topic_new_input.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") {
                            this.add_topic();
                        }
                    });
                }
                
                // åˆ›å»ºæŒ‰é’®
                const createTopicBtn = this.container.querySelector(".chat-topic-new-btn");
                if (createTopicBtn) {
                    createTopicBtn.addEventListener("click", () => {
                        this.e_topic_select.classList.add("hidden");
                        createTopicBtn.classList.add("hidden");
                        this.e_topic_new_input.classList.remove("hidden");
                        this.e_topic_new_input.focus();
                    });
                }


				
				
				
				
				// =============================
			// ğŸ”¥ ä»APIåŠ è½½å€™é€‰è¯
			// =============================
			// ğŸ”¥ ä»APIåŠ è½½å€™é€‰è¯
			// =============================
			let commonPhrases = [];
			
			// åŠ è½½å€™é€‰è¯åˆ—è¡¨
			async function loadCandidateWords() {
				try {
					const url = join_path(root_url(), "api", "candidate_word");
					const resp = await fetch(url, {
						credentials: 'include'
					});
					if (resp.ok) {
						const words = await resp.json();
						if (words && words.length > 0) {
							commonPhrases = words;
							return;
						}
					}
				} catch (e) {
					console.error('åŠ è½½å€™é€‰è¯å¤±è´¥', e);
				}
				// åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤å€™é€‰è¯
				commonPhrases = [
					"è¯·è‡ªè¡Œæ·»åŠ "
				];
			}
				
			// ä½¿ç”¨å€™é€‰è¯åæ›´æ–°é¢‘ç‡
			async function useCandidateWord(word) {
				try {
					const url = join_path(root_url(), "api", "candidate_word", "use");
					await fetch(url, {
						method: 'POST',
						headers: {'Content-Type': 'application/json'},
						body: JSON.stringify({word}),
						credentials: 'include'
					});
				} catch (e) {
					console.error('æ›´æ–°ä½¿ç”¨é¢‘ç‡å¤±è´¥', e);
				}
			}
				
			// åˆå§‹åŠ è½½å€™é€‰è¯
			loadCandidateWords();
			
			// =============================
			// ğŸ”¥ åŠå±å€™é€‰è¯æ¸²æŸ“
				// =============================
				this.render_candidate_panel = (list) => {
					const body = this.e_candidate_panel_body;
					body.innerHTML = "";

					list.forEach(text => {
						const div = document.createElement("div");
						div.className = "chat-candidate-item";
						div.textContent = text;

						div.addEventListener("click", () => {
							this.add_new_textarea_element(text);
							this.send_msg_text();
							useCandidateWord(text);
							this.e_candidate_panel.classList.add("hidden");
						});

						body.appendChild(div);
					});
				};

               // æ¸²æŸ“å€™é€‰è¯ï¼ˆåªæ›´æ–°å­å…ƒç´ ï¼Œæœ€å¤šæ˜¾ç¤º50ä¸ªï¼‰
                const renderCandidates = (list) => {
                    const container = this.e_inputarea_candidates;

                    // æ¸…ç©ºå­å…ƒç´ 
                    container.querySelectorAll(".chat-session-inputarea-candidate-item").forEach(el => el.remove());

                    if (!list.length) {
                        container.classList.add("hidden");
                        return;
                    }

                    // åªå–å‰50ä¸ª
                    const limitedList = list.slice(0, 2000);

                    limitedList.forEach(text => {
                        const div = document.createElement("div");
                        div.className = "chat-session-inputarea-candidate-item";
                        div.textContent = text;
                        container.appendChild(div);
                    });

                    container.classList.remove("hidden");
                };


				// ğŸ”¹ è¾“å…¥ç­›é€‰äº‹ä»¶
				this.e_candidate_filter.addEventListener("input", () => {
					const v = this.e_candidate_filter.value.trim();
					const filtered = v === "" ? commonPhrases : commonPhrases.filter(p => p.includes(v));
					this.render_candidate_panel(filtered); // âœ… ä¼ å…¥ç­›é€‰åçš„åˆ—è¡¨
					this.e_candidate_panel_body.scrollTop = 0;
					updateCandidateButtons();
				});
				
                // è¾“å…¥æ¡† input æ˜¾ç¤ºå€™é€‰è¯
                this.e_inputarea_textarea.addEventListener("input", () => {
                    const v = this.e_inputarea_textarea.value.trim();
                    renderCandidates(v === "" ? commonPhrases : commonPhrases.filter(p => p.includes(v)));
                });

                // focus æ˜¾ç¤ºå€™é€‰è¯
                this.e_inputarea_textarea.addEventListener("focus", () => {
                    renderCandidates(commonPhrases);
                });

                // blur éšè—å€™é€‰è¯ï¼Œä½†åˆ¤æ–­å¦‚æœæ­£åœ¨ç‚¹å‡»å€™é€‰è¯å°±ä¸éšè—
                this.e_inputarea_textarea.addEventListener("blur", (e) => {
                    setTimeout(() => {
                        const active = document.activeElement;
                        if (!active.classList.contains("chat-session-inputarea-candidate-item")) {
                            this.e_inputarea_candidates.classList.add("hidden");
                        }
                    }, 150);
                });


				// =============================
				// ğŸ”¥ åŠå±å€™é€‰è¯ï¼šæ‰“å¼€ / å…³é—­
				// =============================
				this.e_candidate_btn.addEventListener("click", () => {
					this.render_candidate_panel(commonPhrases);
					this.e_candidate_panel.classList.remove("hidden");
				});

				this.e_candidate_panel_close.addEventListener("click", () => {
					this.e_candidate_panel.classList.add("hidden");
				});

                // âœ… äº‹ä»¶å§”æ‰˜ï¼Œç»‘å®šåœ¨çˆ¶å®¹å™¨ï¼ˆæ°¸è¿œæœ‰æ•ˆï¼‰
                this.e_inputarea_candidates.addEventListener("mousedown", (e) => {
                    // ç”¨ mousedown è€Œä¸æ˜¯ clickï¼Œé¿å… blur å…ˆè§¦å‘éšè—
                    const item = e.target.closest(".chat-session-inputarea-candidate-item");
                    if (!item) return;

                    // æ’å…¥å…‰æ ‡ä½ç½®
                    this.add_new_textarea_element(item.textContent);

                    this.send_msg_text();
                    
                    // æ›´æ–°å€™é€‰è¯ä½¿ç”¨é¢‘ç‡
                    useCandidateWord(item.textContent);

                    // éšè—å€™é€‰è¯
                    this.e_inputarea_candidates.classList.add("hidden");
                });


                // ç»‘å®šåœ¨çˆ¶å®¹å™¨ä¸Š
                this.container.addEventListener("click", (e) => {
                    const item = e.target.closest(".chat-session-inputarea-candidate-item");
                    if (!item) return; // ä¸æ˜¯å€™é€‰è¯å°±å¿½ç•¥

                    // æ’å…¥æ–‡æœ¬å¹¶å‘é€
                    this.add_new_textarea_element(item.textContent);
                    this.send_msg_text();
                    
                    // æ›´æ–°å€™é€‰è¯ä½¿ç”¨é¢‘ç‡
                    useCandidateWord(item.textContent);

                    // éšè—å€™é€‰è¯
                    this.e_inputarea_candidates.classList.add("hidden");
                });



                // =============================
                // ğŸ”¥ æ¨ªå‘æ»šåŠ¨æŒ‰é’®
                // =============================
                const prevBtn = this.container.querySelector(".chat-session-inputarea-candidates .btn-prev");
                const nextBtn = this.container.querySelector(".chat-session-inputarea-candidates .btn-next");

                if (prevBtn) prevBtn.addEventListener("click", () => {
                    this.e_inputarea_candidates.scrollBy({ left: -100, behavior: "smooth" });
                });
                if (nextBtn) nextBtn.addEventListener("click", () => {
                    this.e_inputarea_candidates.scrollBy({ left: 100, behavior: "smooth" });
                });



                // ğŸ”¥ å›è½¦å‘é€ï¼ˆåŸé€»è¾‘ï¼Œä¿ç•™ï¼‰
                this.e_inputarea_textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.send_msg_text();
                        this.update_activity(
                            dashboardwrappers.ChatDashboardWrapper.activity_type.none
                        );
                        this.e_inputarea_textarea.style.height = 'auto';
                        this.e_inputarea_textarea.style.height =
                            `${this.e_inputarea_textarea.scrollHeight}px`;
                    }
                });

                // è¾“å…¥çŠ¶æ€ + å‘é€æŒ‰é’®ç¦ç”¨
                this.e_inputarea_textarea.addEventListener('input', () => {
                    const text = this.e_inputarea_textarea.value;

                    if (text.length > 0) {
                        this.update_activity(
                            dashboardwrappers.ChatDashboardWrapper.activity_type.typing
                        );
                    } else {
                        this.update_activity(
                            dashboardwrappers.ChatDashboardWrapper.activity_type.none
                        );
                    }

                    // ğŸ”¥ åŒæ­¥å‘é€æŒ‰é’®çŠ¶æ€
                    if (this.e_inputarea_sendbtn) {
                        this.e_inputarea_sendbtn.disabled = text.length === 0;
                    }
                });



                // åŠ è½½è‰ç¨¿
                this.load_draft_text();

                // ç¼–è¾‘æç¤º
                this.e_inputarea_tip_editing = this.container.querySelector(
                    ":scope .chat-session-inputarea-tip-editing"
                );
                this.e_inputarea_tip_editing__cancel_btn =
                    this.e_inputarea_tip_editing.querySelector(":scope > button");

                this.e_inputarea_tip_editing__cancel_btn.addEventListener("click", () => {
                    this.end_editing_msg();
                });

                // =============================
                // ğŸ”¥ æ–°å¢ï¼šå‘é€æŒ‰é’®é€»è¾‘
                // =============================
                this.e_inputarea_sendbtn = this.container.querySelector(
                    ":scope .chat-session-inputarea-sendbtn"
                );

                if (this.e_inputarea_sendbtn) {
                    // åˆå§‹ç¦ç”¨
                    this.e_inputarea_sendbtn.disabled = true;

                    // ç‚¹å‡»å‘é€
                    this.e_inputarea_sendbtn.addEventListener('click', () => {
                        this.send_msg_text();
                        this.update_activity(
                            dashboardwrappers.ChatDashboardWrapper.activity_type.none
                        );
                        this.e_inputarea_textarea.style.height = 'auto';
                        this.e_inputarea_textarea.style.height =
                            `${this.e_inputarea_textarea.scrollHeight}px`;
                    });
                }


                // å…¶ä»–æ¶ˆæ¯ç±»å‹
                this.e_othertypes_image = this.container.querySelector(":scope button.chat-session-inputarea-othertypes-image");
                this.e_othertypes_image.addEventListener("click", (event) => {
                    this.e_othertypes_image__input.click();
                });
                this.e_othertypes_image__input = this.e_othertypes_image.querySelector(":scope > input");
                this.e_othertypes_image__input.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        this.start__send_msg_image(file);
                    }
                });


                this.e_othertypes_file = this.container.querySelector(":scope button.chat-session-inputarea-othertypes-file");
                this.e_othertypes_file.addEventListener("click", (event) => {
                    this.e_othertypes_file__input.click();
                });
                this.e_othertypes_file__input = this.e_othertypes_file.querySelector(":scope > input");
                this.e_othertypes_file__input.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        this.start__send_msg_file(file);
                    }
                });

                // æ‹–æ‹½ä¸Šä¼ 
                this.e_msgflow_wrap.addEventListener('dragenter', (event) => {
                    if (!check_if_contains_file_in_drop_event(event)) return;
                    if (dragging_item) return;
                    event.preventDefault();
                    // this.e_msgflow_wrap.classList.add("drag-active");
                    this.e_msgflow_mark_droparea.classList.remove("hidden");
                });
                this.e_msgflow_wrap.addEventListener('dragover', (event) => {
                    if (!check_if_contains_file_in_drop_event(event)) return;
                    if (dragging_item) return;
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'copy';
                    // this.e_msgflow_wrap.classList.add("drag-active");
                    this.e_msgflow_mark_droparea.classList.remove("hidden");
                });
                this.e_msgflow_wrap.addEventListener('dragleave', () => {
                    if (dragging_item) return;
                    // this.e_msgflow_wrap.classList.remove("drag-active");
                    this.e_msgflow_mark_droparea.classList.add("hidden");
                });
                this.e_msgflow_wrap.addEventListener('drop', async (event) => {
                    if (dragging_item) return;
                    event.preventDefault();
                    // this.e_msgflow_wrap.classList.remove("drag-active");
                    this.e_msgflow_mark_droparea.classList.add("hidden");
                    const dataTransferItems = event.dataTransfer.items;
                    const validFiles = [];
                    const validFolders = [];
                    for (let i = 0; i < dataTransferItems.length; i++) {
                        const item = dataTransferItems[i];
                        const entry = item.webkitGetAsEntry && item.webkitGetAsEntry();
                        // console.log(item, entry);
                        if (item.kind === 'file') {
                            if (entry && entry.isDirectory) {
                                // validFolders.push(entry);
                            } else {
                                const file = item.getAsFile();
                                // console.log(file,);
                                if (file) {
                                    validFiles.push(file);
                                }
                            }
                        }
                    }
                    if (validFolders.length > 0) {
                        for (const entry of validFolders) {
                            const files = await getAllFilesFromDroppedFolder(entry);
                            for (const file of files) {
                                // console.log(file.relativePath, file);
                                file.relativePath.pop()
                                validFiles.push(file);
                            }
                        }
                        // return;
                    }
                    let files = [];
                    if (validFiles.length > 0) {
                        for (const file of validFiles) {
                            let can = true;

                            let name = normalizeName(file.name);
                            if (!name) can = false;

                            if (!can) {
                                // continue;
                                return;
                            }

                            // for (let disallowedUploadElement of disallowed_upload) {
                            //     if (name.endsWith(disallowedUploadElement)) {
                            //         MessageMark.report(`ä¸å…è®¸ä¸Šä¼ ï¼š${disallowedUploadElement}`);
                            //         can = false;
                            //         break;
                            //     }
                            // }

                            if (!can) {
                                // continue;
                                return;
                            }

                            // if (root_attr.max_upload_size > 0 && file.size >= root_attr.max_upload_size * 1024 * 1024) {
                            //     alert(`å•æ–‡ä»¶å¤§å°é™åˆ¶ä¸º${root_attr.max_upload_size}MBã€‚`);
                            //     can = false;
                            //     // continue;
                            //     return;
                            // }

                            if (file.relativePath && file.relativePath.length > 0) {
                            } else {
                            }

                            if (!can) {
                                // continue;
                                return;
                            }

                            files.push(file)
                        }
                    }
                    if (files.length > 0) {
                        if (event.target === this.e_msgflow_mark_droparea_image) {
                            for (const file of files) {
                                this.start__send_msg_image(file);
                            }
                            // floatball.look_upload_tasks();
                        } else if (event.target === this.e_msgflow_mark_droparea_file) {
                            for (const file of files) {
                                this.start__send_msg_file(file);
                            }
                            // floatball.look_upload_tasks();
                        }
                        // MessageMark.confirm(`${files.length}ä¸ªæ–‡ä»¶ï¼Œå¼€å§‹ä¸Šä¼ ï¼Ÿ`, null, null, () => {
                        // }, MessageMark.colors.blue)
                    }
                });


                // console.log("sending_msgs", this.li.bindmap.sending_msgs)
                // console.log("msgs", this.li.bindmap.msgs)

                this.msgflow_manage.load_msgs();
                this.msgflow_manage.load_sending_msgs();
                this.refresh();
                this.start_timer__fetch_unread_msgs(false);
                this.start_timer__update_read_progress(false);
                
                // ğŸ”¥ æ›´æ–°è¯é¢˜é€‰æ‹©å™¨æ˜¾ç¤ºçŠ¶æ€
                if (this.update_topic_selector_visibility) {
                    this.update_topic_selector_visibility();
                }
                
                // ğŸ”¥ åˆå§‹åŒ–è¯é¢˜ä¸‹æ‹‰åˆ—è¡¨
                if (this.refresh_topic_list) {
                    this.refresh_topic_list();
                }
                
                // ğŸ”¥ åˆå§‹åŒ–è¯é¢˜ç­›é€‰æ 
                if (this.refresh_topic_filter_list) {
                    this.refresh_topic_filter_list();
                }
                if (this.update_topic_filter_visibility) {
                    this.update_topic_filter_visibility();
                }

                // âš¡ æ–°å¢å†™å­—åŠŸèƒ½ DOM
                this.e_writeboard = this.container.querySelector(".chat-writeboard");
                this.e_writeboard_canvas = this.container.querySelector(".chat-writeboard-canvas");
                this.e_writeboard_btn = this.container.querySelector(".chat-session-inputarea-othertypes-write");
                this.e_writeboard_close = this.container.querySelector(".chat-writeboard-close");
                this.e_writeboard_clear = this.container.querySelector(".chat-writeboard-clear");
                this.e_writeboard_confirm = this.container.querySelector(".chat-writeboard-confirm");
                this.e_writeboard_eraser = this.container.querySelector(".chat-writeboard-eraser");
                this.e_writeboard_size = this.container.querySelector(".chat-writeboard-size");




                // é¼ æ ‡ç»˜å›¾çŠ¶æ€
                this.write_ctx = null;
                this.write_drawing = false;
                this.write_is_eraser = false; // â­ æ˜¯å¦æ©¡çš®æ“¦


                // âš¡ åˆå§‹åŒ–å†™å­—æ¿
                this.init_writeboard = () => {
                    const canvas = this.e_writeboard_canvas;

                    // å°† canvas HTML å®½é«˜åŒæ­¥ä¸º CSS å°ºå¯¸
                    const resizeCanvas = () => {
                        const tempData = canvas.toDataURL(); // æš‚å­˜å†…å®¹ï¼Œé˜²æ­¢æ¸…å±
                        canvas.width = canvas.clientWidth;
                        canvas.height = canvas.clientHeight;

                        // è·å– 2D ä¸Šä¸‹æ–‡
                        this.write_ctx = canvas.getContext("2d");

                        // é»˜è®¤èƒŒæ™¯ç™½è‰²
                        this.write_ctx.fillStyle = "#fff";
                        this.write_ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // å¦‚æœæœ‰ä¹‹å‰å†…å®¹ï¼Œç»˜å›å»
                        if (tempData) {
                            const img = new Image();
                            img.src = tempData;
                            img.onload = () => {
                                this.write_ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            };
                        }

                        // è®¾ç½®ç”»ç¬”å±æ€§
                        this.write_ctx.strokeStyle = "#000";
                        const size = parseInt(this.e_writeboard_size.value || 4);

                        if (this.write_is_eraser) {

                            this.write_ctx.globalCompositeOperation = "destination-out";
                            this.write_ctx.lineWidth = size * 3;

                        } else {

                            this.write_ctx.globalCompositeOperation = "source-over";
                            this.write_ctx.strokeStyle = "#000";
                            this.write_ctx.lineWidth = size;
                        }

                        this.write_ctx.lineCap = "round";
                    };
                    resizeCanvas();
                    window.addEventListener("resize", resizeCanvas);


                    // é¼ æ ‡ç»˜å›¾
                    canvas.onmousedown = (e) => {
                        this.write_drawing = true;


                        const size = parseInt(this.e_writeboard_size.value || 4);

                        if (this.write_is_eraser) {
                            // ğŸ§½ æ©¡çš®æ“¦æ¨¡å¼
                            this.write_ctx.globalCompositeOperation = "destination-out";
                            this.write_ctx.lineWidth = size * 3;   // æ ¹æ®æ»‘å—
                        } else {
                            // âœï¸ å†™å­—æ¨¡å¼
                            this.write_ctx.globalCompositeOperation = "source-over";
                            this.write_ctx.strokeStyle = "#000";
                            this.write_ctx.lineWidth = size;       // æ ¹æ®æ»‘å—
                        }

                        this.write_ctx.beginPath();
                        this.write_ctx.moveTo(e.offsetX, e.offsetY);
                    };


                    canvas.onmousemove = (e) => {
                        if (!this.write_drawing) return;

                        const x = e.offsetX;
                        const y = e.offsetY;

                        this.write_ctx.lineTo(x, y);
                        this.write_ctx.stroke();

                        // â­ å…³é”®ï¼šè®©è·¯å¾„è¿ç»­ï¼Œæ©¡çš®æ“¦æ›´ä¸æ»‘
                        this.write_ctx.beginPath();
                        this.write_ctx.moveTo(x, y);
                    };

                    canvas.onmouseup = canvas.onmouseleave = () => {
                        this.write_drawing = false;
                    };

                    // âš¡ æ‹–æ‹½è°ƒæ•´é¢æ¿å¤§å°ï¼ˆå³ä¸‹è§’ï¼‰
                    const panel = this.e_writeboard.querySelector(".chat-writeboard-panel");

                    // åˆ›å»ºå³ä¸‹è§’æ‹–æ‹½æ‰‹æŸ„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                    let resizer = panel.querySelector(".chat-writeboard-resizer");
                    if (!resizer) {
                        resizer = document.createElement("div");
                        resizer.classList.add("chat-writeboard-resizer");
                        panel.appendChild(resizer);
                    }

                    let isResizing = false;
                    let startX, startY, startWidth, startHeight;

                    resizer.addEventListener("mousedown", e => {
                        isResizing = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        startWidth = panel.offsetWidth;
                        startHeight = panel.offsetHeight;
                        e.preventDefault();
                    });

                    window.addEventListener("mousemove", e => {
                        if (!isResizing) return;

                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;

                        let newWidth = startWidth + dx;
                        let newHeight = startHeight + dy;

                        // é™åˆ¶æœ€å°å°ºå¯¸
                        newWidth = Math.max(newWidth, 300);
                        newHeight = Math.max(newHeight, 200);

                        // æš‚å­˜ç”»å¸ƒå†…å®¹
                        const tempData = canvas.toDataURL();

                        panel.style.width = `${newWidth}px`;
                        panel.style.height = `${newHeight}px`;

                        // åŒæ­¥ canvas å°ºå¯¸
                        canvas.width = canvas.clientWidth;
                        canvas.height = canvas.clientHeight;

                        // ç™½è‰²èƒŒæ™¯
                        this.write_ctx.fillStyle = "#fff";
                        this.write_ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // ç»˜å›åŸå†…å®¹
                        if (tempData) {
                            const img = new Image();
                            img.src = tempData;
                            img.onload = () => {
                                this.write_ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            };
                        }
                    });

                    window.addEventListener("mouseup", () => {
                        isResizing = false;
                    });
                };

                // âš¡ æ›´æ–°é¼ æ ‡å…‰æ ‡ï¼ˆç”»ç¬”/æ©¡çš®ï¼‰
                this.updateCursor = () => {
                    const size = parseInt(this.e_writeboard_size.value || 4);
                    // å…‰æ ‡ç›´å¾„æ§åˆ¶åœ¨ 12~28px å†…
                    let diameter = this.write_is_eraser ? size * 2 : size * 2; 
                    diameter = Math.min(diameter, 28);
                    diameter = Math.max(diameter, 12);

                    const cursorCanvas = document.createElement("canvas");
                    cursorCanvas.width = diameter;
                    cursorCanvas.height = diameter;

                    const ctx = cursorCanvas.getContext("2d");
                    ctx.fillStyle = "#000"; // ç”»ç¬”çº¯é»‘
                    ctx.globalAlpha = this.write_is_eraser ? 0.5 : 1; // æ©¡çš®åŠé€æ˜
                    ctx.beginPath();
                    ctx.arc(diameter / 2, diameter / 2, diameter / 2, 0, Math.PI * 2);
                    ctx.fill();

                    const dataURL = cursorCanvas.toDataURL("image/png");
                    this.e_writeboard_canvas.style.cursor = `url(${dataURL}) ${diameter/2} ${diameter/2}, auto`;
                };


                // ç‚¹å‡»æŒ‰é’®æ‰“å¼€å†™å­—æ¿
                this.e_writeboard_btn.addEventListener("click", () => {

                    this.e_writeboard.classList.remove("hidden");
                    this.init_writeboard();

                    // é»˜è®¤ç”»ç¬”æ¨¡å¼
                    this.write_is_eraser = false;
                    if (this.e_writeboard_eraser) {
                        this.e_writeboard_eraser.textContent = "ğŸ§½ æ©¡çš®æ“¦";
                        this.e_writeboard_eraser.classList.remove("active");
                    }

                    // â­ ä½¿ç”¨ç»Ÿä¸€å…‰æ ‡æ›´æ–°å‡½æ•°
                    this.updateCursor();
                });


                // ç‚¹å‡»å…³é—­æŒ‰é’®éšè—å†™å­—æ¿
                this.e_writeboard_close.addEventListener("click", () => {
                    this.e_writeboard.classList.add("hidden");
                    if (this.write_ctx) {
                        this.write_ctx.clearRect(0, 0, this.e_writeboard_canvas.width, this.e_writeboard_canvas.height);
                    }
                });

                // æ¸…ç©ºæŒ‰é’®
                this.e_writeboard_clear.addEventListener("click", () => {
                    if (this.write_ctx) {
                        this.write_ctx.fillStyle = "#fff";
                        this.write_ctx.fillRect(0, 0, this.e_writeboard_canvas.width, this.e_writeboard_canvas.height);
                    }
                });




                // â­ æ©¡çš®æ“¦æŒ‰é’®
                this.e_writeboard_eraser.addEventListener("click", () => {
                    this.write_is_eraser = !this.write_is_eraser;

                    if (this.write_is_eraser) {
                        this.e_writeboard_eraser.textContent = "âœï¸ å†™å­—";
                        this.e_writeboard_eraser.classList.add("active");
                    } else {
                        this.e_writeboard_eraser.textContent = "ğŸ§½ æ©¡çš®æ“¦";
                        this.e_writeboard_eraser.classList.remove("active");
                    }

                    // â­ ä¸ç®¡æ˜¯åˆ‡æ¢ç”»ç¬”è¿˜æ˜¯æ©¡çš®ï¼Œå®æ—¶æ›´æ–°å…‰æ ‡
                    this.updateCursor();
                });





                // â­ ç¬”ç²—è°ƒèŠ‚æ»‘å—
                this.e_writeboard_size.addEventListener("input", () => {
                    if (!this.write_ctx) return;
                    const size = parseInt(this.e_writeboard_size.value);

                    if (this.write_is_eraser) {
                        this.write_ctx.lineWidth = size * 3; 
                    } else {
                        this.write_ctx.lineWidth = size;
                    }

                    // â­ æ»‘å—å˜åŒ–æ—¶ç«‹å³æ›´æ–°å…‰æ ‡
                    this.updateCursor();
                });




                // ç¡®å®šæŒ‰é’®ï¼ˆç”Ÿæˆå›¾ç‰‡å¹¶å‘é€ï¼‰
                this.e_writeboard_confirm.addEventListener("click", () => {
                    const canvas = this.e_writeboard_canvas;
                    if (!this.write_ctx) return;

                    // â­ åˆ›å»ºä¸´æ—¶ç”»å¸ƒï¼ˆå…³é”®ï¼‰
                    const exportCanvas = document.createElement("canvas");
                    exportCanvas.width = canvas.width;
                    exportCanvas.height = canvas.height;

                    const exportCtx = exportCanvas.getContext("2d");

                    // â­ å…ˆé“ºç™½åº•
                    exportCtx.fillStyle = "#fff";
                    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                    // â­ å†ç»˜åˆ¶åŸç”»å¸ƒï¼ˆé€æ˜éƒ¨åˆ†ä¼šå˜ç™½ï¼‰
                    exportCtx.drawImage(canvas, 0, 0);

                    // â­ å¯¼å‡º
                    exportCanvas.toBlob((blob) => {
                        const file = new File([blob], "handwrite.jpg", { type: "image/jpeg" });
                        this.start__send_msg_image(file);
                        this.e_writeboard.classList.add("hidden");

                        // æ¸…ç©ºåŸç”»å¸ƒ
                        this.write_ctx.fillStyle = "#fff";
                        this.write_ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }, "image/jpeg", 0.5);
                });



                setTimeout(() => {
                    check_scroll_to_end();
                }, 400);
            }

            is_group() {
                return this.li.bindmap.contact_attr.type === subviews.Chat.receiver_type.group;
            }

            current_contact_xxid() {
                return {
                    contact_type: this.li.bindmap.contact_attr.type,
                    xxid: this.is_group() ? this.li.bindmap.contact_attr.gid : this.li.bindmap.contact_attr.uid,
                    ceid: this.li.bindmap.ceid,
                }
            }

            current_contact_name() {
                const {xxid, contact_type, ceid} = this.current_contact_xxid();
                return xxid;
            }

            refresh() {
                // const {xxid, contact_type, ceid} = this.current_contact_xxid(); // ä¸fetch_unread_msgsé‡å¤äº†
                // checkin.subviews.chat.sync_one(contact_type, xxid, ceid,)
                //     .then(result => {
                //         // if (this.closed) return;
                //         this.client.dashboard_chat.wrapper.update_contact_item_status(result);
                //     }).catch(error => {
                //     // if (this.closed) return;
                //     MessageMark.report(error);
                // });
            }

            check_scroll_position_to_load(event) {
                if (this.closed) return;
                if (this.e_msgflow.scrollTop === 0) {
                    clearTimeout(this.e_msgflow__load_history_timer);
                    this.e_msgflow__load_history_timer = setTimeout(() => {
                        if (this.e_msgflow.scrollTop > 10) return;
                        this.start__load_history();
                    }, 200);
                }
                if (this.e_msgflow__checknew_timer__enabled) {
                    const current_time = Date.now();
                    if (current_time - this.e_msgflow__checknew_timer__last_emit_time < 4000) return;
                    if (this.e_msgflow.scrollTop + this.e_msgflow.clientHeight >= this.e_msgflow.scrollHeight) {
                        this.e_msgflow__checknew_timer__last_emit_time = current_time;
                        clearTimeout(this.e_msgflow__checknew_timer);
                        this.e_msgflow__checknew_timer = setTimeout(() => {
                            const distanceToBottom = this.e_msgflow.scrollHeight - this.e_msgflow.scrollTop - this.e_msgflow.clientHeight;
                            if (distanceToBottom > 10) return;
                            this.start_timer__fetch_unread_msgs();
                        }, 200);
                    }
                }
            }


            /*
            * å®šæœŸè·å–æ–°æ¶ˆæ¯
            * */
            start_timer__fetch_unread_msgs(is_background = true) {
                if (!is_background) {
                    this.remove_loading_mark();
                    this.loading_mark.show();
                    if (this.is_processing__fetch_unread_msgs) return;
                } else {
                    if (this.is_processing__fetch_unread_msgs) return;
                }
                this.stop_timer__fetch_unread_msgs();
                this.fetch_unread_msgs(is_background);
            }

            stop_timer__fetch_unread_msgs() {
                if (this.timer__fetch_unread_msgs !== null) clearTimeout(this.timer__fetch_unread_msgs);
                this.timer__fetch_unread_msgs = null;
            }

            fetch_unread_msgs(is_background = true) {
                if (!this.client.dashboard_chat.wrapper.is_active()) return;

                this.is_processing__fetch_unread_msgs = true;
                this.change_loading_status__checknew();

                const last_msgattr = this.li.bindmap.msgs.length > 0 ? this.li.bindmap.msgs.at(-1) : null;

                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    this.is_processing__fetch_unread_msgs = false;
                    this.change_loading_status__checknew();
                    this.remove_loading_mark();
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    this.stop_timer__fetch_unread_msgs();
                    this.handle_response__fetch_unread_msgs(last_msgattr, result, is_background);
                    this.client.dashboard_chat.wrapper._update_contact_item_status(this.li.bindmap, this.li.bindmap.status_attr, true);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    this.is_processing__fetch_unread_msgs = false;
                    this.change_loading_status__checknew();
                    this.remove_loading_mark();
                    if (error.auto_retry) {
                        this.stop_timer__fetch_unread_msgs();
                        if (this.closed) return;
                        if (this.client.dashboard_chat.wrapper.is_active()) this.fetch_unread_msgs();
                    } else {
                        MessageMark.report(error, null, () => {
                            this.stop_timer__fetch_unread_msgs();
                            if (this.closed) return;
                            if (this.client.dashboard_chat.wrapper.is_active()) this.fetch_unread_msgs();
                        });
                    }
                };
                const ws_isopen = this.panel.wrapper.ws_isopen();
                checkin.subviews.chat.load(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, last_msgattr,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });

            }

            async handle_response__fetch_unread_msgs(last_msgattr, result, is_background = true) {
                if (!this.client.dashboard_chat.wrapper.is_active()) return;

                if (result.is_found_last_message) { // æŒ‰è¯·æ±‚çš„èµ·å§‹æ¶ˆæ¯
                    if (result.previous_message_id !== last_msgattr.id) {
                        console.warn(`previous_message_idä¸åŒ¹é…ï¼Œlast_msgattr.id=${last_msgattr.id}ï¼Œresult=${JSON.stringify(result)}`);
                    } else {
                        const new_msgattrs = this.msgflow_manage.store_msgs(last_msgattr, result.messages);
                        if (new_msgattrs.length > 0) {
                            const msg = new_msgattrs.find(i => i.sender !== logged_user.uid);
                            if (msg) {
                                msg.msgobj.highlight();
                                if (!is_background) msg.msgobj.scroll_to_view(true);
                            }
                        }
                    }
                } else if (result.is_found_read_message && !result.is_no_more_unread) { // æŒ‰å·²è¯»è¿›åº¦
                    this.msgflow_manage.clear_msgs();
                    const new_msgattrs = this.msgflow_manage.store_msgs(null, result.messages);
                    if (new_msgattrs.length > 0) {
                        const msg = new_msgattrs.find(i => {
                            if (result.sync.read_message_id !== null) { // å› å¦‚æœæœªè¯»æ¶ˆæ¯å¤ªå°‘ï¼Œä¼šè‡ªåŠ¨å¡«å……ç‚¹å†å²
                                return i.sender !== logged_user.uid && i.id > result.sync.read_message_id;
                            } else {
                                return i.sender !== logged_user.uid;
                            }
                        });
                        if (msg) {
                            msg.msgobj.highlight();
                            msg.msgobj.scroll_to_view(true);
                        }
                    }
                } else if (result.is_found_read_message && result.is_no_more_unread) { // æŒ‰å·²è¯»è¿›åº¦ï¼Œæœ¬åœ°æ²¡æœ‰ç¼“å­˜æ—¶ï¼Œç®—æ˜¯åŠ è½½å†å²å§
                    this.msgflow_manage.clear_msgs();
                    const new_msgattrs = this.msgflow_manage.store_msgs(null, result.messages);
                    if (new_msgattrs.length > 0) {
                        const msg = new_msgattrs.at(-1);
                        if (msg) {
                            msg.msgobj.highlight();
                            msg.msgobj.scroll_to_view(false);
                        }
                    }
                } else { // å·²è¯»è®°å½•éƒ½æ²¡æœ‰
                    this.msgflow_manage.clear_msgs();
                    const new_msgattrs = this.msgflow_manage.store_msgs(null, result.messages);
                    if (new_msgattrs.length > 0) {
                        const msg = new_msgattrs.find(i => i.sender !== logged_user.uid);
                        if (msg) {
                            msg.msgobj.highlight();
                            msg.msgobj.scroll_to_view(true);
                        }
                    }
                }

                this.stop_timer__fetch_unread_msgs();
                if (this.closed) return;
                if (this.client.dashboard_chat.wrapper.is_active()) this.timer__fetch_unread_msgs = setTimeout(() => {
                    this.fetch_unread_msgs()
                }, this.panel.wrapper.ws_isopen() ? this.interval__fetch_unread_msgs__ws : this.interval__fetch_unread_msgs);

                this.e_msgflow__checknew_timer__enabled = true;
            }

            /*
            * æ›´æ–°å·²è¯»è¿›åº¦
            * */
            start_timer__update_read_progress(is_background = true) {
                this.stop_timer__update_read_progress();
                this.update_read_progress(is_background);
            }

            stop_timer__update_read_progress() {
                if (this.timer__update_read_progress !== null) clearTimeout(this.timer__update_read_progress);
                this.timer__update_read_progress = null;
            }

            update_read_progress(is_background = true) {
                if (!this.client.dashboard_chat.wrapper.is_active()) return;

                const lastVisible = findLastVisibleElement(this.e_msgflow, this.li.bindmap.msgs.filter(i => !form_field_checker.ffc_int(this.li.bindmap.status_attr.read_message_id) || i.id > this.li.bindmap.status_attr.read_message_id).map(i => i.msgobj.e_container));
                if (!lastVisible) {
                    this.stop_timer__update_read_progress();
                    if (this.closed) return;
                    if (this.client.dashboard_chat.wrapper.is_active()) this.timer__update_read_progress = setTimeout(() => {
                        this.update_read_progress()
                    }, this.interval__update_read_progress);

                    this.check_and_auto_mark_as_read();

                    return;
                }
                const visible_msgattr = lastVisible.msgobj.msgattr;

                this.check_and_auto_mark_as_read();

                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    this.stop_timer__update_read_progress();
                    this.handle_response__update_read_progress(visible_msgattr, result, is_background);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    if (error.auto_retry) {
                        this.stop_timer__update_read_progress();
                        if (this.closed) return;
                        if (this.client.dashboard_chat.wrapper.is_active()) this.update_read_progress();
                    } else {
                        MessageMark.report(error, null, () => {
                            this.stop_timer__update_read_progress();
                            if (this.closed) return;
                            if (this.client.dashboard_chat.wrapper.is_active()) this.update_read_progress();
                        });
                    }
                };
                const ws_isopen = false;
                checkin.subviews.chat.read(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, visible_msgattr,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

            async handle_response__update_read_progress(visible_msgattr, result, is_background = true) {
                if (!this.client.dashboard_chat.wrapper.is_active()) return;

                this.stop_timer__update_read_progress();
                if (this.closed) return;
                if (this.client.dashboard_chat.wrapper.is_active()) this.timer__update_read_progress = setTimeout(() => {
                    this.update_read_progress()
                }, this.interval__update_read_progress);
            }


            /*
            * å‘é€æ¶ˆæ¯
            * */
            send_msg_text() {
                const text = this.e_inputarea_textarea.value;
                if (text.length === 0) return;
                this.e_inputarea_textarea.value = "";
                this.save_draft_text();

                if (this.is_editing_msg) {
                    if (text !== this.editing_msg.plain_data_text) {
                        this._edit_msg(this.editing_msg, text);
                    }
                    this.end_editing_msg();
                } else {
                    const msg = {
                        sender: logged_user.uid,
                        sender_rand: generateRandomString(10),
                        is_sent: false,

                        type: dashboardwrappers.ChatDashboardWrapper.message_type.text,

                        plain_text: text,
                        topic: this.e_topic_select ? this.e_topic_select.value : '',
                    }

                    console.log("å‘é€æ¶ˆæ¯ï¼Œè¯é¢˜:", msg.topic, "ä¸‹æ‹‰æ¡†:", this.e_topic_select);

                    // å°†è¯é¢˜æ·»åŠ åˆ°åˆ—è¡¨ä¸­
                    if (msg.topic && !this.current_topics.includes(msg.topic)) {
                        this.current_topics.push(msg.topic);
                        this.refresh_topic_list();
                    }

                    this.msgflow_manage.append_sending_msg(msg);
                    this._send_msg_text(msg);
                }
            }

            _send_msg_text(msg) {
                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    this.msgflow_manage.update_sending_msg(msg.sender_rand, result.message_attr, result.previous_message_id);
                };
                const onfetcherror = (error) => {
                    msg.msgobj.on_send_failed(error);
                    // if (this.closed) return;
                    // MessageMark.report(error);
                };
                const ws_isopen = false;
                const topic = msg.topic || '';
                checkin.subviews.chat.send_text(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, msg.sender_rand, msg.plain_text, topic)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

            resend_msg(msgobj) {
                // console.log("é‡æ–°å‘é€", msgobj);
                msgobj.on_resend_started();
                if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(msgobj.msgattr.type)) {
                    this._send_msg_text(msgobj.msgattr);
                } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(msgobj.msgattr.type)) {
                    floatball.dialog.retryToStartTask(msgobj.msgattr.upload_task);
                }
            }

            start__send_msg_image(file) {
                let name = normalizeName(file.name);
                if (!name) return;

                const img = new Image();
                const url = URL.createObjectURL(file);
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    const d = {
                        file_name: name,
                        image_attr: {
                            width: img.width,
                            height: img.height,
                        }
                    }
                    this.send_msg_file(file, dashboardwrappers.ChatDashboardWrapper.message_type.image, d);
                };
                img.onerror = () => {
                    MessageMark.report("é€‰æ‹©çš„å›¾ç‰‡æ— æ•ˆã€‚");
                };
                img.src = url;

            }

            start__send_msg_file(file) {
                let name = normalizeName(file.name);
                if (!name) return;
                // for (let disallowedUploadElement of disallowed_upload) {
                //     if (name.endsWith(disallowedUploadElement)) {
                //         MessageMark.report(`ä¸å…è®¸ä¸Šä¼ ï¼š${disallowedUploadElement}`);
                //         return;
                //     }
                // }
                const d = {
                    file_name: name,
                    file_attr: {
                        name: "å‘é€ç”¨ä¸ä¸Š",
                        size: file.size,
                    },
                }
                this.send_msg_file(file, dashboardwrappers.ChatDashboardWrapper.message_type.file, d);
            }

            send_msg_file(file, type, attach_attrs) {

                const msg = {
                    sender: logged_user.uid,
                    sender_rand: generateRandomString(10),
                    is_sent: false,

                    type: type,

                    file: file,
                    ...attach_attrs,
                }

                this.msgflow_manage.append_sending_msg(msg);
                const task = this._send_msg_file(msg);
                // floatball.look_upload_tasks(task);
            }

            _send_msg_file(msg) {
                const t = new FloatBall.tasktypes.Upload_ChatMessage(floatball.dialog.tab_content_backtasks, {
                    onfinished: () => {
                        msg.msgobj.update();
                        // if (this.closed) return;
                        const text = new TextDecoder('utf-8').decode(t.xhr.response);
                        const result = JSON.parse(text);
                        this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                        this.msgflow_manage.update_sending_msg(msg.sender_rand, result.message_attr, result.previous_message_id);
                    },
                    onwaiting: () => {
                        msg.msgobj.update();
                    },
                    onprogress: () => {
                        msg.msgobj.update();
                    },
                    onfailed: () => {
                        msg.msgobj.update();
                        msg.msgobj.on_send_failed();
                        // if (this.closed) return;
                        // MessageMark.report(error);
                    },
                });

                msg.upload_task = t;

                floatball.dialog.addTask(t);
                t.set_name(normalizeName(msg.file.name));
                t.set_args({
                    msg,
                    ...this.current_contact_xxid(),
                });

                floatball.dialog.checkToStartTask();
                floatball.dialog.checkToHide(t);

                return t;
            }

            edit_msg(msgattr) {
                this.save_draft_text();
                this.is_editing_msg = true;
                this.editing_msg = msgattr;
                this.e_inputarea_tip_editing.classList.remove("hidden");
                this.e_inputarea_textarea.placeholder = "";
                this.e_inputarea_textarea.value = msgattr.plain_data_text;
                this.e_inputarea_textarea.focus();
            }

            end_editing_msg() {
                this.is_editing_msg = false;
                this.editing_msg = null;
                this.e_inputarea_tip_editing.classList.add("hidden");
                this.e_inputarea_textarea.placeholder = "è¾“å…¥æ¶ˆæ¯å,ç‚¹å‡»å‘é€æˆ–å›è½¦...";
                this.load_draft_text();
            }

            _edit_msg(msgattr, new_text) {
                msgattr.msgobj.blur_content();

                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    if (result.sync.editions.length === 1 && result.sync.editions[0] === result.message_attr.id) {
                        result.sync.editions.splice(0, 1); // è‡ªå·±ç¼–è¾‘åå…äº†å†æ¬¡åŒæ­¥
                        // console.log("å…äº†é‡å¤åŒæ­¥äºŒç¼–æ¶ˆæ¯", result.sync.edition_id, result.sync.editions);
                    }
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    this.msgflow_manage.update_msg(msgattr, result.message_attr,);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    MessageMark.report(error);
                    msgattr.msgobj.unblur_content();
                };
                const ws_isopen = false;
                checkin.subviews.chat.edit_text(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, msgattr.id, new_text,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

            revoke_msg(msgattr) {
                msgattr.msgobj.blur_content();

                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    if (result.sync.editions.length === 1 && result.sync.editions[0] === result.message_attr.id) {
                        result.sync.editions.splice(0, 1);
                    }
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    this.msgflow_manage.update_msg(msgattr, result.message_attr,);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    MessageMark.report(error);
                    msgattr.msgobj.unblur_content();
                };
                const ws_isopen = false;
                checkin.subviews.chat.revoke_message(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, msgattr.id,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

            init_batch_action_bar() {
                this.e_batch_select_all.addEventListener("change", (event) => {
                    this.batch_select_all(event.target.checked);
                });

                this.e_batch_btn_select_inverse.addEventListener("click", (event) => {
                    this.batch_select_inverse();
                });

                this.e_batch_btn_delete.addEventListener("click", (event) => {
                    this.batch_delete_selected();
                });

                this.e_batch_btn_cancel.addEventListener("click", (event) => {
                    this.exit_batch_mode();
                });
            }

            // ğŸ”¥ è¯é¢˜ç­›é€‰åŠŸèƒ½
            update_topic_filter_visibility() {
                if (this.is_group() && this.current_topics.length > 1) {
                    this.e_topic_filter_bar.classList.remove("hidden");
                } else {
                    this.e_topic_filter_bar.classList.add("hidden");
                }
            }

            refresh_topic_filter_list() {
                if (!this.e_topic_filter_select) return;
                const currentVal = this.e_topic_filter_select.value;
                this.e_topic_filter_select.innerHTML = '';
                
                // æ·»åŠ "å…¨éƒ¨æ¶ˆæ¯"é€‰é¡¹
                const allOpt = document.createElement('option');
                allOpt.value = '';
                allOpt.textContent = 'ğŸ“‹ å…¨éƒ¨æ¶ˆæ¯';
                this.e_topic_filter_select.appendChild(allOpt);
                
                // æ·»åŠ å„è¯é¢˜é€‰é¡¹
                this.current_topics.forEach(topic => {
                    const opt = document.createElement('option');
                    opt.value = topic;
                    opt.textContent = topic ? '# ' + topic : 'ğŸ“ é—²èŠ';
                    this.e_topic_filter_select.appendChild(opt);
                });
                
                // æ¢å¤é€‰ä¸­å€¼
                if (this.current_topics.includes(currentVal)) {
                    this.e_topic_filter_select.value = currentVal;
                }
            }

            filter_by_topic(topic) {
                this.current_topic_filter = topic;
                if (this.e_topic_filter_select) {
                    this.e_topic_filter_select.value = topic;
                }
                this.apply_topic_filter();
            }

            apply_topic_filter() {
                const messages = this.e_msgflow.querySelectorAll(".chat-message");
                messages.forEach(msgEl => {
                    const topicEl = msgEl.querySelector(".chat-message-topic");
                    const msgTopic = topicEl ? topicEl.textContent.replace('# ', '').trim() : '';
                    
                    if (!this.current_topic_filter || msgTopic === this.current_topic_filter) {
                        msgEl.classList.remove("hidden");
                    } else {
                        msgEl.classList.add("hidden");
                    }
                });
            }

            enter_batch_mode() {
                this.e_batch_action_bar.classList.add("show");
                this.chat_rect.classList.add("chat-batch-mode");
                this.e_header_actions.classList.add("hidden");
            }

            exit_batch_mode() {
                this.e_batch_action_bar.classList.remove("show");
                this.chat_rect.classList.remove("chat-batch-mode");
                this.e_header_actions.classList.remove("hidden");
                this.e_batch_select_all.checked = false;
                this.e_batch_count.textContent = "å·²é€‰0æ¡";
                const checkboxes = this.e_msgflow.querySelectorAll(".chat-message-checkbox input");
                checkboxes.forEach(cb => {
                    cb.checked = false;
                });
            }

            batch_select_all(select) {
                const checkboxes = this.e_msgflow.querySelectorAll(".chat-message-checkbox input:not(:disabled)");
                checkboxes.forEach(cb => {
                    cb.checked = select;
                });
                this.update_batch_count();
            }

            batch_select_inverse() {
                const checkboxes = this.e_msgflow.querySelectorAll(".chat-message-checkbox input:not(:disabled)");
                checkboxes.forEach(cb => {
                    cb.checked = !cb.checked;
                });
                this.update_batch_count();
            }

            update_batch_count() {
                const checkboxes = this.e_msgflow.querySelectorAll(".chat-message-checkbox input:checked");
                this.e_batch_count.textContent = `å·²é€‰${checkboxes.length}æ¡`;
                this.e_batch_select_all.checked = checkboxes.length > 0 && this.e_msgflow.querySelectorAll(".chat-message-checkbox input:not(:disabled)").length === checkboxes.length;
            }

            batch_delete_selected() {
                const checkboxes = this.e_msgflow.querySelectorAll(".chat-message-checkbox input:checked");
                const message_ids = [];
                checkboxes.forEach(cb => {
                    const msgattr = cb.closest(".chat-message-content-container")?.bindmap;
                    if (msgattr && msgattr.id) {
                        message_ids.push(msgattr.id);
                    }
                });

                if (message_ids.length === 0) {
                    MessageMark.report(new Error("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ¶ˆæ¯"));
                    return;
                }

                const is_admin = logged_user && (logged_user.contact_any == 1 || logged_user.contact_any === true);
                const tip = is_admin 
                    ? `ç¡®å®šåˆ é™¤é€‰ä¸­çš„${message_ids.length}æ¡æ¶ˆæ¯å—ï¼Ÿ`
                    : `ç¡®å®šåˆ é™¤é€‰ä¸­çš„${message_ids.length}æ¡æ¶ˆæ¯å—ï¼Ÿï¼ˆéç®¡ç†å‘˜åªèƒ½åˆ é™¤è‡ªå·±çš„æ¶ˆæ¯ï¼‰`;

                MessageMark.confirm(tip, null, null, () => {
                    this.do_batch_delete(message_ids);
                });
            }

            do_batch_delete(message_ids) {
                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    this.exit_batch_mode();
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    for (const msgid of message_ids) {
                        const msgattr = this.li.bindmap.msgs.find(m => m.id === msgid);
                        if (msgattr) {
                            const new_message_attr = {...msgattr};
                            new_message_attr.type = dashboardwrappers.ChatDashboardWrapper.message_type.sys;
                            new_message_attr.status = msgattr.status | dashboardwrappers.ChatDashboardWrapper.message_status.revoked;
                            new_message_attr.sys_attr = {
                                type: dashboardwrappers.ChatDashboardWrapper.data_spec_action_type.revoke_message,
                                a1_uid: logged_user.uid,
                                a3_number: 0,
                                a4_number: 0,
                            };
                            this.msgflow_manage.update_msg(msgattr, new_message_attr);
                        }
                    }
                    this.client.dashboard_chat.wrapper.sync();
                };
                const onfetcherror = (error) => {
                    MessageMark.report(error);
                };

                const ws_isopen = false;
                checkin.subviews.chat.batch_revoke(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, message_ids)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

            get_selectable_messages() {
                const is_admin = logged_user && (logged_user.contact_any == 1 || logged_user.contact_any === true);
                const selectable = [];
                for (const msgattr of this.li.bindmap.msgs) {
                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_sys(msgattr.type)) {
                        continue;
                    }
                    if (is_admin || msgattr.sender === logged_user.uid) {
                        selectable.push(msgattr);
                    }
                }
                return selectable;
            }

            /*
            * æ ‡è®°å·²è¯»
            * */
            mark_as_read(msgattr) {
                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;

                    if (result.sync.editions.length === 1 && result.message_attrs.length === 1 && result.sync.editions[0] === result.message_attrs[0].id) {
                        result.sync.editions.splice(0, 1);
                    }
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    if (result.message_attrs.length > 0) this.msgflow_manage.update_msg(msgattr, result.message_attrs[0],);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    MessageMark.report(error);
                };
                const ws_isopen = false;
                checkin.subviews.chat.mark_read(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, [msgattr.id,],)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

            check_and_auto_mark_as_read() {
                const msgattrs = this.li.bindmap.msgs.filter(i => {
                    if (i.status & dashboardwrappers.ChatDashboardWrapper.message_status.i_read) return false;
                    if (i.msgobj.at_attr.is_marking) return false;
                    if (i.msgobj.is_sys_msg()) return false;
                    if (this.is_group()) {
                        stopTitleFlash();
                        return (i.msgobj.at_attr.at_all && i.sender !== logged_user.uid) || i.msgobj.at_attr.at_users.includes(logged_user.uid);
                    } else {
                        stopTitleFlash();
                        return i.sender !== logged_user.uid;
                    }
                });
                const e_containers = msgattrs.map(i => i.msgobj.e_container);
                const unread_msgobjs = [];
                for (const eContainer of e_containers) {
                    if (checkIfElementVisible(this.e_msgflow, eContainer)) unread_msgobjs.push(eContainer.msgobj);
                }
                // console.log("éœ€è¦æ ‡è®°å·²è¯»çš„æ¶ˆæ¯", unread_msgobjs);
                if (unread_msgobjs.length === 0) return;
                const unreadIds = [];
                for (const unreadMsgobj of unread_msgobjs) {
                    unreadMsgobj.at_attr.is_marking = true;
                    const msgattr = unreadMsgobj.msgattr;
                    unreadIds.push(msgattr.id);
                }
                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;

                    if (result.sync.editions.length === result.message_attrs.length) {
                        let is_same = true;
                        for (let i = 0; i < result.sync.editions.length; i++) {
                            if (i !== result.message_attrs.findIndex(j => j.id === result.sync.editions[i])) {
                                is_same = false;
                                break;
                            }
                        }
                        if (is_same) result.sync.editions.splice(0, result.sync.editions.length);
                    }
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    for (const message_attr of result.message_attrs) this.msgflow_manage.update_msg(unread_msgobjs.find(i => i.msgattr.id === message_attr.id).msgattr, message_attr,);

                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    if (error.auto_retry) {
                        for (const unreadMsgobj of unread_msgobjs) unreadMsgobj.at_attr.is_marking = false;
                    } else {
                        MessageMark.report(error, null, () => {
                            for (const unreadMsgobj of unread_msgobjs) unreadMsgobj.at_attr.is_marking = false;
                        });
                    }

                };
                const ws_isopen = false;
                checkin.subviews.chat.mark_read(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, unreadIds,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }


            /*
            * è½¬å‘æ¶ˆæ¯
            * */

			forward_msg(msgattr) {
				let form = [
					{ type: "title", label: "è½¬å‘ç»™ï¼š" },
					{
						type: "custom",
						label: "",
						add_element: (fm, row_custom) => {
						    row_custom.subs = [];

						    /* ========= å…¨é€‰ï¼šè½¬å‘ç»™æ‰€æœ‰äºº ========= */
						    const allHtml = `
								<div class="fmic-forward-all-wrap">
									<label class="fmic-forward-all">
										<input type="checkbox" class="forward-select-all">
										<span class="fmic-forward-all-text">
											ğŸš€ è½¬å‘ç»™æ‰€æœ‰äºº
										</span>
									</label>
									<div class="fmic-forward-all-desc">
										å°†æ¶ˆæ¯å‘é€ç»™å½“å‰å¯é€‰çš„å…¨éƒ¨è”ç³»äºº
									</div>
								</div>
							`;

						    row_custom.input_element.insertAdjacentHTML("beforeend", allHtml);

						    const selectAllCheckbox =
						        row_custom.input_element.querySelector(".forward-select-all");

						    /* ========= æ™®é€šè”ç³»äºº ========= */
						    for (const mainaction of this.panel.wrapper.contact_items()) {
						        if (mainaction === this.li.bindmap) continue;

						        let text;
						        if (dashboardwrappers.ChatDashboardWrapper.is_group(mainaction.contact_attr)) {
						            text = `ç»„ï¼š${dashboardwrappers.ChatDashboardWrapper.get_contact_xxid(mainaction.contact_attr)}`;
						        } else {
						            text = `${dashboardwrappers.ChatDashboardWrapper.get_contact_xxid(mainaction.contact_attr)}`;
						        }

						        const html = `
						            <div class="fmic-item fmic-item-forwardmsgto">
						                <label><input type="checkbox">${text}</label>
						            </div>
						        `;
						        row_custom.input_element.insertAdjacentHTML("beforeend", html);

						        const column =
						            row_custom.input_element.querySelector(":scope > .fmic-item:last-of-type");
						        const checkbox = column.querySelector("input");

						        row_custom.subs.push({
						            mainaction,
						            column,
						            checkbox,
						        });
						    }

						    /* ========= å…¨é€‰ â†’ å­é€‰é¡¹ ========= */
						    selectAllCheckbox.addEventListener("change", () => {
						        const checked = selectAllCheckbox.checked;
						        for (const sub of row_custom.subs) {
						            sub.checkbox.checked = checked;
						        }
						    });

						    /* ========= å­é€‰é¡¹ â†’ å…¨é€‰ ========= */
						    for (const sub of row_custom.subs) {
						        sub.checkbox.addEventListener("change", () => {
						            selectAllCheckbox.checked =
						                row_custom.subs.length > 0 &&
						                row_custom.subs.every(s => s.checkbox.checked);
						        });
						    }
						},

						collect_data: (fm, row_custom) => {
						    const map = [];
						    for (const sub of row_custom.subs) {
						        if (!sub.checkbox.checked) continue;
						        map.push(sub.mainaction);
						    }
						    row_custom.value = map;
						},
					},
				];

				const confirm_callback = (fm) => {
					fm.collect_data();
					try {
						const mainactions = form[1].value;
						if (mainactions.length === 0) {
						    fm.remove();
						} else {
						    this._forward_msg(fm, msgattr, mainactions);
						}
					} catch (e) {
						MessageMark.report(e, fm.rect);
					}
				};

				FormMark.get_global_input(form, confirm_callback);
			}

			/*
			* çœŸæ­£æ‰§è¡Œè½¬å‘
			* */
			_forward_msg(fm, msgattr, mainactions) {
				const { xxid, contact_type, ceid } = this.current_contact_xxid();

				const to = [];
				mainactions.forEach(i => {
					if (i.contact_attr.type === subviews.Chat.receiver_type.group) {
						to.push({ type: i.contact_attr.type, gid: i.contact_attr.gid });
					} else {
						to.push({ type: i.contact_attr.type, uid: i.contact_attr.uid });
					}
				});

				fm.loading_mark = new LoadingMark(fm.rect);
				fm.loading_mark.show();

				const onfetchload = (result) => {
					this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
					if (this.closed) return;
					fm.loading_mark.remove();
					fm.remove();
				};

				const onfetcherror = (error) => {
					if (this.closed) return;
					fm.loading_mark.remove();
					MessageMark.report(error, fm.rect);
				};

				const ws_isopen = false;

				checkin.subviews.chat.forward(
					ws_isopen ? (args) => {
						this.panel.wrapper.ws_send(args.body, { onfetchload, onfetcherror });
					} : null,
					contact_type,
					xxid,
					ceid,
					msgattr.id,
					to
				)
				.then(result => {
					if (!ws_isopen) onfetchload(result);
				})
				.catch(error => {
					onfetcherror(error);
				});
			}



            /*
            * ç®¡ç†ç¼“å­˜çš„æ¶ˆæ¯å’Œæ¸²æŸ“
            * */
            msgflow_manage = { // this=contentpage

                load_sending_msgs: () => {
                    // const msgseniors = [...this.li.bindmap.sending_msgs].reverse();
                    // msgseniors.forEach(msgattr => {
                    //     if (msgattr.msgobj) this.msgflow_manage.remove_element(msgattr);
                    // });
                    // const msgs = [...this.li.bindmap.sending_msgs];
                    // this.li.bindmap.sending_msgs.length = 0;
                    // for (const sendingMsg of msgs) {
                    //     this.msgflow_manage.append_sending_msg(sendingMsg);
                    // }
                    for (const sendingMsg of this.li.bindmap.sending_msgs) {
                        sendingMsg.msgobj.contentpage = this;
                        if (sendingMsg.msgobj.is_header()) {
                            this.e_msgflow.append(sendingMsg.msgobj.msgelement);
                        }
                    }
                    for (const msgattr of this.li.bindmap.sending_msgs) msgattr.msgobj.update();

                    if (this.li.bindmap.sending_msgs.length > 0) {
                        this.li.bindmap.sending_msgs.at(-1).msgobj.scroll_to_view(false);
                    }
                },

                append_sending_msg: (msgattr) => {
                    const msgseniors = [...this.li.bindmap.sending_msgs].reverse();
                    this.li.bindmap.sending_msgs.push(msgattr);
                    this.panel.wrapper.msgflow_manage.add_element(this, msgattr, msgseniors);

                    this.e_msgflow__checknew_timer__last_emit_time = Date.now();

                    msgattr.msgobj.scroll_to_view(true);
                },

                update_sending_msg: (sender_rand, message_attr, previous_message_id) => {
                    message_attr.is_sent = true;
                    for (let i = 0; i < this.li.bindmap.sending_msgs.length; i++) {
                        const sendingMsg = this.li.bindmap.sending_msgs[i];
                        if (sendingMsg.sender_rand === sender_rand) {
                            if (this.li.bindmap.msgs.length === 0 && !form_field_checker.ffc_int(previous_message_id)) { // ç¾¤é‡Œçš„é¦–æ¡æ¶ˆæ¯
                                this.li.bindmap.sending_msgs.splice(i, 1);
                                Object.assign(sendingMsg, message_attr);
                                this.msgflow_manage.append_msg(sendingMsg);
                            } else if (this.li.bindmap.msgs.length > 0 && form_field_checker.ffc_int(previous_message_id) && this.li.bindmap.msgs.at(-1).id === previous_message_id) { // å¯ä»¥ç›´æ¥è¿½åŠ 
                                this.li.bindmap.sending_msgs.splice(i, 1);
                                Object.assign(sendingMsg, message_attr);
                                this.msgflow_manage.append_msg(sendingMsg);
                            } else { // flowä¸å®Œæ•´
                                this.start_timer__fetch_unread_msgs(false);
                            }
                            return;
                        }
                    }
                },

                load_msgs: () => {
                    for (const sendingMsg of this.li.bindmap.msgs) {
                        sendingMsg.msgobj.contentpage = this;
                        if (sendingMsg.msgobj.is_header()) {
                            this.e_msgflow.append(sendingMsg.msgobj.msgelement);
                        }
                    }
                    for (const msgattr of this.li.bindmap.msgs) msgattr.msgobj.update();

                    if (this.li.bindmap.msgs.length > 0) {
                        if (this.li.bindmap.status_attr.read_message_id !== null) { // å¯èƒ½æœ‰æœªè¯»
                            const first_unread_msg = this.li.bindmap.msgs.find(i => i.id > this.li.bindmap.status_attr.read_message_id);
                            if (first_unread_msg) {
                                first_unread_msg.msgobj.highlight();
                                first_unread_msg.msgobj.scroll_to_view(false);
                            } else {
                                this.li.bindmap.msgs.at(-1).msgobj.scroll_to_view(false);
                            }
                        } else {
                            this.li.bindmap.msgs.at(-1).msgobj.scroll_to_view(false);
                        }
                    }
                },

                append_msg: (msgattr) => {
                    let sent_one = false;
                    if (msgattr.msgobj) { // å‘é€åè¿½åŠ çš„
                        this.msgflow_manage.remove_element(msgattr);
                        sent_one = true;
                    }
                    const msgseniors = [...this.li.bindmap.msgs].reverse();
                    this.li.bindmap.msgs.push(msgattr);
                    this.panel.wrapper.msgflow_manage.add_element(this, msgattr, msgseniors);

                    if (sent_one) {
                        msgattr.msgobj.scroll_to_view(true);
                    }
                },

                update_msg: (msgattr, new_message_attr) => {
                    return this.panel.wrapper.msgflow_manage.update_msg(this, msgattr, new_message_attr);
                },

                insert_history_msgs: (next_msgattr, msgattrs) => {
                    const msgs = [];
                    for (const msgattr of msgattrs) {
                        const msgseniors = [...msgs].reverse();
                        msgs.push(msgattr);
                        this.panel.wrapper.msgflow_manage.add_element(this, msgattr, msgseniors, true);
                    }
                    const histories = [...msgs];

                    if (msgattrs.length === 0) return histories; // æ²¡æœ‰éœ€è¦æ’å…¥çš„å†å²

                    if (next_msgattr.msgobj.is_header()) {
                        next_msgattr.msgobj.remove_from_flow();
                        for (const msgattr of [next_msgattr, ...next_msgattr.msgobj.msgobjchildren.map(i => i.msgattr)]) {
                            const msgseniors = [...msgs].reverse();
                            msgs.push(msgattr);
                            this.panel.wrapper.msgflow_manage.add_element(this, msgattr, msgseniors, true);
                        }
                    } else {
                        const msgseniors = [...msgs].reverse();
                        msgs.push(next_msgattr);
                        this.panel.wrapper.msgflow_manage.add_element(this, next_msgattr, msgseniors, true);
                    }

                    this.li.bindmap.msgs.unshift(...histories);

                    this.e_msgflow.prepend(...msgs.filter(i => i.msgobj.is_header()).map(i => i.msgobj.msgelement));

                    return histories;
                },

                store_msgs: (last_msgattr, new_messages) => {
                    new_messages.forEach(i => {
                        i.is_sent = true;
                    });

                    let found_previous_msg;
                    let found_previous_msg_index;
                    if (last_msgattr) {
                        for (let i = 0; i < this.li.bindmap.msgs.length; i++) {
                            const msg = this.li.bindmap.msgs[i];
                            if (msg.id === last_msgattr.id) {
                                found_previous_msg = msg;
                                found_previous_msg_index = i;
                                break;
                            }
                        }
                    }
                    const new_msgattrs = [];
                    if (found_previous_msg) { // å‰ä¸€æ¡æ¶ˆæ¯è¢«ç¼“å­˜è¿‡ï¼Œæ£€æŸ¥åœ¨åˆé€‚çš„ä½ç½®æ’å…¥æˆ–æ›´æ–°ç°æœ‰
                        const back_count = this.li.bindmap.msgs.length - found_previous_msg_index - 1;
                        const part1 = new_messages.slice(0, back_count); // æ—©ç¼“å­˜è¿‡çš„æ¶ˆæ¯ï¼Œè¿™é‡Œæ›´æ–°ä»¥ä¸‹æ•°æ®
                        for (let i = found_previous_msg_index + 1; i < this.li.bindmap.msgs.length; i++) {
                            const msg = this.li.bindmap.msgs[i];
                            Object.assign(msg, part1[i - found_previous_msg_index - 1]);
                            msg.msgobj.update();
                        }
                        const part2 = new_messages.slice(back_count); // æœ«å°¾æœªç¼“å­˜è¿‡çš„æ¶ˆæ¯
                        for (const newMessage of part2) {
                            if (newMessage.sender_rand) {
                                let sending_msg;
                                for (let i = 0; i < this.li.bindmap.sending_msgs.length; i++) {
                                    const sendingMsg = this.li.bindmap.sending_msgs[i];
                                    if (sendingMsg.sender_rand === newMessage.sender_rand) {
                                        this.li.bindmap.sending_msgs.splice(i, 1);
                                        Object.assign(sendingMsg, newMessage);
                                        sending_msg = sendingMsg;
                                        break;
                                    }
                                }
                                if (sending_msg) {
                                    this.msgflow_manage.append_msg(sending_msg);
                                    new_msgattrs.push(sending_msg);
                                    continue;
                                }
                            }
                            this.msgflow_manage.append_msg(newMessage);
                            new_msgattrs.push(newMessage);
                        }

                    } else { // æ²¡æœ‰å‰ä¸€æ¡æ¶ˆæ¯ï¼Œflowä¸å®Œæ•´å§
                        this.msgflow_manage.clear_msgs();
                        for (const newMessage of new_messages) {
                            if (newMessage.sender_rand) {
                                let sending_msg;
                                for (let i = 0; i < this.li.bindmap.sending_msgs.length; i++) {
                                    const sendingMsg = this.li.bindmap.sending_msgs[i];
                                    if (sendingMsg.sender_rand === newMessage.sender_rand) {
                                        this.li.bindmap.sending_msgs.splice(i, 1);
                                        Object.assign(sendingMsg, newMessage);
                                        sending_msg = sendingMsg;
                                        break;
                                    }
                                }
                                if (sending_msg) {
                                    this.msgflow_manage.append_msg(sending_msg);
                                    new_msgattrs.push(sending_msg);
                                    continue;
                                }
                            }
                            this.msgflow_manage.append_msg(newMessage);
                            new_msgattrs.push(newMessage);
                        }
                    }
                    return new_msgattrs;
                },

                insert_msgs: (first_msgattr, new_messages) => {
                    new_messages.forEach(i => {
                        i.is_sent = true;
                    });

                    let found_next_msg;
                    let found_next_msg_index;
                    if (first_msgattr) {
                        for (let i = 0; i < this.li.bindmap.msgs.length; i++) {
                            const msg = this.li.bindmap.msgs[i];
                            if (msg.id === first_msgattr.id) {
                                found_next_msg = msg;
                                found_next_msg_index = i;
                                break;
                            }
                        }
                    }
                    const new_msgattrs = [];
                    if (found_next_msg) { // åä¸€æ¡æ¶ˆæ¯è¢«ç¼“å­˜è¿‡ï¼Œæ£€æŸ¥åœ¨åˆé€‚çš„ä½ç½®æ’å…¥æˆ–æ›´æ–°ç°æœ‰
                        const face_count = found_next_msg_index;
                        const part1 = new_messages.slice(-face_count); // æ—©ç¼“å­˜è¿‡çš„æ¶ˆæ¯ï¼Œè¿™é‡Œæ›´æ–°ä»¥ä¸‹æ•°æ®
                        for (let i = found_next_msg_index - 1; i > -1; i--) {
                            const msg = this.li.bindmap.msgs[i];
                            Object.assign(msg, part1.at(-(i + 1)));
                            msg.msgobj.update();
                        }
                        const part2 = new_messages.slice(0, face_count === 0 ? undefined : -face_count); // æœ«å°¾æœªç¼“å­˜è¿‡çš„æ¶ˆæ¯
                        new_msgattrs.push(...this.msgflow_manage.insert_history_msgs(found_next_msg, part2));

                    } else { // æ²¡æœ‰åä¸€æ¡æ¶ˆæ¯ï¼Œflowä¸å®Œæ•´å§
                        this.msgflow_manage.clear_msgs();
                        for (const newMessage of new_messages) {
                            if (newMessage.sender_rand) {
                                let sending_msg;
                                for (let i = 0; i < this.li.bindmap.sending_msgs.length; i++) {
                                    const sendingMsg = this.li.bindmap.sending_msgs[i];
                                    if (sendingMsg.sender_rand === newMessage.sender_rand) {
                                        this.li.bindmap.sending_msgs.splice(i, 1);
                                        Object.assign(sendingMsg, newMessage);
                                        sending_msg = sendingMsg;
                                        break;
                                    }
                                }
                                if (sending_msg) {
                                    this.msgflow_manage.append_msg(sending_msg);
                                    new_msgattrs.push(sending_msg);
                                    continue;
                                }
                            }
                            this.msgflow_manage.append_msg(newMessage);
                            new_msgattrs.push(newMessage);
                        }
                    }
                    return new_msgattrs;
                },

                clear_msgs: () => {
                    const msgseniors = [...this.li.bindmap.msgs].reverse();
                    msgseniors.forEach(msgattr => {
                        if (msgattr.msgobj) this.msgflow_manage.remove_element(msgattr);
                    });
                    this.li.bindmap.msgs.length = 0;
                },

                remove_element: (msgattr) => {
                    if (msgattr.msgobj.is_header()) {
                        msgattr.msgobj.remove_all_children();
                        msgattr.msgobj.remove_from_flow();
                    } else {
                        msgattr.msgobj.header().remove_child(msgattr.msgobj);
                    }
                    msgattr.msgobj = null;
                },
            }

            static msgtypes = (() => {
                class _ {
                    constructor(panel, contentpage, msgattr, msgattrseniors,) {
                        this.panel = panel;
                        this.contentpage = contentpage; // æ³¨æ„å¯èƒ½ä¸ºnullç›´åˆ°ç‚¹å‡»mainactionå¡«å……msgsæ—¶ï¼Œä¾‹å¦‚åœ¨åå°åˆ›å»ºçš„msgtypeå¯¹è±¡

                        this.msgattr = msgattr;
                        this.msgattrseniors = msgattrseniors;
                        // =========================
                        // é€‰ä¸­æ¶ˆæ¯ç›¸å…³çŠ¶æ€ï¼ˆæ–°å¢ï¼‰
                        // =========================
                        this.is_selected = false;   // æ˜¯å¦è¢«é€‰ä¸­
                        this.e_actionbar = null;    // åº•éƒ¨æ“ä½œæ¡ DOM
                        if (this.is_sys_msg()) {
                            this.palette = contentpages._chat.get_message_palette(msgattr.sender, true);
                        } else {
                            this.palette = contentpages._chat.get_message_palette(msgattr.sender);
                        }

                        this.msgattrparents = [];
                        this.is_different_day = false;
                        this.#resolve_relations(msgattrseniors);

                        // this.msgobjparent = null;
                        this.msgobjchildren = [];

                        this.at_attr = {
                            at_all: false,
                            at_users: [],
                            is_marking: false,
                        };

                        // ğŸ”¥ æ”¶é›†è¯é¢˜
                        if (this.contentpage && this.msgattr.topic) {
                            const topic = this.msgattr.topic;
                            if (topic && !this.contentpage.current_topics.includes(topic)) {
                                this.contentpage.current_topics.push(topic);
                                this.contentpage.refresh_topic_list();
                                this.contentpage.refresh_topic_filter_list();
                                this.contentpage.update_topic_filter_visibility();
                            }
                        }

                        this.init();
                        this.fill_marks();
                        this.update();
                    }

                    init() {
                        const temp_parent_element = document.createElement('template');
                        let html = `<div class="chat-message"></div>`;
                        temp_parent_element.insertAdjacentHTML("beforeend", html);
                        this.msgelement = temp_parent_element.querySelector(":scope *:first-child");
                        temp_parent_element.remove();
                        this.msgelement.msgobj = this;

                        this.sent_by_me = false;
                        this.sent_by_me = this.msgattr.sender === logged_user.uid;
                        if (this.sent_by_me) {
                            this.msgelement.classList.add("sent-by-me");
                        }

                        // æ¶ˆæ¯å†…å®¹ container
                        {
                            const temp_parent_element = document.createElement('template');
                            let html = `
<div class="chat-message-content-container">
    <div class="chat-message-checkbox">
        <input type="checkbox">
    </div>
</div>
`;
                            temp_parent_element.insertAdjacentHTML("beforeend", html);
                            this.e_container = temp_parent_element.querySelector(":scope .chat-message-content-container");
                            this.e_msg_checkbox = this.e_container.querySelector(":scope .chat-message-checkbox input");
                            temp_parent_element.remove();
                            this.e_container.msgobj = this;

                            // å¤é€‰æ¡†äº‹ä»¶
                            this.e_msg_checkbox.addEventListener("click", (e) => {
                                e.stopPropagation();
                                const contentpage = this.contentpage || checkin.current_content_page;
                                if (contentpage && typeof contentpage.update_batch_count === "function") {
                                    contentpage.update_batch_count();
                                }
                            });

                            // åˆ¤æ–­æ˜¯å¦å¯é€‰ä¸­ï¼ˆç³»ç»Ÿæ¶ˆæ¯å’Œæ²¡æœ‰æƒé™çš„æ¶ˆæ¯ç¦ç”¨ï¼‰
                            this.update_checkbox_state();

                            // ç»‘å®šmsgattråˆ°å…ƒç´ ä¸Šï¼Œæ–¹ä¾¿æ‰¹é‡æ“ä½œæ—¶è·å–æ¶ˆæ¯ID
                            this.e_container.bindmap = this.msgattr;

                            // =========================
                            // ç‚¹å‡»æ¶ˆæ¯ â†’ é€‰ä¸­
                            // =========================
                            this.e_container.addEventListener("click", (e) => {
                                e.stopPropagation();   // é˜²æ­¢å†’æ³¡è¢«å…¨å±€ click å–æ¶ˆ
                                this.select();
                            });

                            const showMenu = (event) => {
                                const rect = this.e_container.getBoundingClientRect();
                                const items = this.build_context_menu_items();

                                

                                this.e_container.classList.add("active");
                                MenuMark.exec({x: rect.left, y: rect.top + rect.height,}, items, () => {
                                    this.e_container.classList.remove("active");
                                });
                            };

                            // èœå•
                            this.e_container.addEventListener("contextmenu", (event) => showMenu(event));
                            if (_isMobileDevice) bindMenuForMobile(this.e_container, showMenu);

                        }


                        if (this.is_header()) {
                            const html = `<div class="chat-message-group"></div>`;
                            this.msgelement.insertAdjacentHTML("beforeend", html);
                            this.e_group = this.msgelement.querySelector(":scope .chat-message-group");

                            const tree_headers = [];
                            this.e_tree_item = new TreeWidget(this.e_group, tree_headers, null, 0, false, false, this.sent_by_me, 6)
                            // ğŸ”¥ æ·»åŠ è¯é¢˜æ ‡ç­¾
                            const topic = this.msgattr.topic || '';
                            const topicHtml = topic ? `<span class="chat-message-topic" title="ç‚¹å‡»ç­›é€‰æ­¤è¯é¢˜"># ${topic}</span>` : '';
                            const html2 = `
<div class="chat-message-group-header">

<div class="chat-message-group-header-row1">
    <p class="chat-message-group-header-date hidden"></p>
</div>

<div class="chat-message-group-header-row2">
    ${topicHtml}
    <p class="chat-message-group-header-name">${this.msgattr.sender}</p>
</div>

</div>
`;
                            this.e_tree_item.set_raw_header(html2);
                            this.e_tree_item.show();
                            this.e_tree_item.summary.style.padding = "0";
                            this.e_tree_item.summary.style.background = "transparent";
                            this.msgelement_li = this.e_tree_item.container_tree_items;


                            const group_header_name = this.e_tree_item.raw_header.querySelector(":scope p.chat-message-group-header-name");
                            group_header_name.style.color = "white";
                            group_header_name.style.background = this.palette.name_bg;

                            // ğŸ”¥ ç‚¹å‡»è¯é¢˜æ ‡ç­¾ç­›é€‰æ¶ˆæ¯
                            const topicEl = this.e_tree_item.raw_header.querySelector(":scope .chat-message-topic");
                            if (topicEl) {
                                topicEl.addEventListener("click", (e) => {
                                    e.stopPropagation();
                                    // è§¦å‘è¯é¢˜ç­›é€‰
                                    if (this.contentpage && this.contentpage.filter_by_topic) {
                                        this.contentpage.filter_by_topic(topic);
                                    }
                                });
                            }

                            if (this.is_different_day && form_field_checker.ffc_int(this.msgattr.sent_time)) {
                                const group_header_date = this.e_tree_item.raw_header.querySelector(":scope p.chat-message-group-header-date");
                                group_header_date.textContent = format_timestamp_utc8_day_time(this.msgattr.sent_time)[0];
                                group_header_date.classList.remove("hidden");
                            }

                            this.msgelement_li.style.margin = "0";
                            this.msgelement_li.style.transform = "translateY(-4px)";

                            this.msgelement_li.append(this.e_container);

                            if (this.is_sys_msg()) {
                                // this.e_tree_item.summary.classList.add("hidden");
                                const group_header_row2 = this.e_tree_item.raw_header.querySelector(":scope div.chat-message-group-header-row2");
                                group_header_row2.classList.add("hidden");
                            }
                        } else {
                            this.msgelement.append(this.e_container);
                        }
                    }
                    // =========================
                    // æ„å»ºå³é”® / æ›´å¤š èœå•é¡¹
                    // =========================
                    build_context_menu_items() {
                        const items = [];

                        if (this.msgattr.is_sent && (!this.blur_mark || !this.blur_mark.is_visible())) {
                                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(this.msgattr.type) ||
                                        dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(this.msgattr.type)) {
                                        items.push(
                                            {
                                                type: "button", text: "å¼•ç”¨", callback: event => {
                                                    this.contentpage.add_textarea_element__cite(
                                                        this.msgattr.id,
                                                        this.msgattr.plain_data_text,
                                                        this.msgattr.sender
                                                    );
                                                },
                                            },
                                            {type: "section", text: "",},
                                        );
                                    }

                                    if (!this.sent_by_me && !(this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.i_read)) {
                                        if (!this.contentpage.is_group() || this.at_attr.at_all || this.at_attr.at_users.includes(logged_user.uid)) {
                                            if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(this.msgattr.type) ||
                                                dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(this.msgattr.type)) {
                                                items.push(
                                                    {
                                                        type: "button", text: "æ ‡è®°å·²è¯»", callback: event => {
                                                            this.contentpage.mark_as_read(this.msgattr)
                                                        },
                                                    },
                                                    {type: "section", text: "",},
                                                );
                                            }
                                        }
                                    }

                                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(this.msgattr.type)) {
                                        const _ = {
                                            type: "button", text: "å¤åˆ¶æ–‡æœ¬", callback: event => {
                                                if (this.msgattr.plain_data_text) {
                                                    navigator.clipboard.writeText(this.msgattr.plain_data_text);
                                                }
                                            },
                                        }
                                        items.push(_, {type: "section", text: "",},);
                                        if (!this.msgattr.plain_data_text) {
                                            _.disabled = true;
                                        }
                                        // =========================
                                        // ğŸ¤– AI å’¨è¯¢ï¼ˆæ–°å¢ï¼‰
                                        // =========================
                                        const aiConsultItem = {
                                            type: "button",
                                            text: "ğŸ¤– AI å’¨è¯¢",
                                            callback: event => {
                                                if (!this.msgattr.plain_data_text) return;

                                                const prompt = build_ai_teacher_prompt(this.msgattr.plain_data_text);
                                                const encodedPrompt = encodeURIComponent(prompt);

                                                // è·³è½¬ AI å’¨è¯¢é¡µé¢
                                                window.open(`https://chatgpt.com/?q=${encodedPrompt}`, "_blank");
                                            },
                                        };
                                        items.push(aiConsultItem, { type: "section", text: "" });

                                        if (!this.msgattr.plain_data_text) {
                                            aiConsultItem.disabled = true;
                                        }
                                    }

                                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(this.msgattr.type)) {
                                        const _ = {
                                            type: "button", text: "å¤åˆ¶æ–‡ä»¶åç§°", callback: event => {
                                                if (this.msgattr.plain_file_name) {
                                                    navigator.clipboard.writeText(this.msgattr.plain_file_name);
                                                }
                                            },
                                        }
                                        items.push(_, {type: "section", text: "",},);
                                        if (!this.msgattr.plain_file_name) {
                                            _.disabled = true;
                                        }

                                        
                                    }

                                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(this.msgattr.type) ||
                                        dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(this.msgattr.type)) {
                                        items.push(
                                            {
                                                type: "button", text: "è½¬å‘", callback: event => {
                                                    this.contentpage.forward_msg(this.msgattr)
                                                },
                                            },
                                            {type: "section", text: "",},
                                        );
                                    }

                                    if (this.sent_by_me && dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(this.msgattr.type)) {
                                        const _ = {
                                            type: "button", text: "ç¼–è¾‘", callback: event => {
                                                this.contentpage.edit_msg(this.msgattr);
                                            },
                                        };
                                        items.push(_, {type: "section", text: "",},);
                                        if (!this.msgattr.plain_data_text || Date.now() / 1000 - this.msgattr.sent_time > seconds_of_minutes(10)) {
                                            _.disabled = true;
                                        }
                                    }

                                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(this.msgattr.type) ||
                                        dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(this.msgattr.type)) {
                                        const _ = {
                                            type: "button", text: "æ’¤å›", callback: event => {
                                                MessageMark.confirm(`ç¡®å®š${_.text}æ¶ˆæ¯ï¼Ÿ`, null, null, () => {
                                                    this.contentpage.revoke_msg(this.msgattr);
                                                },);
                                            },
                                        };
                                        items.push(_);
                                        if (Date.now() / 1000 - this.msgattr.sent_time > seconds_of_minutes(10)) {
                                            _.text = "åˆ é™¤";
                                        }
                                    }

                                }

                        return items;
                    }

                    // =========================
                    // ç‚¹å‡» ... æ‰“å¼€å®Œæ•´èœå•
                    // =========================
                    open_more_menu(btn) {
                        if (!btn) return;

                        const rect = btn.getBoundingClientRect();
                        const items = this.build_context_menu_items();

                        // ç”¨ requestAnimationFrame ä¿è¯ DOM å·²æ¸²æŸ“å®Œæˆ
                        requestAnimationFrame(() => {
                            MenuMark.exec(
                                { x: rect.left, y: rect.bottom },
                                items,
                                () => {} // èœå•å…³é—­å›è°ƒ
                            );
                        });
                    }


                    fill_marks() {
                        let html = `
<div class="chat-message-content-marks">

    <div class="chat-message-content-mark chat-mcm-send-status hidden">
        <span class="chat-mcm-send-status-text">æ­£åœ¨å‘é€</span>
        <button class="chat-mcm-send-status-btn-retry hidden">å‘é€å¤±è´¥ï¼Œç‚¹å‡»é‡è¯•</button>
    </div>

    <div class="chat-message-content-mark chat-mcm-sent-time hidden"></div>

    <div class="chat-message-content-mark chat-mcm-read-status hidden"></div>

</div>
`;
                        this.e_container.insertAdjacentHTML(this.sent_by_me ? "afterbegin" : "beforeend", html);


                        this.e_marks = this.e_container.querySelector(":scope .chat-message-content-marks");

                        this.e_send_status = this.e_marks.querySelector(":scope .chat-mcm-send-status");
                        this.e_send_status_text = this.e_marks.querySelector(":scope .chat-mcm-send-status-text");
                        this.e_send_status_btn_retry = this.e_marks.querySelector(":scope .chat-mcm-send-status-btn-retry");
                        this.e_send_status_btn_retry.addEventListener("click", () => {
                            this.contentpage.resend_msg(this);
                        });

                        this.e_sent_time = this.e_marks.querySelector(":scope .chat-mcm-sent-time");
                        this.e_read_status = this.e_marks.querySelector(":scope .chat-mcm-read-status");

                        // äºŒç¼–æ ‡è®°
                        {
                            let html = `<div class="chat-message-content-rect-mark-edited hidden"></div>`;
                            this.e_mcr.insertAdjacentHTML("beforeend", html);
                            this.e_mark_edited = this.e_mcr.querySelector(":scope .chat-message-content-rect-mark-edited");
                        }

                    }

                    update() {
                        if (!this.msgattr.is_sent) {
                            this.msgelement.classList.add("unsent");
                        } else {
                            this.msgelement.classList.remove("unsent");
                        }

                        if (this.is_sys_msg()) {
                            this.e_marks.classList.add("hidden");
                            this.e_container.classList.add("sys-msg");
                        }

                        if (!this.is_sys_msg()) {
                            if (!this.msgattr.is_sent) {
                                this.e_send_status.classList.remove("hidden");
                            } else {
                                if (this.is_header()) { // å‘é€æ—¶é—´
                                    if (form_field_checker.ffc_int(this.msgattr.sent_time)) {
                                        this.e_sent_time.textContent = format_timestamp_utc8_day_time(this.msgattr.sent_time)[1];
                                        this.e_sent_time.classList.remove("hidden");
                                    }
                                }

                                if (this.contentpage) { // å·²è¯»çŠ¶æ€
                                    this.e_read_status.classList.remove("hidden");

                                    if (this.contentpage.is_group()) { // ç¾¤èŠ
                                        if (this.at_attr.at_all) { // æ‰€æœ‰äºº
                                            if (this.sent_by_me) {
                                                this.e_read_status.textContent = `${this.msgattr.read_count}äººå·²è¯»`;
                                                this.e_read_status.classList.remove("noticing");
                                            } else if (this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.i_read) {
                                                this.e_read_status.textContent = `${this.msgattr.read_count}äººå·²è¯»`;
                                                this.e_read_status.classList.remove("noticing");
                                            } else {
                                                this.e_read_status.textContent = `æœªè¯»`;
                                                this.e_read_status.classList.add("noticing");
                                            }
                                        } else if (this.at_attr.at_users.length > 0) { // æŸäº›ç”¨æˆ·
                                            if (this.at_attr.at_users.length > 1) { // å¤šäºº
                                                if (this.sent_by_me) {
                                                    this.e_read_status.textContent = `${this.msgattr.read_count}äººå·²è¯»`;
                                                    this.e_read_status.classList.remove("noticing");
                                                } else if (this.at_attr.at_users.includes(logged_user.uid)) {
                                                    if (this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.i_read) {
                                                        this.e_read_status.textContent = `${this.msgattr.read_count}äººå·²è¯»`;
                                                        this.e_read_status.classList.remove("noticing");
                                                    } else {
                                                        this.e_read_status.textContent = `æœªè¯»`;
                                                        this.e_read_status.classList.add("noticing");
                                                    }
                                                } else {
                                                    this.e_read_status.classList.add("hidden");
                                                }
                                            } else { // å•äºº
                                                if (this.sent_by_me) {
                                                    if (this.msgattr.read_count > 0) {
                                                        this.e_read_status.textContent = `å·²è¯»`;
                                                        this.e_read_status.classList.remove("noticing");
                                                    } else {
                                                        this.e_read_status.textContent = `å¯¹æ–¹æœªè¯»`;
                                                        this.e_read_status.classList.add("noticing");
                                                    }
                                                } else if (this.at_attr.at_users.includes(logged_user.uid)) {
                                                    if (this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.i_read) {
                                                        this.e_read_status.textContent = `å·²è¯»`;
                                                        this.e_read_status.classList.remove("noticing");
                                                    } else {
                                                        this.e_read_status.textContent = `æœªè¯»`;
                                                        this.e_read_status.classList.add("noticing");
                                                    }
                                                } else {
                                                    this.e_read_status.classList.add("hidden");
                                                }
                                            }
                                        } else {
                                            this.e_read_status.classList.add("hidden");
                                        }

                                    } else { // ç§èŠ
                                        if (this.sent_by_me) {
                                            if (this.msgattr.read_count > 0) {
                                                this.e_read_status.textContent = `å·²è¯»`;
                                                this.e_read_status.classList.remove("noticing");
                                            } else {
                                                this.e_read_status.textContent = `å¯¹æ–¹æœªè¯»`;
                                                this.e_read_status.classList.add("noticing");
                                            }
                                        } else {
                                            if (this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.i_read) {
                                                this.e_read_status.textContent = `å·²è¯»`;
                                                this.e_read_status.classList.remove("noticing");
                                            } else {
                                                this.e_read_status.textContent = `æœªè¯»`;
                                                this.e_read_status.classList.add("noticing");
                                            }
                                        }
                                    }


                                }


                            }
                        }

                        if (!this.is_sys_msg()) {
                            if (!this.msgattr.is_sent) {
                            } else {
                                if (this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.edited) {
                                    this.e_mark_edited.classList.remove("hidden");
                                }
                            }
                        }


                    }

                    // =========================
                    // é€‰ä¸­ / å–æ¶ˆé€‰ä¸­
                    // =========================
                    select() {
                        // 1ï¸âƒ£ å…ˆæ¸…é™¤å…¶ä»–æ¶ˆæ¯é€‰ä¸­çŠ¶æ€
                        if (this.contentpage && this.contentpage.clear_all_selected_msgs) {
                            this.contentpage.clear_all_selected_msgs();
                        }

                        // 2ï¸âƒ£ æ ‡è®°è‡ªå·±ä¸ºé€‰ä¸­
                        this.is_selected = true;
                        this.e_container.classList.add("selected");

                        // 3ï¸âƒ£ æ˜¾ç¤ºæ“ä½œæ¡ï¼ˆæ¯æ¬¡éƒ½æ˜¾ç¤ºï¼Œä¸å— is_selected é™åˆ¶ï¼‰
                        this.show_actionbar();
                    }


                    unselect() {
                        if (!this.is_selected) return;

                        this.is_selected = false;
                        this.e_container.classList.remove("selected");

                        this.hide_actionbar();
                    }

                    // =========================
                    // æ˜¾ç¤ºåº•éƒ¨æ“ä½œæ¡
                    // =========================
                    show_actionbar() {
                        // 1ï¸âƒ£ ç§»é™¤å·²æœ‰æ“ä½œæ¡
                        document.querySelectorAll(".chat-msg-actionbar").forEach(bar => {
                            if (bar.msgobj) bar.msgobj.e_actionbar = null;
                            bar.remove();
                        });

                        // 2ï¸âƒ£ åˆ›å»ºæ“ä½œæ¡
                        const bar = document.createElement("div");
                        bar.className = "chat-msg-actionbar";
                        bar.msgobj = this;
                        this.e_actionbar = bar;

                        // 3ï¸âƒ£ æ„å»ºæŒ‰é’®åˆ—è¡¨
                        const items = [];

                        // å¼•ç”¨
                        items.push({
                            text: "å¼•ç”¨",
                            callback: () => this.contentpage.add_textarea_element__cite(this.msgattr.id, this.msgattr.plain_data_text, this.msgattr.sender)
                        });

                        // å¤åˆ¶
                        items.push({
                            text: "å¤åˆ¶",
                            callback: () => {
                                if (this.msgattr.plain_data_text) navigator.clipboard.writeText(this.msgattr.plain_data_text);
                            }
                        });

                        // è½¬å‘
                        items.push({
                            text: "è½¬å‘",
                            callback: () => this.contentpage.forward_msg(this.msgattr)
                        });

                        // AI å’¨è¯¢
                        items.push({
                            text: "ğŸ¤– AI å’¨è¯¢",
                            disabled: !this.msgattr.plain_data_text,
                            callback: () => {
                                if (!this.msgattr.plain_data_text) return;
                                const prompt = build_ai_teacher_prompt(this.msgattr.plain_data_text);
                                window.open(`https://chatgpt.com/?q=${encodeURIComponent(prompt)}`, "_blank");
                            }
                        });

                        // è‡ªå·±çš„æ¶ˆæ¯æ‰å¯ç¼–è¾‘/æ’¤å›/åˆ é™¤ï¼Œç®¡ç†å‘˜å¯åˆ é™¤ä»»ä½•æ¶ˆæ¯
                        const is_admin = logged_user && logged_user.contact_any;
                        if (this.sent_by_me || is_admin) {
                            const delText = Date.now() / 1000 - this.msgattr.sent_time > seconds_of_minutes(10) ? "åˆ é™¤" : "æ’¤å›";
                            items.push({
                                text: delText,
                                callback: () => {
                                    MessageMark.confirm(`ç¡®å®š${delText}æ¶ˆæ¯ï¼Ÿ`, null, null, () => {
                                        if (this.contentpage && typeof this.contentpage.revoke_msg === "function") {
                                            this.contentpage.revoke_msg(this.msgattr);
                                        }
                                    });
                                }
                            });

                            if (this.sent_by_me) {
                                items.push({
                                    text: "ç¼–è¾‘",
                                    callback: () => {
                                        if (this.contentpage && typeof this.contentpage.edit_msg === "function") {
                                            this.contentpage.edit_msg(this.msgattr);
                                        }
                                    }
                                });
                            }
                        }

                        // æ›´å¤šèœå•
                        items.push({
                            text: "...",
                            callback: (btn) => this.open_more_menu(btn)
                        });

                        // 4ï¸âƒ£ æ¸²æŸ“æŒ‰é’®
                        for (const item of items) {
                            const btn = document.createElement("button");
                            btn.textContent = item.text;
                            if (item.disabled) btn.disabled = true;

                            // å¯¹ â€œ...â€ æŒ‰é’®ç‰¹æ®Šå¤„ç†ï¼Œä¼  btn ç»™ open_more_menu
                            if (item.text === "...") {
                                btn.addEventListener("click", e => {
                                    e.stopPropagation();
                                    item.callback(btn);  // ä¼ å…¥æŒ‰é’®å…ƒç´ 
                                });
                            } else {
                                btn.addEventListener("click", e => {
                                    e.stopPropagation();
                                    item.callback();
                                    // é ... æŒ‰é’®ç‚¹å‡»åéšè—æ“ä½œæ¡
                                    this.hide_actionbar();
                                });
                            }

                            bar.appendChild(btn);
                        }

                        // 5ï¸âƒ£ æ·»åŠ åˆ°æ¶ˆæ¯å…ƒç´ 
                        this.msgelement.append(bar);
                    }






                    // =========================
                    // éšè—åº•éƒ¨æ“ä½œæ¡
                    // =========================
                    hide_actionbar() {
                        if (!this.e_actionbar) return;

                        this.e_actionbar.remove();
                        this.e_actionbar = null;
                    }

                    // =========================
                    // åº•éƒ¨æ“ä½œæ¡æŒ‰é’®å¤„ç†
                    // =========================
                    handle_actionbar_click(e) {
                        const btn = e.target.closest("button");
                        if (!btn) return;

                        const action = btn.dataset.action;

                        switch (action) {
                            case "cite":
                                this.contentpage.add_textarea_element__cite(
                                    this.msgattr.id,
                                    this.msgattr.plain_data_text,
                                    this.msgattr.sender
                                );
                                break;

                            case "copy":
                                if (this.msgattr.plain_data_text) {
                                    navigator.clipboard.writeText(this.msgattr.plain_data_text);
                                }
                                break;

                            case "forward":
                                this.contentpage.forward_msg(this.msgattr);
                                break;

                            case "ai":
                                // AIå’¨è¯¢é€»è¾‘
                                this.contentpage.open_ai_consult(this.msgattr);
                                break;

                            case "edit":
                                // ç¼–è¾‘é€»è¾‘
                                if (this.sent_by_me) {
                                    this.contentpage.edit_msg(this.msgattr);
                                } else {
                                    alert("åªèƒ½ç¼–è¾‘è‡ªå·±çš„æ¶ˆæ¯");
                                }
                                break;

                            case "delete":
                                // åˆ é™¤é€»è¾‘
                                const can_delete = this.sent_by_me || (logged_user && logged_user.contact_any);
                                if (can_delete) {
                                    if (this.contentpage && typeof this.contentpage.revoke_msg === "function") {
                                        this.contentpage.revoke_msg(this.msgattr);
                                    }
                                } else {
                                    alert("æƒé™ä¸è¶³ï¼Œåªèƒ½åˆ é™¤è‡ªå·±çš„æ¶ˆæ¯æˆ–ç®¡ç†å‘˜åˆ é™¤");
                                }
                                break;

                            case "more":
                                this.open_more_menu(btn); // ä¼ å…¥æŒ‰é’®å…ƒç´ 
                                break;
                        }

                        // ç‚¹å‡»åè‡ªåŠ¨éšè—æ“ä½œæ¡
                        this.hide_actionbar();
                    }


                    highlight() {
                        this.e_container.classList.add("highlight");
                        setTimeout(() => {
                            this.e_container.classList.remove("highlight");
                        }, 2000);
                    }

                    scroll_to_view(smooth) {
                        this.e_container.scrollIntoView({
                            behavior: smooth ? 'smooth' : 'instant',
                            block: 'center'
                        });
                        setTimeout(() => {
                            this.e_container.scrollIntoView({
                                behavior: smooth ? 'smooth' : 'instant',
                                block: 'center'
                            });
                        }, 200);
                    }

                    blur_content() {
                        if (!this.blur_mark) this.blur_mark = new BlurMark(this.e_container);
                        this.blur_mark.show();
                    }

                    unblur_content() {
                        if (this.blur_mark) this.blur_mark.remove();
                        this.blur_mark = null;
                    }

                    #resolve_relations(msgattrseniors) {
                        for (let i = 0; i < msgattrseniors.length; i++) {
                            const msgattrsenior = msgattrseniors[i];
                            if (!msgattrsenior.is_sent || !this.msgattr.is_sent) return;

                            if (i === 0) {
                                if (!form_field_checker.ffc_int(this.msgattr.sent_time) || !form_field_checker.ffc_int(msgattrsenior.sent_time)) return;
                                const this_dt = format_timestamp_utc8_day_time(this.msgattr.sent_time);
                                const previous_dt = format_timestamp_utc8_day_time(msgattrsenior.sent_time);
                                this.is_different_day = this_dt[0] !== previous_dt[0];
                                if (this.is_different_day) return;
                                if (this.msgattr.sent_time - msgattrsenior.sent_time > seconds_of_minutes(30)) return;
                            }

                            if (msgattrsenior.sender !== this.msgattr.sender) return;

                            if (this.is_sys_msg() || msgattrsenior.msgobj.is_sys_msg()) {
                                return;
                            }

                            if (msgattrsenior.msgobj.is_header()) {
                                this.msgattrparents.push(msgattrsenior);
                                return;
                            }
                            this.msgattrparents.push(msgattrsenior);
                        }
                        if (msgattrseniors.length === 0) {
                            this.is_different_day = true;
                        }
                    }

                    is_sys_msg() {
                        return dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_sys(this.msgattr.type);
                    }

                    update_checkbox_state() {
                        if (!this.e_msg_checkbox) return;
                        
                        const is_sys = this.is_sys_msg();
                        const is_admin = logged_user && (logged_user.contact_any == 1 || logged_user.contact_any === true);
                        const is_own_message = logged_user && this.msgattr.sender === logged_user.uid;

                        if (is_sys) {
                            this.e_msg_checkbox.disabled = true;
                            this.e_msg_checkbox.closest(".chat-message-checkbox").classList.add("chat-message-checkbox-disabled");
                        } else if (!is_admin && !is_own_message) {
                            this.e_msg_checkbox.disabled = true;
                        } else {
                            this.e_msg_checkbox.disabled = false;
                            this.e_msg_checkbox.closest(".chat-message-checkbox").classList.remove("chat-message-checkbox-disabled");
                        }
                    }

                    is_header() {
                        return this.msgattrparents.length === 0;
                    }

                    header() {
                        // if (this.msgobjparent === null) return this;
                        // let msgobjparent = this.msgobjparent;
                        // while (true) {
                        //     if (msgobjparent.msgobjparent !== null) {
                        //         msgobjparent = msgobjparent.msgobjparent;
                        //     } else {
                        //         return msgobjparent;
                        //     }
                        // }
                        return this.msgattrparents.at(-1).msgobj;
                    }

                    append_child(msgobj) {
                        // if (this.msgobjchildren.length > 0) {
                        //     msgobj.msgobjparent = this.msgobjchildren.at(-1);
                        // } else {
                        //     msgobj.msgobjparent = this;
                        // }
                        this.msgobjchildren.push(msgobj);
                        this.msgelement_li.append(msgobj.msgelement);
                    }

                    remove_child(msgobj_child) {
                        const index = this.msgobjchildren.indexOf(msgobj_child);
                        if (index > -1) {
                            this.msgobjchildren.splice(index, 1);
                            msgobj_child.remove_from_group();
                        }
                    }

                    remove_all_children() {
                        for (const msgchild of this.msgobjchildren) {
                            msgchild.remove_from_group();
                        }
                        this.msgobjchildren.length = 0;
                    }

                    remove_from_flow() {
                        this.msgelement.remove();
                    }

                    remove_from_group() {
                        this.msgelement.remove();
                    }

                    on_send_failed(error) {
                        this.e_send_status_text.classList.add("hidden");
                        this.e_send_status_btn_retry.classList.remove("hidden");
                    }

                    on_resend_started() {
                        this.e_send_status_text.classList.remove("hidden");
                        this.e_send_status_btn_retry.classList.add("hidden");
                    }
                }

                class TextMsg extends _ {
                    constructor(panel, contentpage, msgattr, msgattrseniors,) {
                        super(panel, contentpage, msgattr, msgattrseniors,);
                    }

                    init() {
                        super.init();

                        let html = `
<div class="chat-message-content-rect chat-mcr-text">
<div></div>
</div>
`;
                        this.e_container.insertAdjacentHTML("beforeend", html);

                        this.e_mcr = this.e_container.querySelector(":scope .chat-message-content-rect");
                        this.e_mcr.style.background = this.palette.rect_bg;

                        this.e_mcr_span = this.e_mcr.querySelector(":scope div");

                    }

                    update() {
                        super.update();

                        if (!this.msgattr.is_sent && this.msgattr.plain_text) {
                            // this.e_mcr_span.textContent = this.msgattr.plain_text;
                            this.e_mcr_span.innerHTML = MarkdownResolver.to_html(this.msgattr.plain_text);
                            this.init_md();
                        } else {
                            if (this.msgattr.plain_data_text) {
                                // this.e_mcr_span.textContent = this.msgattr.id + " | " + this.msgattr.plain_data_text;
                                if (!this.msgattr.plain_data_markdown) this.msgattr.plain_data_markdown = MarkdownResolver.to_html(this.msgattr.plain_data_text);
                                this.e_mcr_span.innerHTML = this.msgattr.plain_data_markdown;
                                this.init_md();
                            } else {
                                if (this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.encrypted) {
                                    encryptors.decrypt2string(this.msgattr.data_text).then(result => {
                                        // this.e_mcr_span.textContent = this.msgattr.id + " | " + result;
                                        this.msgattr.plain_data_markdown = MarkdownResolver.to_html(result);
                                        this.e_mcr_span.innerHTML = this.msgattr.plain_data_markdown;
                                        this.init_md();
                                        this.msgattr.plain_data_text = result;
                                    }).catch(error => {
                                        this.e_mcr_span.classList.add("red");
                                        this.e_mcr_span.textContent = decrypt_error_string;
                                    });
                                } else {
                                    // this.e_mcr_span.textContent = this.msgattr.data_text;
                                    this.msgattr.plain_data_markdown = MarkdownResolver.to_html(this.msgattr.data_text);
                                    this.e_mcr_span.innerHTML = this.msgattr.plain_data_markdown;
                                    this.init_md();
                                    this.msgattr.plain_data_text = this.msgattr.data_text;
                                }

                            }
                        }

                    }

                    init_md() {
                        {
                            const code_areas = this.e_mcr_span.querySelectorAll(":scope .md-area-code");
                            for (const codeArea of code_areas) {
                                const code_area_btn_copy = codeArea.closest(".md-area-code-wrap").querySelector(":scope .md-area-code-btn-copy");
                                code_area_btn_copy.addEventListener("click", (event) => navigator.clipboard.writeText(codeArea.textContent));
                            }
                        }

                        {
                            const tokens = this.e_mcr_span.querySelectorAll(":scope .md-text-at");
                            for (const token of tokens) {
                                let id = token.dataset.userId;
                                if (id === "all") id = "æ‰€æœ‰äºº";
                                if (id === "æ‰€æœ‰äºº") {
                                    token.textContent = "@" + id;
                                    this.at_attr.at_all = true;
                                } else {
                                    if (!this.at_attr.at_users.includes(id) && id !== this.msgattr.sender) {
                                        this.at_attr.at_users.push(id);
                                    }
                                }
                                token.palette = contentpages._chat.get_message_palette(id);
                                // token.style.color = "white";
                                token.style.color = token.palette.name_bg;
                                // token.style.background = token.palette.name_bg;
                            }
                        }

                        {
                            const tokens = this.e_mcr_span.querySelectorAll(":scope .md-text-cite");
                            for (const token of tokens) {
                                const id = parseInt(token.dataset.messageId);
                                if (form_field_checker.ffc_int(id)) {
                                    if (id === this.msgattr.id)
                                        continue;
                                    const msg = this.contentpage.li.bindmap.msgs.findLast(i => i.id === id);
                                    if (msg) {
                                        if (!this.at_attr.at_users.includes(msg.sender) && msg.sender !== this.msgattr.sender) {
                                            this.at_attr.at_users.push(msg.sender);
                                        }
                                        if (msg.plain_data_text) {
                                            if (msg.plain_data_text.length > 15) {
                                                token.textContent = "&" + msg.plain_data_text.slice(0, 15) + "...";
                                            } else {
                                                token.textContent = "&" + msg.plain_data_text;
                                            }
                                        } //
                                        else if (msg.plain_file_name) {
                                            if (msg.plain_file_name.length > 25) {
                                                token.textContent = "&" + msg.plain_file_name.slice(0, 25) + "...";
                                            } else {
                                                token.textContent = "&" + msg.plain_file_name;
                                            }
                                        } //
                                        else if (msg.formated_sys_msg) {
                                            if (msg.formated_sys_msg.length > 25) {
                                                token.textContent = "&" + msg.formated_sys_msg.slice(0, 25) + "...";
                                            } else {
                                                token.textContent = "&" + msg.formated_sys_msg;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        super.update();

                    }
                }

                class ImageMsg extends _ {
                    constructor(panel, contentpage, msgattr, msgattrseniors,) {
                        super(panel, contentpage, msgattr, msgattrseniors,);
                    }

                    init() {
                        super.init();

                        let html = `
                <div class="chat-message-content-rect chat-mcr-image">
                <img src="" alt="" draggable="false">
                <span>[ğŸ–¼ï¸å›¾ç‰‡]</span>
                </div>
                `;
                        this.e_container.insertAdjacentHTML("beforeend", html);
                        this.e_mcr = this.e_container.querySelector(":scope .chat-message-content-rect");
                        this.e_mcr.style.background = this.palette.rect_bg;

                        this.e_mcr_img = this.e_mcr.querySelector(":scope img");

                        const maxWidth = 650;
                        const maxHeight = 650;
                        let width = this.msgattr.image_attr.width;
                        let height = this.msgattr.image_attr.height;

                        if (width > maxWidth) {
                            height = height * (maxWidth / width);
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = width * (maxHeight / height);
                            height = maxHeight;
                        }

                        this.e_mcr_img.style.width = width + "px";
                        this.e_mcr_img.style.height = height + "px";

                        // ç‚¹å‡»å›¾ç‰‡å…¨å±
                        this.e_mcr_img.addEventListener("click", () => {
                            const im = new ImageMark(document.body);
                            im.show();
                            im.load_from_uint8array(
                                this.msgattr.plain_file_name,
                                this.msgattr.plain_file_data
                            );
                        });

                        // ç‚¹å‡»æ–‡å­—æ‰‹åŠ¨ä¸‹è½½
                        this.e_mcr_span = this.e_mcr.querySelector(":scope span");

                        this.e_mcr_span.addEventListener("click", () => {
                            if (!this.msgattr.is_sent) return;
                            if (!this.msgattr.plain_file_name) return;

                            if (this.msgattr.download_task) {
                                floatball.look_download_tasks(this.msgattr.download_task);
                                return;
                            }

                            this.startDownload();
                        });
                    }

                    /* ================================
                       è‡ªåŠ¨ / æ‰‹åŠ¨ä¸‹è½½ç»Ÿä¸€å…¥å£
                    ================================= */
                    startDownload() {

                        const t = new FloatBall.tasktypes.Download_ChatMessage(
                            floatball.dialog.tab_content_backtasks,
                            {
                                onfinished: () => this.update(),
                                onwaiting: () => this.update(),
                                onprogress: () => this.update(),
                                onfailed: () => this.update()
                            }
                        );

                        this.msgattr.download_task = t;

                        floatball.dialog.addTask(t);
                        t.set_name(this.msgattr.file_attr.name);
                        t.set_args({ msg: this.msgattr });

                        floatball.dialog.checkToStartTask();
                        floatball.dialog.checkToHide(t);
                    }

                    /* ================================
                       æ›´æ–°æ˜¾ç¤ºé€»è¾‘
                    ================================= */
                    update() {
                        super.update();

                        this.e_mcr_span.classList.remove(
                            "status-download",
                            "status-ready",
                            "status-encrypted",
                            "status-error"
                        );

                        /* ========= æœªå‘é€ï¼ˆä¸Šä¼ ä¸­ï¼‰ ========= */

                        if (!this.msgattr.is_sent) {

                            this.e_mcr_img.classList.add("hidden");

                            this.e_mcr_span.classList.add("mcr-status");
                            this.e_mcr_span.classList.add("status-download");

                            if (this.msgattr.upload_task) {
                                set_textContent_if_different(
                                    this.e_mcr_span,
                                    `[ğŸ–¼ï¸å›¾ç‰‡] ${this.msgattr.file_name} ${
                                        this.panel.wrapper.format_text_for_msgview(
                                            this.msgattr.upload_task.backtask_status_text.textContent
                                        )
                                    }`
                                );
                            } else {
                                set_textContent_if_different(
                                    this.e_mcr_span,
                                    `[ğŸ–¼ï¸å›¾ç‰‡] ${this.msgattr.file_name} æ­£åœ¨ä¸Šä¼ ...`
                                );
                            }

                            return;
                        }

                        /* ========= å·²å‘é€ ========= */

                        const fileSize = this.msgattr.file_attr?.size || 0;
                        const AUTO_LIMIT = 5 * 1024 * 1024; // 5MB

                        /* ---- æœªåˆ›å»ºä¸‹è½½ä»»åŠ¡ ---- */

                        if (!this.msgattr.download_task) {

                            this.e_mcr_img.classList.add("hidden");

                            this.msgattr.plain_file_name =
                                this.msgattr.file_attr.name;

                            // ===== å°äº 5MB è‡ªåŠ¨ä¸‹è½½ =====
                            if (fileSize <= AUTO_LIMIT && !this.msgattr.auto_downloading) {

                                this.msgattr.auto_downloading = true;

                                this.startDownload();

                                this.e_mcr_span.classList.add("mcr-status");
                                this.e_mcr_span.classList.add("status-download");

                                set_textContent_if_different(
                                    this.e_mcr_span,
                                    `[ğŸ–¼ï¸å›¾ç‰‡] ${this.msgattr.file_attr.name} æ­£åœ¨åŠ è½½...`
                                );

                                return;
                            }

                            // ===== å¤§å›¾ï¼šç‚¹å‡»ä¸‹è½½ =====
                            this.e_mcr_span.classList.add("mcr-status");
                            this.e_mcr_span.classList.add("status-download");

                            const sizeMB = (fileSize / 1024 / 1024).toFixed(2);

                            set_textContent_if_different(
                                this.e_mcr_span,
                                `[ğŸ–¼ï¸å›¾ç‰‡] ${this.msgattr.file_attr.name} (${sizeMB} MB) ç‚¹å‡»ä¸‹è½½æŸ¥çœ‹`
                            );

                            return;
                        }

                        /* ---- å·²æœ‰ä¸‹è½½ä»»åŠ¡ ---- */

                        // ä¸‹è½½å®Œæˆ
                        if (this.msgattr.plain_file_data) {

                            this.e_mcr_img.classList.remove("hidden");
                            this.e_mcr_span.classList.add("hidden");

                            if (!this.e_mcr_img.src.startsWith("blob")) {
                                this.set_img_src(this.msgattr.plain_file_data);
                            }

                            return;
                        }

                        // ä¸‹è½½ä¸­
                        this.e_mcr_span.classList.add("mcr-status");
                        this.e_mcr_span.classList.add("status-download");

                        const statusText =
                            this.panel.wrapper.format_text_for_msgview(
                                this.msgattr.download_task.backtask_status_text.textContent
                            );

                        set_textContent_if_different(
                            this.e_mcr_span,
                            `[ğŸ–¼ï¸å›¾ç‰‡] ${this.msgattr.plain_file_name} ${statusText}`
                        );

                        // åˆ†å—åˆ°è¾¾æ—¶æå‰æ˜¾ç¤º
                        if (this.msgattr.download_task.args.plain_file_data) {

                            this.msgattr.plain_file_data =
                                this.msgattr.download_task.args.plain_file_data;

                            this.msgattr.download_task.args.plain_file_data = null;

                            this.e_mcr_img.classList.remove("hidden");
                            this.e_mcr_span.classList.add("hidden");

                            this.set_img_src(this.msgattr.plain_file_data);
                        }
                    }

                    /* ================================
                       ç§»é™¤
                    ================================= */
                    remove_from_group() {
                        super.remove_from_group();

                        if (this.e_mcr_img__urlobj) {
                            URL.revokeObjectURL(this.e_mcr_img__urlobj);
                            this.e_mcr_img__urlobj = null;
                        }
                    }

                    /* ================================
                       è®¾ç½®å›¾ç‰‡
                    ================================= */
                    set_img_src(plain_file_data) {

                        const blob = new Blob([plain_file_data]);

                        this.e_mcr_img__urlobj = URL.createObjectURL(blob);
                        this.e_mcr_img.src = this.e_mcr_img__urlobj;

                        this.e_mcr_img.onload = () => {
                            if (this.e_mcr_img__urlobj) {
                                URL.revokeObjectURL(this.e_mcr_img__urlobj);
                                this.e_mcr_img__urlobj = null;
                            }
                        };
                    }
                }

                // ===== FileMsg ç±» =====
                  class FileMsg extends _ {
                    constructor(panel, contentpage, msgattr, msgattrseniors) {
                        super(panel, contentpage, msgattr, msgattrseniors);
                    }

                    init() {
                        super.init();

                        let html = `
                <div class="chat-message-content-rect chat-mcr-file">
                    <span class="chat-mcr-file-icon" draggable="false">ğŸ—³ï¸</span>
                    <div class="chat-mcr-file-info">
                        <span class="chat-mcr-file-info-name"></span>
                        <div class="chat-mcr-file-info-others">
                            <span class="chat-mcr-file-info-size"></span>
                            <span class="chat-mcr-file-status"></span>
                        </div>
                    </div>
                </div>
                `;
                        this.e_container.insertAdjacentHTML("beforeend", html);
                        this.e_mcr = this.e_container.querySelector(":scope .chat-message-content-rect");
                        this.e_mcr.style.background = this.palette.rect_bg;

                        this.e_mcr_icon = this.e_mcr.querySelector(":scope .chat-mcr-file-icon");
                        this.e_mcr_info_name = this.e_mcr.querySelector(":scope .chat-mcr-file-info-name");
                        this.e_mcr_info_size = this.e_mcr.querySelector(":scope .chat-mcr-file-info-size");
                        this.e_mcr_status = this.e_mcr.querySelector(":scope .chat-mcr-file-status");

                        this.e_mcr_info_size.textContent = format_bytes(this.msgattr.file_attr.size);

                        // âš¡ æ³¨å†Œåˆ° panel.attachments
                        if (!this.panel.attachments) this.panel.attachments = [];
                        if (!this.panel.attachments.includes(this.msgattr)) this.panel.attachments.push(this.msgattr);

                        // âš¡ ä¿å­˜å®ä¾‹åˆ° msgattrï¼Œç”¨äºé™„ä»¶åˆ—è¡¨å¤ç”¨ä¸‹è½½
                        this.msgattr._fileMsgInstance = this;

                        // ----- ä¸‹è½½é€»è¾‘å‡½æ•° -----
                        const startDownload = () => {
                            if (!this.msgattr.is_sent) return;
                            if (this.msgattr.upload_task && this.msgattr.upload_task.status !== FloatBall.taskstatus.finished) return;
                            if (!this.msgattr.plain_file_name) return;
                            if (this.msgattr.download_task && this.msgattr.download_task.status !== FloatBall.taskstatus.finished) {
                                floatball.look_download_tasks(this.msgattr.download_task);
                                return;
                            }

                            const t = new FloatBall.tasktypes.Download_ChatMessage(floatball.dialog.tab_content_backtasks, {
                                onfinished: () => { this.update(); },
                                onwaiting: () => { this.update(); },
                                onprogress: () => { this.update(); },
                                onfailed: () => { this.update(); }
                            });

                            this.msgattr.download_task = t;

                            floatball.dialog.addTask(t);
                            t.set_name(this.msgattr.plain_file_name);
                            t.set_args({ msg: this.msgattr });

                            floatball.dialog.checkToStartTask();
                            floatball.dialog.checkToHide(t);
                        };

                        // å›¾æ ‡ç‚¹å‡»ä¸‹è½½
                        this.e_mcr_icon.addEventListener("click", startDownload);
                        // æ–‡ä»¶åç‚¹å‡»ä¸‹è½½
                        this.e_mcr_info_name.addEventListener("click", startDownload);
                        this.e_mcr_info_name.style.cursor = "pointer";

                        // ----- æ‹–æ‹½é€»è¾‘ -----
                        this.e_mcr_icon.addEventListener('dragstart', (event) => {
                            if (event.target.tagName !== "SPAN") return;
                            dragging_item = this;
                            event.dataTransfer.effectAllowed = 'copy';
                        });
                        this.e_mcr_icon.addEventListener('dragend', () => { dragging_item = null; });
                    }

                    update() {
                        super.update();

                        if (!this.msgattr.is_sent) {
                            if (this.msgattr.upload_task) {
                                set_textContent_if_different(this.e_mcr_info_name, `${this.msgattr.file_name}`);
                                set_textContent_if_different(this.e_mcr_status, `${this.panel.wrapper.format_text_for_msgview(this.msgattr.upload_task.backtask_status_text.textContent)}`);
                            } else {
                                set_textContent_if_different(this.e_mcr_info_name, `${this.msgattr.file_name}`);
                                set_textContent_if_different(this.e_mcr_status, `æ­£åœ¨ä¸Šä¼ ...`);
                            }
                        } else {
                            if (!this.msgattr.download_task) { // æœªä¸‹è½½
                                if (this.msgattr.status & dashboardwrappers.ChatDashboardWrapper.message_status.encrypted) {
                                    encryptors.decrypt2string(this.msgattr.file_attr.name).then(result => {
                                        set_textContent_if_different(this.e_mcr_info_name, `${result}`);
                                        this.msgattr.plain_file_name = result;
                                    }).catch(error => {
                                        this.e_mcr_info_name.classList.add("red");
                                        this.e_mcr_icon.classList.add("red");
                                        set_textContent_if_different(this.e_mcr_info_name, `${decrypt_error_string}`);
                                    });
                                } else {
                                    set_textContent_if_different(this.e_mcr_info_name, `${this.msgattr.file_attr.name}`);
                                    this.msgattr.plain_file_name = this.msgattr.file_attr.name;
                                }
                            } else {
                                set_textContent_if_different(this.e_mcr_info_name, `${this.msgattr.plain_file_name}`);
                                set_textContent_if_different(this.e_mcr_status, `${this.panel.wrapper.format_text_for_msgview(this.msgattr.download_task.backtask_status_text.textContent)}`);

                                if (this.msgattr.download_task.args.plain_file_data) {
                                    // this.e_mcr_status.classList.add("hidden");

                                    saveFile_from_uint8array(this.msgattr.download_task.args.plain_file_data, this.msgattr.plain_file_name);
                                    this.msgattr.download_task.args.plain_file_data = null;

                                }

                                // 2. åŒæ­¥åˆ°é™„ä»¶åˆ—è¡¨
                                if (this.msgattr._attachment_list_item) {
                                    update_attachment_list_item(this.msgattr);
                                }

                            }

                        }

                    }

                }


                class SysMsg extends _ {
                    constructor(panel, contentpage, msgattr, msgattrseniors,) {
                        super(panel, contentpage, msgattr, msgattrseniors,);
                    }

                    init() {
                        super.init();

                        let html = `
<div class="chat-message-content-rect chat-mcr-sys">
<span></span>
</div>
`;
                        this.e_container.insertAdjacentHTML("beforeend", html);
                        this.e_mcr = this.e_container.querySelector(":scope .chat-message-content-rect");
                        this.e_mcr.style.background = this.palette.rect_bg;

                        this.e_mcr_span = this.e_mcr.querySelector(":scope span");

                    }

                    update() {
                        super.update();

                        if (!this.msgattr.is_sent) {
                            this.e_mcr_span.textContent = "ç³»ç»Ÿæ¶ˆæ¯æœªå‘é€ï¼Ÿ";
                        } else {
                            if (!this.msgattr.formated_sys_msg) this.msgattr.formated_sys_msg = this.panel.wrapper.format_sys_msg(this.msgattr);
                            this.e_mcr_span.textContent = this.msgattr.formated_sys_msg;

                        }

                    }

                }

                return {TextMsg, ImageMsg, FileMsg, SysMsg,};
            })()


            static get_message_palette(name, need_gray = false) {
                if (need_gray) {
                    return {name_bg: "rgb(169,169,169)", rect_bg: "rgba(169,169,169,15%)",};
                }
                const colors = [
                    {name_bg: "rgb(26,173,25)", rect_bg: "rgba(26,173,25,15%)",}, //
                    {name_bg: "rgb(28,137,173)", rect_bg: "rgba(28,137,173,15%)",}, //
                    {name_bg: "rgb(209,46,209)", rect_bg: "rgba(209,46,209,15%)",}, //
                    {name_bg: "rgb(216,67,70)", rect_bg: "rgba(216,67,70,15%)",}, //
                    {name_bg: "rgb(214,59,124)", rect_bg: "rgba(214,59,124,15%)",}, //
                    {name_bg: "rgb(165,64,211)", rect_bg: "rgba(165,64,211,15%)",}, //
                    {name_bg: "rgb(126,72,222)", rect_bg: "rgba(126,72,222,15%)",}, //
                    {name_bg: "rgb(95,88,229)", rect_bg: "rgba(95,88,229,15%)",}, //
                    {name_bg: "rgb(82,106,227)", rect_bg: "rgba(82,106,227,15%)",}, //
                    {name_bg: "rgb(67,129,180)", rect_bg: "rgba(67,129,180,15%)",}, //
                    {name_bg: "rgb(44,149,149)", rect_bg: "rgba(44,149,149,15%)",}, //
                    {name_bg: "rgb(39,149,111)", rect_bg: "rgba(39,149,111,15%)",}, //
                    {name_bg: "rgb(98,131,31)", rect_bg: "rgba(98,131,31,15%)",}, //
                    {name_bg: "rgb(129,129,31)", rect_bg: "rgba(129,129,31,15%)",}, //
                    {name_bg: "rgb(144,106,36)", rect_bg: "rgba(144,106,36,15%)",}, //
                    {name_bg: "rgb(157,90,46)", rect_bg: "rgba(157,90,46,15%)",}, //
                ];
                return pickBucket(name, colors);
                // return random_choice(colors);
            }


            /*
            * è‰ç¨¿
            * */
            save_draft_text() {
                if (this.is_editing_msg) return;
                this.li.bindmap.draft_text = this.e_inputarea_textarea.value;
                this.e_inputarea_textarea.value = "";
                this.client.dashboard_chat.wrapper._update_contact_item_status(this.li.bindmap, this.li.bindmap.status_attr, true);
            }

            load_draft_text() {
                this.e_inputarea_textarea.value = this.li.bindmap.draft_text;
            }


            /*
            * åœ¨çº¿æˆå‘˜
            * */
            fetch_online_users() {
                this.e_msgflow_mark_onlineusers.classList.remove("hidden");
                this.remove_online_users();
                if (!this.e_msgflow_mark_onlineusers.simple_loading_mark.is_visible()) {
                    remove_simple_loading_mark(this.e_msgflow_mark_onlineusers);
                    this.e_msgflow_mark_onlineusers.simple_loading_mark.show();

                    const {xxid, contact_type} = this.current_contact_xxid();
                    checkin.subviews.chat.members(contact_type, xxid,)
                        .then(result => {
                            if (this.closed) return;
                            this.load_online_users(result.users);
                            this.li.bindmap.status_attr.online_count = result.online_count;
                            this.client.dashboard_chat.wrapper._update_contact_item_status(this.li.bindmap, this.li.bindmap.status_attr, true);
                            remove_simple_loading_mark(this.e_msgflow_mark_onlineusers);
                        }).catch(error => {
                        if (this.closed) return;
                        remove_simple_loading_mark(this.e_msgflow_mark_onlineusers);
                        MessageMark.report(error);
                    });
                }
            }

            remove_online_users() {
                const items = this.e_msgflow_mark_onlineusers.querySelectorAll(":scope div.chat-session-onlineusers-item");
                items.forEach(i => i.remove());
            }

            // ===== åœ¨çº¿æˆå‘˜ + é™„ä»¶åˆ—è¡¨ =====
            load_online_users(users) {
                // åˆå§‹åŒ–ç»Ÿä¸€å®¹å™¨
                if (!this.e_online_members_wrapper) {
                    this.e_online_members_wrapper = this.e_msgflow_mark_onlineusers;
                    this.e_online_members_wrapper.style.width = "250px";
                    this.e_online_members_wrapper.style.minWidth = "250px";
                    this.e_online_members_wrapper.style.maxWidth = "150px";

                    this.e_online_members_wrapper.style.border = "1px solid #ddd";
                    this.e_online_members_wrapper.style.padding = "2px";

                    // === å…¨å±€æœç´¢æ¡† ===
                    const globalSearch = document.createElement("input");
                    globalSearch.type = "text";
                    globalSearch.placeholder = "æœç´¢æˆå‘˜æˆ–é™„ä»¶...";
                    globalSearch.style.width = "90%";
                    globalSearch.style.margin = "4px 0";
                    globalSearch.style.padding = "2px 4px";
                    globalSearch.style.border = "1px solid #ccc";
                    globalSearch.style.borderRadius = "3px";
                    this.e_online_members_wrapper.appendChild(globalSearch);
                    this.globalSearchInput = globalSearch;

                    // é™„ä»¶æ ‡é¢˜å’Œå®¹å™¨åˆå§‹åŒ–ä¸ºç©ºï¼Œç¨åæ ¹æ®é™„ä»¶æ•°é‡åˆ›å»º
                    this.e_online_attachment_title = null;
                    this.e_online_attachment_panel = null;

                    // æˆå‘˜æ ‡é¢˜å’Œåˆ—è¡¨å®¹å™¨åˆå§‹åŒ–
                    this.e_member_list_container = null;
                    this.e_member_title = null;

                    // === æœç´¢é€»è¾‘ ===
                    globalSearch.addEventListener("input", e => {
                        const keyword = e.target.value.trim().toLowerCase();

                        // æˆå‘˜è¿‡æ»¤
                        if (this.e_member_list_container) {
                            this.e_member_list_container.querySelectorAll(".chat-session-onlineusers-item").forEach(item => {
                                const name = item.attr.uid.toLowerCase();
                                item.style.display = name.includes(keyword) ? "" : "none";
                            });
                        }

                        // é™„ä»¶è¿‡æ»¤
                        if (this.e_online_attachment_panel) {
                            this.e_online_attachment_panel.querySelectorAll(".cap-item").forEach(item => {
                                const name = item.querySelector(".name").innerText.toLowerCase();
                                item.style.display = name.includes(keyword) ? "" : "none";
                            });
                        }
                    });
                }

                // === æ¸…ç©ºæ—§åˆ—è¡¨ ===
                if (this.e_online_attachment_panel) {
                    this.e_online_attachment_panel.innerHTML = "";
                    this.e_online_attachment_title.remove();
                    this.e_online_attachment_panel.remove();
                    this.e_online_attachment_title = null;
                    this.e_online_attachment_panel = null;
                }
                if (this.e_member_list_container) {
                    this.e_member_list_container.innerHTML = "";
                    if (this.e_member_title) this.e_member_title.remove();
                    this.e_member_list_container.remove();
                    this.e_member_list_container = null;
                    this.e_member_title = null;
                }

                // === æ¸²æŸ“é™„ä»¶ï¼ˆæœ‰é™„ä»¶æ‰æ˜¾ç¤ºæ ‡é¢˜å’Œåˆ—è¡¨ï¼‰ ===
                const attachments = this.panel.attachments || [];
                if (attachments.length > 0) {
                    // é™„ä»¶æ ‡é¢˜
                    const attachTitle = document.createElement("div");
                    attachTitle.innerText = "é™„ä»¶";
                    attachTitle.style.fontWeight = "700";
                    attachTitle.style.fontSize = "14px";
                    attachTitle.style.padding = "4px 6px";
                    attachTitle.style.background = "#f0f0f0";
                    attachTitle.style.borderBottom = "1px solid #ccc";
                    attachTitle.style.marginTop = "4px";
                    attachTitle.style.color = "#333";
                    this.e_online_members_wrapper.appendChild(attachTitle);
                    this.e_online_attachment_title = attachTitle;

                    // é™„ä»¶åˆ—è¡¨å®¹å™¨
                    const attachContainer = document.createElement("div");
                    attachContainer.className = "online-users-attachments";
                    attachContainer.style.marginTop = "2px";
                    this.e_online_members_wrapper.appendChild(attachContainer);
                    this.e_online_attachment_panel = attachContainer;

                    attachments.reverse().forEach(msgattr => {
                        const div = document.createElement("div");
                        div.className = "cap-item";
                        div.style.padding = "4px 2px";
                        div.style.borderBottom = "1px solid #eee";
                        div.style.wordBreak = "break-all";

                        div.innerHTML = `
                            <span class="cap-prefix">
                                <span class="cap-icon">ğŸ“</span>
                            </span>
                            <div class="cap-main">
                                <div class="name" title="${msgattr.plain_file_name || msgattr.file_attr.name}">
                                    ${msgattr.plain_file_name || msgattr.file_attr.name}
                                </div>
                                <div class="cap-info">
                                    <span class="size">${format_bytes(msgattr.file_attr.size)}</span>
                                    <span class="status"></span>
                                    <button class="download-btn">ä¸‹è½½</button>
                                </div>
                                <div class="progress-bar-wrapper">
                                    <div class="progress-bar"></div>
                                </div>
                            </div>
                        `;
                        attachContainer.appendChild(div);
                        msgattr._attachment_list_item = div;

                        div.querySelector(".download-btn").addEventListener("click", e => {
                            e.stopPropagation();
                            trigger_file_download(msgattr);
                        });

                        update_attachment_list_item(msgattr);
                    });
                }

                // === æ¸²æŸ“æˆå‘˜ ===
                if (users.length > 0) {
                    const memberTitle = document.createElement("div");
                    memberTitle.innerText = "æˆå‘˜";
                    memberTitle.style.fontWeight = "700";
                    memberTitle.style.fontSize = "14px";
                    memberTitle.style.padding = "4px 6px";
                    memberTitle.style.background = "#f0f0f0";
                    memberTitle.style.borderBottom = "1px solid #ccc";
                    memberTitle.style.marginTop = "4px";
                    memberTitle.style.color = "#333";
                    this.e_online_members_wrapper.appendChild(memberTitle);
                    this.e_member_title = memberTitle;

                    const memberListContainer = document.createElement("div");
                    memberListContainer.style.padding = "2px 0";
                    this.e_online_members_wrapper.appendChild(memberListContainer);
                    this.e_member_list_container = memberListContainer;

                    users.forEach(i => {
                        const html = `
                        <div class="chat-session-onlineusers-item">
                            <span class="chat-session-onlineusers-item-online-status">â—</span>
                            <span class="chat-session-onlineusers-item-name">${i.uid}</span>
                        </div>
                        `;
                        memberListContainer.insertAdjacentHTML("beforeend", html);
                        const onlineusers_item = memberListContainer.querySelector(":scope .chat-session-onlineusers-item:last-of-type");
                        onlineusers_item.attr = i;

                        const online_status_dot = onlineusers_item.querySelector(":scope span.chat-session-onlineusers-item-online-status");
                        online_status_dot.dataset.onlineStatus = i.status === dashboardwrappers.ChatDashboardWrapper.online_status.online ? "online" : "offline";

                        onlineusers_item.addEventListener("click", event => {
                            const rect = event.target.getBoundingClientRect();
                            const items = [{
                                type: "button",
                                text: "è‰¾ç‰¹",
                                callback: () => this.add_textarea_element__at(onlineusers_item.attr.uid)
                            }];
                            onlineusers_item.classList.add("active");
                            MenuMark.exec({ x: rect.left, y: rect.top + rect.height }, items, () => {
                                onlineusers_item.classList.remove("active");
                            });
                        });
                    });
                }
            }







            /*
            * å½“å‰æ—¥æœŸ
            * */
            show_currentday_mark(msgattr) {
                if (this.e_msgflow_mark_currentday__timer) {
                    clearTimeout(this.e_msgflow_mark_currentday__timer);
                    this.e_msgflow_mark_currentday__timer = null;
                }
                if (!msgattr) {
                    this.e_msgflow_mark_currentday.style.opacity = "0";
                    return;
                }
                this.e_msgflow_mark_currentday_p.textContent = format_timestamp_utc8_day_time(msgattr.sent_time)[0];
                this.e_msgflow_mark_currentday.style.opacity = "1";
                this.e_msgflow_mark_currentday__timer = setTimeout(() => {
                    if (this.closed) return;
                    this.e_msgflow_mark_currentday.style.opacity = "0";
                }, 3000);
            }



            /*
            * æ–‡æœ¬è¾“å…¥æ¡†
            * */
            add_textarea_element__at(uid) {
                const textToInsert = `@${uid} `;
                this.add_textarea_element(textToInsert);
            }


            add_textarea_element__cite(message_id, text, user_name) {
                if (!text) return;
                const new_text = `&${message_id} â®Œ**${user_name}ï¼š**${text}`
                // å¤šè¡Œæ–‡æœ¬ä¹Ÿèƒ½æ­£å¸¸å¼•ç”¨
                const quoted = new_text
                    .split("\n")
                    .map(line => `> ${line}`)
                    .join("\n");

                const textToInsert = `\n${quoted}\n\n`;
                this.add_textarea_element(textToInsert);
            }


            add_textarea_element(textToInsert) {
                const textarea = this.e_inputarea_textarea;

                // è·å–å…‰æ ‡ä½ç½®
                const startPos = textarea.selectionStart;
                const endPos = textarea.selectionEnd;
                // textarea åŸæ¥çš„å†…å®¹
                const originalValue = textarea.value;
                // åœ¨å…‰æ ‡ä½ç½®æ’å…¥æ–‡æœ¬
                textarea.value =
                    originalValue.substring(0, startPos) +
                    textToInsert +
                    originalValue.substring(endPos);
                // æ›´æ–°å…‰æ ‡ä½ç½®åˆ°æ’å…¥æ–‡æœ¬å
                textarea.selectionStart = textarea.selectionEnd = startPos + textToInsert.length;
                // ä¿æŒ textarea ç„¦ç‚¹
                textarea.focus();
            }

            add_new_textarea_element(textToInsert) {
                const textarea = this.e_inputarea_textarea;

                // è·å–å…‰æ ‡ä½ç½®
                const startPos = textarea.selectionStart;
                const endPos = textarea.selectionEnd;
                // textarea åŸæ¥çš„å†…å®¹
                const originalValue = "";
                // åœ¨å…‰æ ‡ä½ç½®æ’å…¥æ–‡æœ¬
                textarea.value =
                    originalValue.substring(0, startPos) +
                    textToInsert +
                    originalValue.substring(endPos);
                // æ›´æ–°å…‰æ ‡ä½ç½®åˆ°æ’å…¥æ–‡æœ¬å
                textarea.selectionStart = textarea.selectionEnd = startPos + textToInsert.length;
                // ä¿æŒ textarea ç„¦ç‚¹
                textarea.focus();
            }
            update_activity(type) {
                // if (this.previous_activity_attr.is_sending) return;
                const current_time = Date.now();
                if (this.previous_activity_attr.type === type && current_time - this.previous_activity_attr.sent_time < 5 * 1000) return;
                this.previous_activity_attr.type = type;
                this.previous_activity_attr.sent_time = current_time;

                // this.previous_activity_attr.is_sending = true;
                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    // this.previous_activity_attr.is_sending = false;
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result);
                };
                const onfetcherror = (error) => {
                    if (error.auto_retry) {
                        return;
                    }

                    // if (this.closed) return;
                    // this.previous_activity_attr.is_sending = false;
                    MessageMark.report(error);
                };
                const ws_isopen = this.panel.wrapper.ws_isopen();
                checkin.subviews.chat.act(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, type)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });

            }


            /*
            * åŠ è½½å†å²
            * */
            start__load_history() {
                if (this.is_processing__load_history) return;

                this.is_processing__load_history = true;
                this.change_loading_status__loadhistory();

                const first_msgattr = this.li.bindmap.msgs.length > 0 ? this.li.bindmap.msgs.at(0) : null;

                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    this.is_processing__load_history = false;
                    this.change_loading_status__loadhistory();
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                    this.handle_response__load_history(first_msgattr, result, false);
                    this.client.dashboard_chat.wrapper._update_contact_item_status(this.li.bindmap, this.li.bindmap.status_attr, true);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    this.is_processing__load_history = false;
                    this.change_loading_status__loadhistory();
                    MessageMark.report(error);
                };
                const ws_isopen = this.panel.wrapper.ws_isopen();
                checkin.subviews.chat.load_history(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, first_msgattr,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });

            }

            async handle_response__load_history(first_msgattr, result, is_background = true) {
                if (!this.client.dashboard_chat.wrapper.is_active()) return;

                if (result.is_found_first_message) { // æŒ‰è¯·æ±‚çš„èµ·å§‹æ¶ˆæ¯
                    if (result.next_message_id !== first_msgattr.id) {
                        console.warn(`next_message_idä¸åŒ¹é…ï¼Œfirst_msgattr.id=${first_msgattr.id}ï¼Œresult=${JSON.stringify(result)}`);
                    } else {
                        const new_msgattrs = this.msgflow_manage.insert_msgs(first_msgattr, result.messages);
                        if (new_msgattrs.length > 0) {
                            const msg = new_msgattrs.at(-1);
                            if (msg) {
                                msg.msgobj.highlight();
                                if (!is_background) msg.msgobj.scroll_to_view(false);
                            }
                        }
                    }
                }
            }

            change_loading_status__loadhistory() {
                if (this.is_processing__load_history) {
                    this.e_msgflow_mark_loadhistory.classList.remove("hidden");
                } else {
                    this.e_msgflow_mark_loadhistory.classList.add("hidden");
                }
            }

            change_loading_status__checknew() {
                if (this.is_processing__fetch_unread_msgs) {
                    this.e_msgflow_mark_checknew.classList.remove("hidden");
                } else {
                    this.e_msgflow_mark_checknew.classList.add("hidden");
                }
            }


            /*
            * å¯¼å‡ºèŠå¤©è®°å½•
            * @param {boolean} exportZip - true=å¯¼å‡ºzipåŒ…(å«å›¾ç‰‡æ–‡ä»¶å¤¹), false=å•æ–‡ä»¶markdown(Base64å†…åµŒ)
            * */
            output_msgs(exportZip = false) {
                const contact_name = this.current_contact_name();
                const data_string = date_string_for_fileName();
                const folder_name = `01_${contact_name}èŠå¤©è®°å½•_${data_string}`;
                const name = `${folder_name}.md`;

                const strings = [];
                const imageFiles = {};
                let imageCount = 0;

                strings.push(`# ${contact_name} èŠå¤©è®°å½•`);
                strings.push(`\n> å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`);
                strings.push(`---\n`);

                const getMimeType = (filename) => {
                    const ext = filename.split('.').pop().toLowerCase();
                    const mimeTypes = {
                        'jpg': 'image/jpeg',
                        'jpeg': 'image/jpeg',
                        'png': 'image/png',
                        'gif': 'image/gif',
                        'webp': 'image/webp',
                        'bmp': 'image/bmp',
                        'svg': 'image/svg+xml',
                        'ico': 'image/x-icon'
                    };
                    return mimeTypes[ext] || 'image/jpeg';
                };

                const uint8ArrayToBase64 = (uint8Array) => {
                    let binary = '';
                    const len = uint8Array.byteLength;
                    for (let i = 0; i < len; i++) {
                        binary += String.fromCharCode(uint8Array[i]);
                    }
                    return btoa(binary);
                };

                const isSentByMe = (sender) => {
                    return logged_user && sender === logged_user.uid;
                };

                const formatTime = (timestamp) => {
                    return format_timestamp_utc8(timestamp);
                };

                this.li.bindmap.msgs.forEach(msgattr => {
                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_sys(msgattr.type)) {
                        return;
                    }

                    const isMe = isSentByMe(msgattr.sender);
                    const senderName = isMe ? "**ä½ **" : `**${msgattr.sender}**`;
                    const timeStr = formatTime(msgattr.sent_time);
                    const arrow = isMe ? "â¬…ï¸" : "â¡ï¸";

                    let s = `[æœªçŸ¥æ¶ˆæ¯ç±»å‹]`;

                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(msgattr.type)) {
                        const content = msgattr.plain_data_text.replace(/\n/g, '\n> ');
                        s = `> ${senderName} ${arrow} ${timeStr}\n>\n> ${content}`;
                    } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(msgattr.type)) {
                        if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_image(msgattr.type)) {
                            const filename = msgattr.plain_file_name || 'image';
                            if (msgattr.plain_file_data && msgattr.plain_file_data instanceof Uint8Array) {
                                if (exportZip) {
                                    try {
                                        const mimeType = getMimeType(filename);
                                        let uniqueFilename = filename;
                                        let counter = 1;
                                        while (imageFiles[uniqueFilename]) {
                                            const ext = filename.split('.').pop();
                                            const base = filename.replace(`.${ext}`, '');
                                            uniqueFilename = `${base}_${counter}.${ext}`;
                                            counter++;
                                        }
                                        imageFiles[uniqueFilename] = {
                                            data: msgattr.plain_file_data,
                                            mime: mimeType
                                        };
                                        s = `> ${senderName} ${arrow} ${timeStr}\n>\n> ![${uniqueFilename}](images/${uniqueFilename})`;
                                    } catch (e) {
                                        s = `> ${senderName} ${arrow} ${timeStr}\n>\n> ğŸ–¼ï¸ [${filename}] (å¯¼å‡ºå¤±è´¥: ${e.message})`;
                                    }
                                } else {
                                    s = `> ${senderName} ${arrow} ${timeStr}\n>\n> ğŸ–¼ï¸ [${filename}]`;
                                }
                            } else {
                                s = `> ${senderName} ${arrow} ${timeStr}\n>\n> ğŸ–¼ï¸ [${filename}] (è¯·å…ˆä¸‹è½½å›¾ç‰‡)`;
                            }
                        } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_file(msgattr.type)) {
                            s = `> ${senderName} ${arrow} ${timeStr}\n>\n> ğŸ“ [${msgattr.plain_file_name}]`;
                        }
                    }

                    strings.push(s);
                });

                const markdownContent = strings.join("\n\n");

                if (exportZip && Object.keys(imageFiles).length > 0) {
                    const zip = new JSZip();
                    zip.file(name, markdownContent);
                    
                    const imgFolder = zip.folder("images");
                    for (const [filename, fileInfo] of Object.entries(imageFiles)) {
                        imgFolder.file(filename, fileInfo.data);
                    }
                    
                    zip.generateAsync({type: "blob"})
                        .then(function(content) {
                            const zipName = `${folder_name}.zip`;
                            const a = document.createElement("a");
                            a.href = URL.createObjectURL(content);
                            a.download = zipName;
                            a.click();
                            URL.revokeObjectURL(a.href);
                        });
                } else {
                    saveFile_from_text(markdownContent, name);
                }

            }


            /*
            * æ¸…ç†æ¶ˆæ¯
            * */
            clear_msgs() {

                let form = [
                    {type: "title", label: "åˆ é™¤æ¶ˆæ¯ï¼š"},
                    {type: "number", label: "å¤šå°‘å°æ—¶å‰çš„", value: 72, min: 0, max: 24 * 90,},
                    {type: "noticing", label: "", text: "ç¡®ä¿ä»–äººå·²è¯»ã€‚"},
                ];

                const confirm_callback = (fm,) => {
                    fm.collect_data();

                    try {
                        let old_than_hours = JSON.parse(form[1].value);
                        if (!form_field_checker.ffc_int(old_than_hours)) throw new Error("number");

                        fm.remove();
                        this._clear_msgs(old_than_hours);

                    } catch (e) {
                        MessageMark.report(e, fm.rect)
                    }

                }

                FormMark.get_global_input(form, confirm_callback)
            }

            _clear_msgs(old_than_hours) {
                const {xxid, contact_type, ceid} = this.current_contact_xxid();

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    this.client.dashboard_chat.wrapper.update_contact_item_status(result.sync);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;
                    MessageMark.report(error);
                };
                const ws_isopen = false;
                checkin.subviews.chat.clear(ws_isopen ? (args) => {
                    this.panel.wrapper.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, contact_type, xxid, ceid, old_than_hours,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

        }

        /*
        * æ”¶å‘
        * */
        let dashboard_mail = {
            inbox(event) {

            },

            sent(event) {

            },

            trashcan(event) {

            },

            activity(event) {

            },
        }

        /*
        * ç½‘ç›˜
        * */
        let dashboard_drive = {

            myspace: class extends _drive {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                }
            },

            trashcan: class extends _drive {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                }
            },

            newfiles: class extends _drive {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                }
            },

            sharewithme: class extends _drive {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                }
            },

            root: class extends _drive {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                }
            },
        }

        /*
         * èŠå¤©
         * */
        let dashboard_chat = {
            group: class extends _chat {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                }
            },

            user: class extends _chat {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                }
            },

        }

        /*
        * è®ºå›
        * */
        let dashboard_forum = {
            myspace(event) {

            },
        }

        /*
        * åå°
        * */
        let backend_panel = {
            activity: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    this.tree1.remove()
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                    let html = `
<div class="activity-rect">
<button class="btn-back-to-left-aside">â®Œ</button>
<div class="activity-filter">
    <label>èŒƒå›´<select></select></label>
    <label>æ—¥æœŸ<input type="date"></label>
</div>

<div class="activity-users">
</div>

</div>
`;
                    this.container.insertAdjacentHTML("beforeend", html);
                    this.activity_rect = this.container.querySelector(":scope div.activity-rect");

                    this.e_btn_back_to_left_aside = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    this.e_btn_back_to_left_aside.addEventListener("click", (event) => {
                        this.client.close_content_page();
                    });

                    this.activity_filter = this.activity_rect.querySelector(":scope div.activity-filter");
                    this.activity_filter_group_selector = this.activity_filter.querySelector(":scope select");
                    this.activity_filter_group_selector.addEventListener("change", (event) => {
                        this.fetch_list();
                    });
                    this.activity_filter_date = this.activity_filter.querySelector(":scope input[type=\"date\"]");
                    this.activity_filter_date.value = format_timestamp_utc8((Date.now() / 1000), "YYYY-MM-DD")
                    this.activity_filter_date.addEventListener("change", (event) => {
                        this.fetch_list();
                    });

                    this.activity_users = this.activity_rect.querySelector(":scope div.activity-users");

                    const tree_headers = [
                        {text: "", width: 40,},
                        {text: "ç”¨æˆ·", width: 120,},
                        {text: "å½“æ—¥é¦–æ¬¡ä¸Šçº¿", width: 160,},
                        {text: "å½“æ—¥æœ€ååœ¨çº¿", width: 160,},
                    ];
                    this.tree1 = new TreeWidget(this.activity_users, tree_headers, this.fill_tree_menu.bind(this))
                    this.tree1.show();

                    this.fetch_group_list();
                }

                fill_tree_menu(clicking_info) {
                    const items = [];
                    if (clicking_info.direction === TreeWidget.clicking_direction.header)
                        return items;

                    return items;
                }

                _attrs2columns(attr) {
                    const left = !attr.first_login_time && !attr.first_login_time;
                    return [
                        {text: this.tree1.tree_items.length + 1, selectable: false,},
                        {text: attr.uid, selectable: true,},
                        {
                            text: left ? "æœªä¸Šçº¿" : format_timestamp_utc8(attr.first_login_time),
                            selectable: true,
                            highlight: left,
                        },
                        {text: left ? "" : format_timestamp_utc8(attr.last_login_time), selectable: true,},
                    ];
                }

                remove_all_group_items() {
                    this.activity_filter_group_selector.querySelectorAll(":scope > option").forEach(i => i.remove());
                    let html = `
<option value="æ‰€æœ‰ç”¨æˆ·">æ‰€æœ‰ç”¨æˆ·</option>
`;
                    this.activity_filter_group_selector.insertAdjacentHTML("beforeend", html);
                }

                add_group_item(attr) {
                    let html = `
<option value="${attr.gid}">ç»„ï¼š${attr.gid}</option>
`;
                    this.activity_filter_group_selector.insertAdjacentHTML("beforeend", html);
                    const option = this.activity_filter_group_selector.querySelector(":scope > option:last-of-type");
                }

                fetch_group_list() {
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_group_list()
                        .then(result => {
                            if (this.closed) return;
                            this.remove_all_group_items();
                            for (const resultElement of result) {
                                this.add_group_item(resultElement);
                            }
                            this.remove_loading_mark();
                            this.fetch_list();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

                add_item(attr) {
                    let tree_item = {
                        clickable: false,
                        columns: this._attrs2columns(attr),
                    };
                    this.tree1.add_item(tree_item);
                }

                fetch_list() {
                    this.tree1.remove_all_items();

                    const selected_group = this.activity_filter_group_selector.value;
                    if (!selected_group) return;
                    let selected_date = this.activity_filter_date.value;
                    if (!form_field_checker.ffc_string_date(selected_date)) return;
                    selected_date = format_timestamp_utc(Math.floor(new Date(selected_date).getTime() / 1000) - seconds_of_eight_hours);

                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_activity(selected_group === "æ‰€æœ‰ç”¨æˆ·" ? null : selected_group, selected_date)
                        .then(result => {
                            if (this.closed) return;
                            for (const resultElement of result) {
                                this.add_item(resultElement);
                            }
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

            },

            users: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    this.tree1.remove()
                    super.close_page();
                }

                open_page() {
                    super.open_page();

                    let html = `
<button class="btn-back-to-left-aside">â®Œ</button>
<div class="users-toolbar">
    <button class="btn-delete-selected" style="display:none">ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤</button>
    <label class="select-all-label" style="display:none">
        <input type="checkbox" class="select-all-checkbox"> å…¨é€‰
    </label>
</div>
`;
                    this.container.insertAdjacentHTML("beforeend", html);

                    this.e_btn_back_to_left_aside = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    this.e_btn_back_to_left_aside.addEventListener("click", (event) => {
                        this.client.close_content_page();
                    });

                    this.e_btn_delete_selected = this.container.querySelector(":scope button.btn-delete-selected");
                    this.e_btn_delete_selected.addEventListener("click", (event) => this.delete_selected());

                    this.e_select_all_label = this.container.querySelector(":scope label.select-all-label");
                    this.e_select_all_checkbox = this.container.querySelector(":scope input.select-all-checkbox");
                    this.e_select_all_checkbox.addEventListener("change", (event) => this.toggle_select_all());

                    this.selected_uids = new Set();

                    const tree_headers = [
                        {text: "", width: 40,},
                        {text: "â˜‘", width: 30,},
                        {text: "çŠ¶æ€", width: 60,},
                        {text: "åç§°", width: 120,},
                        {text: "ä¸Šæ¬¡åœ¨çº¿", width: 210,},
                        {text: "æ‰€å±ç»„", width: -1,},
                    ];
                    this.tree1 = new TreeWidget(this.container, tree_headers, this.fill_tree_menu.bind(this))
                    this.tree1.show();


                    this.fetch_list();
                }

                toggle_select_all() {
                    const checked = this.e_select_all_checkbox.checked;
                    this.tree1.tree_items.forEach(item => {
                        const checkbox = item.querySelector("input[type='checkbox']");
                        if (checkbox) {
                            checkbox.checked = checked;
                            const uid = item.attr.columns[3].text;
                            if (checked) {
                                this.selected_uids.add(uid);
                            } else {
                                this.selected_uids.delete(uid);
                            }
                        }
                    });
                    this.update_delete_button();
                }

                update_delete_button() {
                    if (this.selected_uids.size > 0) {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤ (${this.selected_uids.size})`;
                    } else {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤`;
                    }
                }

                delete_selected() {
                    if (this.selected_uids.size === 0) {
                        alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„ç”¨æˆ·");
                        return;
                    }
                    
                    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${this.selected_uids.size} ä¸ªç”¨æˆ·å—ï¼Ÿ`)) return;

                    const uids = Array.from(this.selected_uids);
                    this.loading_mark.show();
                    
                    const deletePromises = uids.map(uid => 
                        this.client.subviews.admin.delete_user(uid)
                    );

                    Promise.all(deletePromises)
                        .then(() => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        })
                        .catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                fill_tree_menu(clicking_info) {
                    const items = [];
                    if (clicking_info.direction === TreeWidget.clicking_direction.header)
                        return items;

                    items.push(
                        {
                            type: "button",
                            text: "åˆ›å»º",
                            callback: event => this.new_user(),
                        },
                        {type: "section", text: "",},
                        // {
                        //     type: "button",
                        //     text: "ä¸Šçº¿æƒ…å†µ",
                        //     callback: event => this.activity_user(clicking_info),
                        // },
                        // {type: "section", text: "",},
                        {
                            type: "button",
                            text: "ç¼–è¾‘",
                            callback: event => this.edit_user(clicking_info),
                        },
                        {type: "section", text: "",},
                        {
                            type: "button",
                            text: "åˆ é™¤",
                            callback: event => this.delete_user(clicking_info),
                        },
                    )

                    if (clicking_info.direction !== TreeWidget.clicking_direction.item) {
                        items[2].disabled = true;
                        items[4].disabled = true;
                        // items[6].disabled = true;
                    }

                    return items;
                }

                _attrs2columns(attr) {
                    const left_for_day = !form_field_checker.ffc_int(attr.last_login_time) ? true : attr.last_login_time < (Date.now() / 1000) - seconds_of_one_day;
                    let text_last_login_time = format_timestamp_utc8(attr.last_login_time);
                    if (left_for_day) text_last_login_time += "ï¼ˆ>1å¤©ï¼‰";
                    return [
                        {text: this.tree1.tree_items.length + 1, selectable: false,},
                        {text: "", selectable: false, checkbox: true,},
                        {
                            text: attr.disabled ? "æš‚åœ" : "æ­£å¸¸",
                            selectable: false,
                            inactive: attr.disabled
                        },
                        {text: attr.uid, selectable: true,},
                        {
                            text: text_last_login_time, selectable: true,
                            highlight: left_for_day,
                        },
                        {text: `${attr.groups.length}ä¸ªï¼›${attr.groups.join("ã€")}`, selectable: true,},
                    ];
                }

                add_item(attr) {
                    const itemCount = this.tree1.tree_items.length;
                    
                    let tree_item = {
                        clickable: false,
                        columns: this._attrs2columns(attr),
                    };
                    this.tree1.add_item(tree_item);
                    
                    if (itemCount === 0) {
                        this.e_btn_delete_selected.style.display = "";
                        this.e_select_all_label.style.display = "";
                    }
                    
                    const addedItem = this.tree1.tree_items[this.tree1.tree_items.length - 1];
                    if (addedItem) {
                        const checkbox = addedItem.querySelector("input[type='checkbox']");
                        if (checkbox) {
                            const uid = attr.uid;
                            checkbox.addEventListener("change", (event) => {
                                if (checkbox.checked) {
                                    this.selected_uids.add(uid);
                                } else {
                                    this.selected_uids.delete(uid);
                                }
                                this.update_delete_button();
                            });
                        }
                    }
                }

                update_item(tree_item, user_attr) {
                    const columns = this._attrs2columns(user_attr);
                    columns[0] = tree_item.attr.columns[0];
                    tree_item.attr.columns = columns;
                    this.tree1.update_item(tree_item);
                }

                fetch_list() {
                    this.selected_uids.clear();
                    this.e_select_all_checkbox.checked = false;
                    this.update_delete_button();
                    this.tree1.remove_all_items();
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_user_list()
                        .then(result => {
                            if (this.closed) return;
                            this.e_btn_delete_selected.style.display = "none";
                            this.e_select_all_label.style.display = "none";
                            for (const resultElement of result) {
                                this.add_item(resultElement);
                            }
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

                _check_form(attr, is_edit = false) {
                    if (!form_field_checker.ffc_bool(attr["åœç”¨"])) throw new Error("åœç”¨");
                    if (!form_field_checker.ffc_string(attr["åç§°"])) throw new Error("åç§°");
                    if (!form_field_checker.ffc_string(attr["å¯†ç "], is_edit)) throw new Error("å¯†ç ");
                    if (is_edit) {
                        if (attr["å¯†ç "] === "ä¸å˜") attr["å¯†ç "] = "";
                    }

                    const free_space = attr["å‚¨å­˜ç©ºé—´"];
                    let free_space_number = /^(\d+)mb$/.exec(free_space.toString())
                    if (!form_field_checker.ffc_string(free_space) || !free_space_number) throw new Error("å‚¨å­˜ç©ºé—´");
                    free_space_number = parseInt(free_space_number[1]);
                    if (!form_field_checker.ffc_int(free_space_number)) throw new Error("å‚¨å­˜ç©ºé—´-æ•°å€¼");
                    attr["å‚¨å­˜ç©ºé—´"] = free_space_number;

                    const groups = attr["æ‰€å±ç»„"];
                    if (!form_field_checker.ffc_array(groups, true)) throw new Error("æ‰€å±ç»„");
                    for (const group of groups) {
                        if (!form_field_checker.ffc_string(group)) throw new Error("æ‰€å±ç»„-ç»„å");
                    }

                    if (!form_field_checker.ffc_bool(attr["å…è®¸ä¸»åŠ¨ä¸æ‰€æœ‰ç”¨æˆ·é€šä¿¡"])) throw new Error("å…è®¸ä¸»åŠ¨ä¸æ‰€æœ‰ç”¨æˆ·é€šä¿¡");

                    const contact_groups = attr["å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç»„é€šä¿¡"];
                    if (!form_field_checker.ffc_array(contact_groups, true)) throw new Error("å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç»„é€šä¿¡");
                    for (const contact_group of contact_groups) {
                        if (!form_field_checker.ffc_string(contact_group)) throw new Error("å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç»„é€šä¿¡-ç»„å");
                    }

                    const contact_users = attr["å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç”¨æˆ·é€šä¿¡"];
                    if (!form_field_checker.ffc_array(contact_users, true)) throw new Error("å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç”¨æˆ·é€šä¿¡");
                    for (const contact_user of contact_users) {
                        if (!form_field_checker.ffc_string(contact_user)) throw new Error("å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç”¨æˆ·é€šä¿¡-ç”¨æˆ·å");
                    }

                    if (!form_field_checker.ffc_bool(attr["å…è®¸ç®¡ç†æ‰€æœ‰ç”¨æˆ·çš„ç½‘ç›˜"])) throw new Error("å…è®¸ç®¡ç†æ‰€æœ‰ç”¨æˆ·çš„ç½‘ç›˜");
                }

                #_template = {
                    "åœç”¨": false,
                    "åç§°": "",
                    "å¯†ç ": "",
                    "å‚¨å­˜ç©ºé—´": "5120mb",
                    "æ‰€å±ç»„": [],
                    "å…è®¸ä¸»åŠ¨ä¸æ‰€æœ‰ç”¨æˆ·é€šä¿¡": true,
                    "å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç»„é€šä¿¡": [],
                    "å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç”¨æˆ·é€šä¿¡": [],
                    "å…è®¸ç®¡ç†æ‰€æœ‰ç”¨æˆ·çš„ç½‘ç›˜": false,
                }

                new_user() {

                    const _template = [{...this.#_template},]

                    let form = [
                        {type: "title", label: "åˆ›å»ºç”¨æˆ·ï¼š"},
                        {type: "textarea", label: "", value: JSON.stringify(_template, null, 2),},
                    ];

                    const confirm_callback = (fm,) => {
                        fm.collect_data();

                        try {
                            let _template = JSON.parse(form[1].value)

                            if (!form_field_checker.ffc_array(_template)) throw new Error("array");
                            for (const attr of _template) {
                                this._check_form(attr);
                            }

                            // fm.remove();
                            this._new_user(fm, _template);

                        } catch (e) {
                            MessageMark.report(e, fm.rect)
                        }

                    }

                    FormMark.get_global_input(form, confirm_callback)
                }

                _new_user(fm, form) {
                    // this.loading_mark.show();
                    fm.loading_mark = new LoadingMark(fm.rect);
                    fm.loading_mark.show();
                    this.client.subviews.admin.new_user(form)
                        .then(result => {
                            if (this.closed) return;
                            for (const resultElement of result) {
                                this.add_item(resultElement);
                            }
                            // this.remove_loading_mark();
                            fm.loading_mark.remove();
                            fm.remove();
                        }).catch(error => {
                        if (this.closed) return;
                        // this.remove_loading_mark();
                        fm.loading_mark.remove();
                        MessageMark.report(error, fm.rect);
                    });
                }

                activity_user(clicking_info) {

                }

                edit_user(clicking_info) {
                    const uid = clicking_info.tree_item.attr.columns[3].text;
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_user_attr(uid)
                        .then(result => {
                            if (this.closed) return;
                            this._edit_user(clicking_info, result);
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark();
                        MessageMark.report(error);
                    });
                }

                _edit_user(clicking_info, attr,) {
                    const _template = {...this.#_template}

                    _template["åœç”¨"] = Boolean(attr.disabled);
                    _template["åç§°"] = attr.uid;
                    _template["å¯†ç "] = "ä¸å˜";
                    _template["å‚¨å­˜ç©ºé—´"] = `${attr.free_space}mb`;
                    _template["æ‰€å±ç»„"] = attr.groups;
                    _template["å…è®¸ä¸»åŠ¨ä¸æ‰€æœ‰ç”¨æˆ·é€šä¿¡"] = Boolean(attr.contact_any);
                    _template["å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç»„é€šä¿¡"] = attr.contact_groups;
                    _template["å…è®¸ä¸»åŠ¨ä¸è¿™äº›ç”¨æˆ·é€šä¿¡"] = attr.contact_users;
                    _template["å…è®¸ç®¡ç†æ‰€æœ‰ç”¨æˆ·çš„ç½‘ç›˜"] = Boolean(attr.manage_drive);

                    let form = [
                        {type: "title", label: `ç¼–è¾‘ç”¨æˆ·ï¼š${attr.uid}`},
                        {type: "textarea", label: "", value: JSON.stringify(_template, null, 2),},
                    ];

                    const confirm_callback = (fm,) => {
                        fm.collect_data();

                        try {
                            let _template = JSON.parse(form[1].value)

                            if (!form_field_checker.ffc_object(_template)) throw new Error("object");
                            this._check_form(_template, true);

                            // fm.remove();
                            this.__edit_user(clicking_info, fm, _template, attr.uid);

                        } catch (e) {
                            MessageMark.report(e, fm.rect)
                        }

                    }

                    FormMark.get_global_input(form, confirm_callback)
                }

                __edit_user(clicking_info, fm, form, old_uid) {
                    fm.loading_mark = new LoadingMark(fm.rect);
                    fm.loading_mark.show();
                    this.client.subviews.admin.edit_user(form, old_uid)
                        .then(result => {
                            if (this.closed) return;
                            this.update_item(clicking_info.tree_item, result);
                            // this.remove_loading_mark();
                            fm.loading_mark.remove();
                            fm.remove();
                        }).catch(error => {
                        if (this.closed) return;
                        // this.remove_loading_mark();
                        fm.loading_mark.remove();
                        MessageMark.report(error, fm.rect);
                    });
                }

                delete_user(clicking_info) {
                    const uid = clicking_info.tree_item.attr.columns[3].text;
                    MessageMark.confirm(`åˆ é™¤ç”¨æˆ·ï¼š${uid}`, null, null, () => {
                        this._delete_user(clicking_info.tree_item, uid);
                    },)
                }

                _delete_user(tree_item, uid,) {
                    this.loading_mark.show();
                    this.client.subviews.admin.delete_user(uid)
                        .then(result => {
                            if (this.closed) return;
                            this.tree1.remove_item(tree_item)
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }
            },

            groups: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    this.tree1.remove()
                    super.close_page();
                }

                open_page() {
                    super.open_page();

                    let html = `
<button class="btn-back-to-left-aside">â®Œ</button>
<div class="groups-toolbar">
    <button class="btn-delete-selected" style="display:none">ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤</button>
    <label class="select-all-label" style="display:none">
        <input type="checkbox" class="select-all-checkbox"> å…¨é€‰
    </label>
</div>
`;
                    this.container.insertAdjacentHTML("beforeend", html);

                    this.e_btn_back_to_left_aside = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    this.e_btn_back_to_left_aside.addEventListener("click", (event) => {
                        this.client.close_content_page();
                    });

                    this.e_btn_delete_selected = this.container.querySelector(":scope button.btn-delete-selected");
                    this.e_btn_delete_selected.addEventListener("click", (event) => this.delete_selected());

                    this.e_select_all_label = this.container.querySelector(":scope label.select-all-label");
                    this.e_select_all_checkbox = this.container.querySelector(":scope input.select-all-checkbox");
                    this.e_select_all_checkbox.addEventListener("change", (event) => this.toggle_select_all());

                    this.selected_gids = new Set();

                    const tree_headers = [
                        {text: "", width: 40,},
                        {text: "â˜‘", width: 30,},
                        {text: "åç§°", width: 120,},
                        {text: "æˆå‘˜", width: -1,},
                    ];
                    this.tree1 = new TreeWidget(this.container, tree_headers, this.fill_tree_menu.bind(this))
                    this.tree1.show();

                    this.fetch_list();
                }

                toggle_select_all() {
                    const checked = this.e_select_all_checkbox.checked;
                    this.tree1.tree_items.forEach(item => {
                        const checkbox = item.querySelector("input[type='checkbox']");
                        if (checkbox) {
                            checkbox.checked = checked;
                            const gid = item.attr.columns[2].text;
                            if (checked) {
                                this.selected_gids.add(gid);
                            } else {
                                this.selected_gids.delete(gid);
                            }
                        }
                    });
                    this.update_delete_button();
                }

                update_delete_button() {
                    if (this.selected_gids.size > 0) {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤ (${this.selected_gids.size})`;
                    } else {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤`;
                    }
                }

                delete_selected() {
                    if (this.selected_gids.size === 0) {
                        alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„ç”¨æˆ·ç»„");
                        return;
                    }
                    
                    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${this.selected_gids.size} ä¸ªç”¨æˆ·ç»„å—ï¼Ÿ`)) return;

                    const gids = Array.from(this.selected_gids);
                    this.loading_mark.show();
                    
                    const deletePromises = gids.map(gid => 
                        this.client.subviews.admin.delete_group(gid)
                    );

                    Promise.all(deletePromises)
                        .then(() => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        })
                        .catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                fill_tree_menu(clicking_info) {
                    const items = [];
                    if (clicking_info.direction === TreeWidget.clicking_direction.header)
                        return items;

                    items.push(
                        {
                            type: "button",
                            text: "åˆ›å»º",
                            callback: event => this.new_group(),
                        },
                        {type: "section", text: "",},
                        // {
                        //     type: "button",
                        //     text: "ä¸Šçº¿æƒ…å†µ",
                        //     callback: event => this.activity_group(clicking_info),
                        // },
                        // {type: "section", text: "",},
                        {
                            type: "button",
                            text: "ç¼–è¾‘",
                            callback: event => this.edit_group(clicking_info),
                        },
                        {
                            type: "button",
                            text: "åˆ é™¤",
                            callback: event => this.delete_group(clicking_info),
                        },
                    )

                    if (clicking_info.direction !== TreeWidget.clicking_direction.item) {
                        items[2].disabled = true;
                        // items[4].disabled = true;
                    }

                    return items;
                }

                _attrs2columns(attr) {
                    return [
                        {text: this.tree1.tree_items.length + 1, selectable: false,},
                        {text: "", selectable: false, checkbox: true,},
                        {text: attr.gid, selectable: true,},
                        {text: `${attr.users.length}äººï¼›${attr.users.join("ã€")}`, selectable: true,},
                    ];
                }

                add_item(attr) {
                    const itemCount = this.tree1.tree_items.length;
                    
                    let tree_item = {
                        clickable: false,
                        columns: this._attrs2columns(attr),
                    };
                    this.tree1.add_item(tree_item);
                    
                    if (itemCount === 0) {
                        this.e_btn_delete_selected.style.display = "";
                        this.e_select_all_label.style.display = "";
                    }
                    
                    const addedItem = this.tree1.tree_items[this.tree1.tree_items.length - 1];
                    if (addedItem) {
                        const checkbox = addedItem.querySelector("input[type='checkbox']");
                        if (checkbox) {
                            const gid = attr.gid;
                            checkbox.addEventListener("change", (event) => {
                                if (checkbox.checked) {
                                    this.selected_gids.add(gid);
                                } else {
                                    this.selected_gids.delete(gid);
                                }
                                this.update_delete_button();
                            });
                        }
                    }
                }

                update_item(tree_item, group_attr) {
                    const columns = this._attrs2columns(group_attr);
                    columns[0] = tree_item.attr.columns[0];
                    tree_item.attr.columns = columns;
                    this.tree1.update_item(tree_item);
                }

                fetch_list() {
                    this.selected_gids.clear();
                    this.e_select_all_checkbox.checked = false;
                    this.update_delete_button();
                    this.tree1.remove_all_items();
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_group_list()
                        .then(result => {
                            if (this.closed) return;
                            this.e_btn_delete_selected.style.display = "none";
                            this.e_select_all_label.style.display = "none";
                            for (const resultElement of result) {
                                this.add_item(resultElement);
                            }
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

                #_template = {
                    "åç§°": "",
                }

                new_group() {

                    const _template = [{...this.#_template},]

                    let form = [
                        {type: "title", label: "åˆ›å»ºåˆ†ç»„ï¼š"},
                        {type: "textarea", label: "", value: JSON.stringify(_template, null, 2),},
                    ];

                    const confirm_callback = (fm,) => {
                        fm.collect_data();

                        try {
                            let _template = JSON.parse(form[1].value)

                            if (!form_field_checker.ffc_array(_template)) throw new Error("array");
                            for (const attr of _template) {
                                if (!form_field_checker.ffc_string(attr["åç§°"])) throw new Error("åç§°");
                            }

                            fm.remove();
                            this._new_group(_template);

                        } catch (e) {
                            MessageMark.report(e, fm.rect)
                        }

                    }

                    FormMark.get_global_input(form, confirm_callback)
                }

                _new_group(form) {
                    this.loading_mark.show();
                    this.client.subviews.admin.new_group(form)
                        .then(result => {
                            if (this.closed) return;
                            for (const resultElement of result) {
                                this.add_item(resultElement);
                            }
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

                activity_group(clicking_info) {

                }

                edit_group(clicking_info) {
                    const gid = clicking_info.tree_item.attr.columns[2].text;
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_group_attr(gid)
                        .then(result => {
                            if (this.closed) return;
                            this._edit_group(clicking_info, result);
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark();
                        MessageMark.report(error);
                    });
                }

                _edit_group(clicking_info, attr,) {
                    const _template = {...this.#_template}

                    _template["åç§°"] = attr.gid;

                    let form = [
                        {type: "title", label: "ç¼–è¾‘åˆ†ç»„ï¼š"},
                        {type: "textarea", label: "", value: JSON.stringify(_template, null, 2),},
                    ];

                    const confirm_callback = (fm,) => {
                        fm.collect_data();

                        try {
                            let _template = JSON.parse(form[1].value)

                            if (!form_field_checker.ffc_string(_template["åç§°"])) throw new Error("åç§°");

                            // fm.remove();
                            this.__edit_group(clicking_info, fm, _template, attr.gid);

                        } catch (e) {
                            MessageMark.report(e, fm.rect)
                        }

                    }

                    FormMark.get_global_input(form, confirm_callback)
                }

                __edit_group(clicking_info, fm, form, old_gid) {
                    fm.loading_mark = new LoadingMark(fm.rect);
                    fm.loading_mark.show();
                    this.client.subviews.admin.edit_group(form, old_gid)
                        .then(result => {
                            if (this.closed) return;
                            this.update_item(clicking_info.tree_item, result);
                            // this.remove_loading_mark();
                            fm.loading_mark.remove();
                            fm.remove();
                        }).catch(error => {
                        if (this.closed) return;
                        // this.remove_loading_mark();
                        fm.loading_mark.remove();
                        MessageMark.report(error, fm.rect);
                    });
                }

                delete_group(clicking_info) {
                    const gid = clicking_info.tree_item.attr.columns[2].text;
                    MessageMark.confirm(`åˆ é™¤åˆ†ç»„ï¼š${gid}`, null, null, () => {
                        this._delete_group(clicking_info.tree_item, gid);
                    },)
                }

                _delete_group(tree_item, gid,) {
                    this.loading_mark.show();
                    this.client.subviews.admin.delete_group(gid)
                        .then(result => {
                            if (this.closed) return;
                            this.tree1.remove_item(tree_item)
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }
            },

            candidate_words: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    if (this.tree1) this.tree1.remove()
                    super.close_page();
                }

                open_page() {
                    super.open_page();

                    let html = `
<button class="btn-back-to-left-aside">â®Œ</button>
<div class="candidate-words-toolbar">
    <button class="btn-add-candidate">â• æ·»åŠ å€™é€‰è¯</button>
    <button class="btn-import-candidates">ğŸ“¥ æ‰¹é‡å¯¼å…¥</button>
    <button class="btn-reset-counts">ğŸ”„ é‡ç½®é¢‘ç‡</button>
    <button class="btn-delete-selected" style="display:none">ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤</button>
</div>
<div class="candidate-words-filter">
    <label class="select-all-label" style="display:none">
        <input type="checkbox" class="select-all-checkbox"> å…¨é€‰
    </label>
    <input type="text" class="filter-input" placeholder="ç­›é€‰å€™é€‰è¯...">
</div>
<div class="candidate-words-list"></div>
`;
                    this.container.insertAdjacentHTML("beforeend", html);

                    this.e_btn_back = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    this.e_btn_back.addEventListener("click", (event) => {
                        this.client.close_content_page();
                    });

                    this.e_btn_add = this.container.querySelector(":scope button.btn-add-candidate");
                    this.e_btn_add.addEventListener("click", (event) => this.add_candidate());

                    this.e_btn_import = this.container.querySelector(":scope button.btn-import-candidates");
                    this.e_btn_import.addEventListener("click", (event) => this.import_candidates());

                    this.e_btn_reset = this.container.querySelector(":scope button.btn-reset-counts");
                    this.e_btn_reset.addEventListener("click", (event) => this.reset_counts());

                    this.e_btn_delete_selected = this.container.querySelector(":scope button.btn-delete-selected");
                    this.e_btn_delete_selected.addEventListener("click", (event) => this.delete_selected());

                    this.e_select_all_label = this.container.querySelector(":scope label.select-all-label");
                    this.e_select_all_checkbox = this.container.querySelector(":scope input.select-all-checkbox");
                    this.e_select_all_checkbox.addEventListener("change", (event) => this.toggle_select_all());

                    this.e_filter_input = this.container.querySelector(":scope input.filter-input");
                    this.e_filter_input.addEventListener("input", (event) => this.filter_list());

                    this.e_list = this.container.querySelector(":scope div.candidate-words-list");

                    this.fetch_list();
                }

                filter_list() {
                    const v = this.e_filter_input.value.trim().toLowerCase();
                    const items = this.e_list.querySelectorAll(".candidate-word-item");
                    items.forEach(item => {
                        const word = item.dataset.word.toLowerCase();
                        if (v === "" || word.includes(v)) {
                            item.style.display = "";
                        } else {
                            item.style.display = "none";
                        }
                    });
                }

                add_candidate() {
                    const word = prompt("è¯·è¾“å…¥å€™é€‰è¯ï¼š");
                    if (!word || !word.trim()) return;
                    
                    this.loading_mark.show();
                    this.client.subviews.admin.add_candidate_word(word.trim())
                        .then(result => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                import_candidates() {
                    const words = prompt("è¯·è¾“å…¥å€™é€‰è¯ï¼ˆå¤šä¸ªç”¨ç©ºæ ¼æˆ–|åˆ†éš”ï¼‰ï¼š");
                    if (!words || !words.trim()) return;
                    
                    const word_list = words.split(/[\n |]/).map(w => w.trim()).filter(w => w);
                    if (word_list.length === 0) return;

                    this.loading_mark.show();
                    this.client.subviews.admin.add_candidate_words(word_list)
                        .then(result => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                edit_candidate(item, word) {
                    const new_word = prompt("è¯·è¾“å…¥æ–°çš„å€™é€‰è¯ï¼š", word);
                    if (!new_word || !new_word.trim()) return;
                    if (new_word.trim() === word) return;

                    this.loading_mark.show();
                    this.client.subviews.admin.edit_candidate_word(word, new_word.trim())
                        .then(result => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                delete_candidate(item, word) {
                    if (!confirm(`ç¡®å®šè¦åˆ é™¤å€™é€‰è¯"${word}"å—ï¼Ÿ`)) return;

                    this.loading_mark.show();
                    this.client.subviews.admin.delete_candidate_word(word)
                        .then(result => {
                            this.remove_loading_mark();
                            item.remove();
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                reset_counts() {
                    if (!confirm("ç¡®å®šè¦é‡ç½®æ‰€æœ‰å€™é€‰è¯çš„ä½¿ç”¨é¢‘ç‡å—ï¼Ÿ")) return;

                    this.loading_mark.show();
                    this.client.subviews.admin.reset_candidate_word_counts()
                        .then(result => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                fetch_list() {
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_candidate_word_list()
                        .then(result => {
                            if (this.closed) return;
                            this.render_list(result);
                            this.remove_loading_mark();
                        }).catch(error => {
                            if (this.closed) return;
                            this.remove_loading_mark()
                            MessageMark.report(error);
                        });
                }

                render_list(list) {
                    this.e_list.innerHTML = "";
                    this.selected_words = new Set();
                    
                    if (list.length > 0) {
                        this.e_btn_delete_selected.style.display = "";
                        this.e_select_all_label.style.display = "";
                    } else {
                        this.e_btn_delete_selected.style.display = "none";
                        this.e_select_all_label.style.display = "none";
                    }
                    
                    list.forEach((item, index) => {
                        const div = document.createElement("div");
                        div.className = "candidate-word-item";
                        div.dataset.word = item.word;
                        div.innerHTML = `
                            <input type="checkbox" class="candidate-checkbox">
                            <span class="candidate-index">${index + 1}</span>
                            <span class="candidate-word">${item.word}</span>
                            <span class="candidate-count">${item.use_count || 0}</span>
                            <span class="candidate-actions">
                                <button class="btn-edit">ç¼–è¾‘</button>
                                <button class="btn-delete">åˆ é™¤</button>
                            </span>
                        `;
                        
                        const checkbox = div.querySelector(".candidate-checkbox");
                        checkbox.addEventListener("change", (event) => {
                            if (checkbox.checked) {
                                this.selected_words.add(item.word);
                            } else {
                                this.selected_words.delete(item.word);
                            }
                            this.update_delete_button();
                        });
                        
                        div.querySelector(".btn-edit").addEventListener("click", () => {
                            this.edit_candidate(div, item.word);
                        });
                        div.querySelector(".btn-delete").addEventListener("click", () => {
                            this.delete_candidate(div, item.word);
                        });
                        
                        this.e_list.appendChild(div);
                    });
                }

                toggle_select_all() {
                    const checked = this.e_select_all_checkbox.checked;
                    const checkboxes = this.e_list.querySelectorAll(".candidate-checkbox");
                    checkboxes.forEach(cb => {
                        cb.checked = checked;
                    });
                    
                    if (checked) {
                        const items = this.e_list.querySelectorAll(".candidate-word-item");
                        items.forEach(item => {
                            this.selected_words.add(item.dataset.word);
                        });
                    } else {
                        this.selected_words.clear();
                    }
                    this.update_delete_button();
                }

                update_delete_button() {
                    if (this.selected_words.size > 0) {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤ (${this.selected_words.size})`;
                    } else {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤`;
                    }
                }

                delete_selected() {
                    if (this.selected_words.size === 0) {
                        alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„å€™é€‰è¯");
                        return;
                    }
                    
                    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${this.selected_words.size} ä¸ªå€™é€‰è¯å—ï¼Ÿ`)) return;

                    const words = Array.from(this.selected_words);
                    this.loading_mark.show();
                    
                    const deletePromises = words.map(word => 
                        this.client.subviews.admin.delete_candidate_word(word)
                    );

                    Promise.all(deletePromises)
                        .then(() => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        })
                        .catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }
            },

            all_people_notice: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    if (this.e_list) this.e_list.remove();
                    if (this.e_editor) this.e_editor.remove();
                    super.close_page();
                }

                open_page() {
                    super.open_page();

                    let html = `
<button class="btn-back-to-left-aside">â®Œ</button>
<div class="all-people-notice-toolbar">
    <button class="btn-add-notice">â• æ·»åŠ é€šçŸ¥</button>
    <button class="btn-delete-selected" style="display:none">ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤</button>
</div>
<div class="all-people-notice-filter">
    <label class="select-all-label" style="display:none">
        <input type="checkbox" class="select-all-checkbox"> å…¨é€‰
    </label>
    <input type="text" class="filter-input" placeholder="ç­›é€‰é€šçŸ¥...">
</div>
<div class="all-people-notice-list"></div>
<div class="all-people-notice-editor">
    <h3 class="editor-title">æ·»åŠ é€šçŸ¥</h3>
    <textarea class="editor-content" placeholder="è¯·è¾“å…¥é€šçŸ¥å†…å®¹"></textarea>
    <label class="editor-enabled">
        <input type="checkbox" class="editor-enabled-checkbox"> å¯ç”¨æ­¤é€šçŸ¥
    </label>
    <div class="editor-buttons">
        <button class="btn-cancel">å–æ¶ˆ</button>
        <button class="btn-save">ä¿å­˜</button>
    </div>
</div>
`;
                    this.container.insertAdjacentHTML("beforeend", html);

                    this.e_btn_back = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    if (this.e_btn_back) {
                        this.e_btn_back.addEventListener("click", (event) => {
                            this.client.close_content_page();
                        });
                    }

                    this.e_btn_add = this.container.querySelector(":scope button.btn-add-notice");
                    if (this.e_btn_add) {
                        this.e_btn_add.addEventListener("click", (event) => this.show_editor());
                    }

                    this.e_btn_delete_selected = this.container.querySelector(":scope button.btn-delete-selected");
                    if (this.e_btn_delete_selected) {
                        this.e_btn_delete_selected.addEventListener("click", (event) => this.delete_selected());
                    }

                    this.e_select_all_label = this.container.querySelector(":scope label.select-all-label");
                    this.e_select_all_checkbox = this.container.querySelector(":scope input.select-all-checkbox");
                    if (this.e_select_all_checkbox) {
                        this.e_select_all_checkbox.addEventListener("change", (event) => this.toggle_select_all());
                    }

                    this.selected_ids = new Set();

                    this.e_list = this.container.querySelector(":scope div.all-people-notice-list");
                    this.e_editor = this.container.querySelector(":scope div.all-people-notice-editor");
                    this.e_editor_content = this.container.querySelector(":scope textarea.editor-content");
                    this.e_editor_enabled = this.container.querySelector(":scope input.editor-enabled-checkbox");
                    this.e_editor_title = this.container.querySelector(":scope h3.editor-title");
                    this.e_btn_save = this.container.querySelector(":scope button.btn-save");
                    this.e_btn_cancel = this.container.querySelector(":scope button.btn-cancel");

                    this.e_filter_input = this.container.querySelector(":scope input.filter-input");
                    if (this.e_filter_input) {
                        this.e_filter_input.addEventListener("input", (event) => this.filter_list());
                    }

                    if (this.e_btn_save) {
                        this.e_btn_save.addEventListener("click", (event) => this.save_notice());
                    }
                    if (this.e_btn_cancel) {
                        this.e_btn_cancel.addEventListener("click", (event) => this.hide_editor());
                    }

                    this.editing_id = null;
                    this.fetch_list();
                }

                filter_list() {
                    if (!this.e_filter_input || !this.e_list) return;
                    const v = this.e_filter_input.value.trim().toLowerCase();
                    const items = this.e_list.querySelectorAll(".all-people-notice-item");
                    items.forEach(item => {
                        const content = item.dataset.content.toLowerCase();
                        if (v === "" || content.includes(v)) {
                            item.style.display = "";
                        } else {
                            item.style.display = "none";
                        }
                    });
                }

                show_editor(item = null) {
                    if (!this.e_editor || !this.e_editor_title || !this.e_editor_content || !this.e_editor_enabled) {
                        console.error("ç¼–è¾‘å™¨å…ƒç´ æœªåˆå§‹åŒ–");
                        return;
                    }
                    this.editing_id = item ? item.id : null;
                    if (item) {
                        this.e_editor_title.textContent = "ç¼–è¾‘é€šçŸ¥";
                        this.e_editor_content.value = item.content;
                        this.e_editor_enabled.checked = item.enabled === 1;
                    } else {
                        this.e_editor_title.textContent = "æ·»åŠ é€šçŸ¥";
                        this.e_editor_content.value = "";
                        this.e_editor_enabled.checked = false;
                    }
                    this.e_editor.classList.add("active");
                }

                hide_editor() {
                    if (!this.e_editor) return;
                    this.e_editor.classList.remove("active");
                    this.editing_id = null;
                }

                save_notice() {
                    if (!this.e_editor_content || !this.e_editor_enabled) {
                        alert("ç¼–è¾‘å™¨æœªåˆå§‹åŒ–");
                        return;
                    }
                    const content = this.e_editor_content.value.trim();
                    if (!content) {
                        alert("é€šçŸ¥å†…å®¹ä¸èƒ½ä¸ºç©º");
                        return;
                    }

                    const enabled = this.e_editor_enabled.checked;
                    this.loading_mark.show();

                    const doSave = async () => {
                        if (enabled && this.list && this.list.length > 0) {
                            const disablePromises = this.list
                                .filter(i => i.enabled === 1)
                                .map(i => this.client.subviews.admin.edit_all_people_notice(i.id, i.content, false));
                            await Promise.all(disablePromises);
                        }

                        const promise = this.editing_id
                            ? this.client.subviews.admin.edit_all_people_notice(this.editing_id, content, enabled)
                            : this.client.subviews.admin.add_all_people_notice(content, enabled);

                        promise.then(result => {
                            this.remove_loading_mark();
                            this.hide_editor();
                            this.fetch_list();
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                    };

                    doSave();
                }

                delete_notice(item, id) {
                    if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™æ¡é€šçŸ¥å—ï¼Ÿ")) return;

                    this.loading_mark.show();
                    this.client.subviews.admin.delete_all_people_notice(id)
                        .then(result => {
                            this.remove_loading_mark();
                            item.remove();
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                async toggle_enabled(item, id, current_enabled) {
                    this.loading_mark.show();
                    
                    const newEnabled = !current_enabled;
                    
                    if (newEnabled && this.list && this.list.length > 1) {
                        const disablePromises = this.list
                            .filter(i => i.id !== id && i.enabled === 1)
                            .map(i => this.client.subviews.admin.edit_all_people_notice(i.id, i.content, false));
                        await Promise.all(disablePromises);
                    }
                    
                    this.client.subviews.admin.edit_all_people_notice(id, item.dataset.content, newEnabled)
                        .then(result => {
                            this.remove_loading_mark();
                            // æ›´æ–°æœ¬åœ°æ•°æ®
                            if (this.list) {
                                if (newEnabled && this.list.length > 1) {
                                    this.list.forEach(i => {
                                        if (i.id !== id) {
                                            i.enabled = 0;
                                        }
                                    });
                                }
                                const idx = this.list.findIndex(i => i.id === id);
                                if (idx !== -1) {
                                    this.list[idx].enabled = newEnabled ? 1 : 0;
                                }
                            }
                            this.render_list(this.list);
                        }).catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                fetch_list() {
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_all_people_notice_list()
                        .then(result => {
                            if (this.closed) return;
                            this.list = result;
                            this.render_list(result);
                            this.remove_loading_mark();
                        }).catch(error => {
                            if (this.closed) return;
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }

                render_list(list) {
                    this.e_list.innerHTML = "";
                    this.selected_ids = new Set();

                    if (list.length === 0) {
                        this.e_list.innerHTML = '<div class="all-people-notice-empty">æš‚æ— é€šçŸ¥ï¼Œç‚¹å‡»"æ·»åŠ é€šçŸ¥"åˆ›å»º</div>';
                        this.e_btn_delete_selected.style.display = "none";
                        this.e_select_all_label.style.display = "none";
                        return;
                    }

                    this.e_btn_delete_selected.style.display = "";
                    this.e_select_all_label.style.display = "";

                    list.forEach((item, index) => {
                        const div = document.createElement("div");
                        div.className = `all-people-notice-item ${item.enabled ? 'enabled' : ''}`;
                        div.dataset.content = item.content;
                        div.dataset.id = item.id;
                        div.dataset.enabled = item.enabled;
                        
                        const date = new Date(item.create_time);
                        const date_str = date.toLocaleString();

                        div.innerHTML = `
                            <input type="checkbox" class="notice-checkbox">
                            <div class="notice-item-body">
                                <div class="all-people-notice-content">${item.content}</div>
                                <div class="all-people-notice-meta">
                                    <span>åˆ›å»ºæ—¶é—´: ${date_str}</span>
                                    <div class="all-people-notice-actions">
                                        ${item.enabled 
                                            ? '<button class="btn-disable">ç¦ç”¨</button>' 
                                            : '<button class="btn-enable">å¯ç”¨</button>'}
                                        <button class="btn-edit">ç¼–è¾‘</button>
                                        <button class="btn-delete">åˆ é™¤</button>
                                    </div>
                                </div>
                            </div>
                        `;

                        const checkbox = div.querySelector(".notice-checkbox");
                        checkbox.addEventListener("change", (event) => {
                            if (checkbox.checked) {
                                this.selected_ids.add(item.id);
                            } else {
                                this.selected_ids.delete(item.id);
                            }
                            this.update_delete_button();
                        });

                        const btn_enable = div.querySelector(".btn-enable");
                        if (btn_enable) {
                            btn_enable.addEventListener("click", () => {
                                this.toggle_enabled(div, item.id, false);
                            });
                        }

                        const btn_disable = div.querySelector(".btn-disable");
                        if (btn_disable) {
                            btn_disable.addEventListener("click", () => {
                                this.toggle_enabled(div, item.id, true);
                            });
                        }

                        div.querySelector(".btn-edit").addEventListener("click", () => {
                            this.show_editor(item);
                        });

                        div.querySelector(".btn-delete").addEventListener("click", () => {
                            this.delete_notice(div, item.id);
                        });

                        this.e_list.appendChild(div);
                    });
                }

                toggle_select_all() {
                    const checked = this.e_select_all_checkbox.checked;
                    const checkboxes = this.e_list.querySelectorAll(".notice-checkbox");
                    checkboxes.forEach(cb => {
                        cb.checked = checked;
                    });
                    
                    if (checked) {
                        const items = this.e_list.querySelectorAll(".all-people-notice-item");
                        items.forEach(item => {
                            this.selected_ids.add(parseInt(item.dataset.id));
                        });
                    } else {
                        this.selected_ids.clear();
                    }
                    this.update_delete_button();
                }

                update_delete_button() {
                    if (this.selected_ids.size > 0) {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤ (${this.selected_ids.size})`;
                    } else {
                        this.e_btn_delete_selected.textContent = `ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤`;
                    }
                }

                delete_selected() {
                    if (this.selected_ids.size === 0) {
                        alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é€šçŸ¥");
                        return;
                    }
                    
                    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${this.selected_ids.size} æ¡é€šçŸ¥å—ï¼Ÿ`)) return;

                    const ids = Array.from(this.selected_ids);
                    this.loading_mark.show();
                    
                    const deletePromises = ids.map(id => 
                        this.client.subviews.admin.delete_all_people_notice(id)
                    );

                    Promise.all(deletePromises)
                        .then(() => {
                            this.remove_loading_mark();
                            this.fetch_list();
                        })
                        .catch(error => {
                            this.remove_loading_mark();
                            MessageMark.report(error);
                        });
                }
            },

            disk: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    this.tree1.remove()
                    super.close_page();
                }

                open_page() {
                    super.open_page();

                    let html = `
<button class="btn-back-to-left-aside">â®Œ</button>
`;
                    this.container.insertAdjacentHTML("beforeend", html);

                    this.e_btn_back_to_left_aside = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    this.e_btn_back_to_left_aside.addEventListener("click", (event) => {
                        this.client.close_content_page();
                    });

                    const tree_headers = [
                        {text: "", width: 40,},
                        {text: "ç”¨æˆ·", width: 120,},
                        {text: "ä¸ªäººç©ºé—´", width: 120,},
                        {text: "å·²ä½¿ç”¨", width: -1,},
                    ];
                    this.tree1 = new TreeWidget(this.container, tree_headers, this.fill_tree_menu.bind(this))
                    this.tree1.show();


                    this.fetch_list();
                }

                fill_tree_menu(clicking_info) {
                    const items = [];
                    if (clicking_info.direction === TreeWidget.clicking_direction.header)
                        return items;

                    return items;
                }

                _attrs2columns(attr) {
                    return [
                        {text: this.tree1.tree_items.length + 1, selectable: false,},
                        {text: attr.uid, selectable: true,},
                        {text: `${attr.free_space} MB`, selectable: true,},
                        {text: `${format_bytes(attr.used_space, ["B", "KB", "MB",])}`, selectable: true,},
                    ];
                }

                add_item(attr) {
                    let tree_item = {
                        clickable: false,
                        columns: this._attrs2columns(attr),
                    };
                    this.tree1.add_item(tree_item);
                }

                fetch_list() {
                    this.loading_mark.show();
                    this.client.subviews.admin.fetch_disk_usage()
                        .then(result => {
                            if (this.closed) return;
                            for (const resultElement of result.users) {
                                this.add_item(resultElement);
                            }
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

            },

            status: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                    let html = `
<div class="service-status-rect">

<button class="btn-back-to-left-aside">â®Œ</button>

<div class="service-status-row service-status-row1">
<span>æœåŠ¡ç‰ˆæœ¬ï¼šv${checkin_version}</>
</div>

</div>
`;
                    this.container.insertAdjacentHTML("beforeend", html);
                    this.service_status_rect = this.container.querySelector(":scope div.service-status-rect");

                    this.e_btn_back_to_left_aside = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    this.e_btn_back_to_left_aside.addEventListener("click", (event) => {
                        this.client.close_content_page();
                    });

                }

            },

            backup: class extends _ {
                constructor(client, panel, li) {
                    super(client, panel, li);
                }

                close_page() {
                    super.close_page();
                }

                open_page() {
                    super.open_page();
                    let html = `
<div class="backup-rect">

<button class="btn-back-to-left-aside">â®Œ</button>

<div class="backup-row backup-row1">
<button class="backup-btn-clear-drive">æ¸…ç©ºç½‘ç›˜</button>
<button class="backup-btn-reset">é‡ç½®æœåŠ¡</button>
</div>

<hr>

<div class="backup-row backup-row2">
<button class="backup-btn-backup">å¤‡ä»½ç”¨æˆ·å’Œç»„</button>
<button class="backup-btn-restore">æ¢å¤<input type="file" class="hidden"></button>
<span>æ¢å¤å‰åˆ é™¤æ‰€æœ‰ç”¨æˆ·å’Œç»„ï¼Œé¿å…åç§°å†²çªã€‚</span>
</div>

</div>
`;
                    this.container.insertAdjacentHTML("beforeend", html);
                    this.backup_rect = this.container.querySelector(":scope div.backup-rect");

                    this.e_btn_back_to_left_aside = this.container.querySelector(":scope button.btn-back-to-left-aside");
                    this.e_btn_back_to_left_aside.addEventListener("click", (event) => {
                        this.client.close_content_page();
                    });

                    this.e_btn_clear_drive = this.backup_rect.querySelector(":scope button.backup-btn-clear-drive");
                    this.e_btn_clear_drive.addEventListener("click", (event) => {
                        MessageMark.confirm(`ç¡®å®šæ¸…ç©ºç½‘ç›˜ï¼Ÿ\nï¼ˆç¡®ä¿éœ€è¦ä¿ç•™çš„æ–‡ä»¶éƒ½å·²ä¸‹è½½ã€‚ï¼‰`, null, null, () => {
                            this.clear_drive();
                        },)
                    });

                    this.e_btn_reset = this.backup_rect.querySelector(":scope button.backup-btn-reset");
                    this.e_btn_reset.addEventListener("click", (event) => {
                        MessageMark.confirm(`ç¡®å®šé‡ç½®æœåŠ¡ï¼Ÿ\nï¼ˆå°†åˆ é™¤æ‰€æœ‰ç”¨æˆ·ã€ç»„ã€èŠå¤©è®°å½•ã€ç½‘ç›˜æ–‡ä»¶ç­‰ã€‚ï¼‰`, null, null, () => {
                            this.reset();
                        },)
                    });

                    this.e_btn_backup = this.backup_rect.querySelector(":scope button.backup-btn-backup");
                    this.e_btn_backup.addEventListener("click", (event) => {
                        this.backup();
                    });

                    this.e_btn_restore = this.backup_rect.querySelector(":scope button.backup-btn-restore");
                    this.e_btn_restore__input = this.e_btn_restore.querySelector(":scope input");
                    this.e_btn_restore.addEventListener("click", (event) => {
                        this.e_btn_restore__input.click();
                    });
                    this.e_btn_restore__input.addEventListener('change', (event) => {
                        const file = event.target.files[0];
                        if (file) {
                            this.restore(file);
                        }
                    });

                }

                clear_drive() {
                    this.loading_mark.show();
                    this.client.subviews.admin.clear_drive()
                        .then(result => {
                            if (this.closed) return;
                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

                reset() {
                    this.loading_mark.show();
                    this.client.subviews.admin.drop_tables()
                        .then(result => {
                            if (this.closed) return;
                            this.remove_loading_mark();
                            this.client.logout();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

                static backup_types = [
                    {
                        type: "checkin-users-and-groups", name: "01_Checkinå¤‡ä»½_ç”¨æˆ·å’Œç»„_{date}.json"
                    },
                ];

                backup() {
                    this.loading_mark.show();
                    this.client.subviews.admin.backup()
                        .then(result => {
                            if (this.closed) return;

                            result.type = backend_panel.backup.backup_types[0].type;
                            const name = backend_panel.backup.backup_types[0].name.replace("{date}", date_string_for_fileName());

                            saveFile_from_json(result, name);

                            this.remove_loading_mark();
                        }).catch(error => {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                    });
                }

                restore(file) {
                    this.loading_mark.show();
                    this._restore(file);
                }

                async _restore(file) {
                    if (this.closed) return;
                    try {
                        const data = await readFileAsync(file, "text");
                        const json = JSON.parse(data);
                        if (!form_field_checker.ffc_object(json) || json.type !== backend_panel.backup.backup_types[0].type) {
                            throw new Error("æ— æ•ˆçš„ç”¨æˆ·å’Œç»„å¤‡ä»½æ–‡ä»¶ã€‚");
                        }
                        await this.client.subviews.admin.restore(json);
                        if (this.closed) return;
                        this.remove_loading_mark();
                    } catch (error) {
                        if (this.closed) return;
                        this.remove_loading_mark()
                        MessageMark.report(error);
                        throw error;
                    }
                }

            },

        }

        return {_drive, _chat, dashboard_mail, dashboard_drive, dashboard_chat, dashboard_forum, backend_panel,};
    })()


    function set_textContent_if_different(element, new_text) {
        if (element.textContent !== new_text) {
            element.textContent = new_text;
        }
    }

    /*
    * mdè§£æ
    * */
    const MarkdownResolver = {
        line_object_types: {
            plain_line: "plain_line",
            code_area: "code_area",
        },

        resolve_line: (line_object, line_text) => {
            // line_object will be mutated: set .tokens (AST), .raw, .is_blockquote
            line_object.raw = line_text;

            // detect blockquote (leading '>' with optional spaces)
            const bqMatch = line_text.match(/^\s*>\s?(.*)$/);
            if (bqMatch) {
                line_object.is_blockquote = true;
                line_text = bqMatch[1];
            } else {
                line_object.is_blockquote = false;
            }

            if (!line_object.is_blockquote) {
                const tlMatch = line_text.match(/^\s*(#{1,6})\s?(.*)$/);
                if (tlMatch) {
                    line_object.title_level = tlMatch[1].length;
                    line_text = tlMatch[2];
                } else {
                    line_object.title_level = 0;
                }
            } else {
                line_object.title_level = 0;
            }

            // Tokenize: split into text tokens and marker tokens.
            // Markers we support (priority order): '~~', '**', '__', '`', '*'
            const markers = ['~~', '**', '__', '`', '*',];

            const atings = ["@", "&",];
            let previous_ating;
            const marker_atings_end = " ";

            const tokens = []; // each token: {type: 'text'|'marker', text: string, marker?: string}
            let buf = '';
            for (let i = 0; i < line_text.length;) {
                let matched = false;
                let matched_ating = false;
                for (const m of markers) {
                    if (line_text.startsWith(m, i)) {
                        // flush buffer
                        if (buf.length) {
                            tokens.push({type: 'text', text: buf});
                            buf = '';
                        }
                        tokens.push({type: 'marker', marker: m});
                        i += m.length;
                        matched = true;
                        break;
                    }
                }
                for (const m of atings) {
                    if (line_text.startsWith(m, i)) {
                        // flush buffer
                        if (buf.length) {
                            tokens.push({type: 'text', text: buf});
                            buf = '';
                        }
                        tokens.push({type: 'marker', marker: m});
                        i += m.length;
                        matched_ating = true;
                        previous_ating = m;
                        buf = m;
                        break;
                    }
                }
                if (previous_ating && line_text.startsWith(marker_atings_end, i)) {
                    // flush buffer
                    if (buf.length) {
                        tokens.push({type: 'text', text: buf});
                        buf = '';
                    }
                    tokens.push({type: 'marker', marker: previous_ating});
                    i += marker_atings_end.length;
                    matched_ating = false;
                    previous_ating = null;
                    continue;
                }

                if (!matched && !matched_ating) {
                    buf += line_text[i];
                    i++;
                }
            }
            if (buf.length) tokens.push({type: 'text', text: buf});

            // Recursive parser on tokens -> returns array of AST nodes
            // node forms:
            // {type: 'text', text: '...'}
            // {type: 'code', text: '...'}
            // {type: 'bold'|'italic'|'underline'|'del', children: [...]}
            function parseRange(tokArr, start = 0, end = tokArr.length) {
                const out = [];
                let i = start;
                while (i < end) {
                    const t = tokArr[i];
                    if (t.type === 'text') {
                        out.push({type: 'text', text: t.text});
                        i++;
                        continue;
                    }

                    // marker handling
                    const m = t.marker;
                    // Inline code `...` : treat interior as raw text (no further parsing)
                    const m_attr_map = {
                        '`': {type: "code",},
                        "@": {type: "at", padded: true,},
                        "&": {type: "cite", padded: true,},
                    }
                    if (Object.keys(m_attr_map).includes(m)) {
                        // find next backtick marker
                        let j = i + 1;
                        while (j < end) {
                            if (tokArr[j].type === 'marker' && tokArr[j].marker === m) break;
                            j++;
                        }
                        if (j < end) {
                            // gather raw text between i+1 .. j-1
                            let codeText = '';
                            for (let k = i + 1; k < j; k++) {
                                codeText += (tokArr[k].type === 'text' ? tokArr[k].text : tokArr[k].marker);
                            }
                            out.push({type: m_attr_map[m].type, text: codeText});
                            i = j + 1;
                        } else {
                            // no closing backtick -> treat marker as literal text
                            if (m_attr_map[m].padded) {
                                out.push({type: 'text', text: m.slice(1)});
                            } else {
                                out.push({type: 'text', text: m});
                            }
                            i++;
                        }
                        continue;
                    }

                    // For other markers, find matching closing marker of same kind
                    // supported mappings:
                    // '**' -> bold
                    // '*'  -> italic
                    // '__' -> underline
                    // '~~' -> del
                    let nodeType = null;
                    if (m === '**') nodeType = 'bold';
                    else if (m === '*') nodeType = 'italic';
                    else if (m === '__') nodeType = 'underline';
                    else if (m === '~~') nodeType = 'del';

                    if (nodeType) {
                        // find a matching marker later (allow nesting)
                        let j = i + 1;
                        while (j < end) {
                            if (tokArr[j].type === 'marker' && tokArr[j].marker === m) break;
                            j++;
                        }
                        if (j < end) {
                            // recursively parse interior tokens
                            const children = parseRange(tokArr, i + 1, j);
                            out.push({type: nodeType, children});
                            i = j + 1;
                        } else {
                            // no matching closer -> treat marker as literal text
                            out.push({type: 'text', text: m});
                            i++;
                        }
                        continue;
                    }

                    // fallback: unknown marker -> literal
                    out.push({type: 'text', text: t.marker});
                    i++;
                }
                return out;
            }

            const ast = parseRange(tokens, 0, tokens.length);
            line_object.tokens = ast;
        },

        resolve: (text) => {
            const lines = text.split(/\r?\n/g);

            const line_statuses = {
                PLAIN_LINE: 0,
                CODE_AREA_BEGIN: 1, // in fenced code block
            }
            let line_status = line_statuses.PLAIN_LINE;

            const line_regexps = {
                code_area_begin: /^\s*(`{3,})([A-Za-z0-9]*)\s*$/,
                code_area_end: "^\\s*([`]{__count__})\\s*$",
            };

            const line_objects = [];

            const line_object_template = {
                type: MarkdownResolver.line_object_types.plain_line,
            }

            const line_args = {
                code_area_backtick_count: null,
                code_area_end_regexp: null,
            };

            for (const rawLine of lines) {
                const line = rawLine; // keep name consistent
                if (line_status === line_statuses.PLAIN_LINE) {

                    const r = line_regexps.code_area_begin.exec(line); // æ£€æµ‹ä»£ç å—å¼€å§‹
                    if (r) {
                        line_args.code_area_backtick_count = r[1].length;
                        line_args.code_area_end_regexp = new RegExp(line_regexps.code_area_end.replace("__count__", line_args.code_area_backtick_count));
                        line_status = line_statuses.CODE_AREA_BEGIN;

                        const line_object = {
                            ...line_object_template,
                            type: MarkdownResolver.line_object_types.code_area,
                            language: r[2] || '',
                            data: [],
                        };
                        line_objects.push(line_object);

                        continue;
                    }

                    // æ™®é€šè¡Œï¼šè§£æä¸º tokens AST
                    const line_object = {...line_object_template, type: MarkdownResolver.line_object_types.plain_line,};
                    MarkdownResolver.resolve_line(line_object, line);
                    line_objects.push(line_object);
                } //
                else if (line_status === line_statuses.CODE_AREA_BEGIN) {
                    const r = line_args.code_area_end_regexp.exec(line);
                    if (r) {
                        // end of fenced code block
                        line_status = line_statuses.PLAIN_LINE;
                        // consume end line and continue
                        continue;
                    }

                    const line_object = line_objects.at(-1);
                    line_object.data.push(line);
                }
            }

            return line_objects;
        },

        escapeHTML: (str) => {
            const div = document.createElement('div');
            div.textContent = str; // æˆ–ä½¿ç”¨ div.innerText
            const r = div.innerHTML;
            div.remove();
            return r;
        },

        to_html: (text) => {
            const line_objects = MarkdownResolver.resolve(text);

            const parts = [];

            function resolve_tokens(tokens) {
                for (const token of tokens) {
                    if (token.type === "text") {
                        parts.push(`<span class="md-text">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(token.text);
                        parts.push(`</span>`);
                    } //
                    else if (token.type === "bold") {
                        parts.push(`<span class="md-text-bold">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(`</span>`);
                    } //
                    else if (token.type === "italic") {
                        parts.push(`<span class="md-text-italic">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(`</span>`);
                    } //
                    else if (token.type === "underline") {
                        parts.push(`<span class="md-text-underline">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(`</span>`);
                    } //
                    else if (token.type === "del") {
                        parts.push(`<span class="md-text-del">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(`</span>`);
                    } //
                    else if (token.type === "code") {
                        parts.push(`<span class="md-text-code">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(MarkdownResolver.escapeHTML(token.text));
                        parts.push(`</span>`);
                    } //

                    else if (token.type === "at") {
                        parts.push(`<span class="md-text-at" data-user-id="${token.text.slice(1)}">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(token.text);
                        parts.push(`</span>`);
                    } //
                    else if (token.type === "cite") {
                        parts.push(`<span class="md-text-cite" data-message-id="${token.text.slice(1)}">`);
                        if (token.children) resolve_tokens(token.children);
                        parts.push(token.text);
                        parts.push(`</span>`);
                    } //
                }
            }

            for (const lineObject of line_objects) {
                if (lineObject.type === MarkdownResolver.line_object_types.plain_line) {
                    if (lineObject.is_blockquote) parts.push(`<div class="md-line-blockquote">`);
                    else if (lineObject.title_level > 0) parts.push(`<div class="md-line-title" data-title-level="${lineObject.title_level}">`);
                    parts.push(`<p class="md-line">`);
                    resolve_tokens(lineObject.tokens);
                    parts.push(`</p>`);
                    if (lineObject.is_blockquote) parts.push(`</div>`);
                    else if (lineObject.title_level > 0) parts.push(`</div>`);
                } else if (lineObject.type === MarkdownResolver.line_object_types.code_area) {
                    parts.push(`<div class="md-area-code-wrap"><pre class="md-area-code">${MarkdownResolver.escapeHTML(lineObject.data.join("\n"))}</pre><button class="md-area-code-btn-copy">å¤åˆ¶</button></div>`);
                }
            }

            return parts.join("\n");
        },
    }


    /*
    * åº”ç”¨å…ƒç´ åŒ…è£…å±‚
    * */
    const dashboardwrappers = (() => {
        class DashboardWrapper {
            constructor(dashboard_element) {
                this.dashboard_element = dashboard_element;
                this.loading_mark = new LoadingMark(this.dashboard_element);

                this.aside_left_wrap = this.dashboard_element.querySelector(':scope .aside-left-wrap');
                if (this.aside_left_wrap) remove_simple_loading_mark(this.aside_left_wrap); // æŸäº›é¡µé¢æ²¡æœ‰aside_left

                this.aside_right = this.dashboard_element.querySelector(':scope .aside-right');
            }

            is_active() {
                return checkin.current_panel() === this.dashboard_element;
            }

            remove_loading_mark() {
                this.loading_mark.remove();
                this.loading_mark = new LoadingMark(this.dashboard_element);
            }

            leave() {
            }


        }

        class ChatDashboardWrapper extends DashboardWrapper {
            constructor(dashboard_element) {
                super(dashboard_element);

                this.timer__sync = null;
                this.interval__sync = 10000;
                this.interval__sync__ws = 7000;
                this.is_processing__sync = false;

                this.mark_syncing = this.dashboard_element.querySelector(':scope .chat-contacts-mark-syncing');
                this.change_loading_status__syncing();

                this.ws_client = null;
                this.ws_counter = 0;
                this.ws_callbacks = {};
                this.ws_lasttime_connecting = 0;

                // âœ… åˆå§‹åŒ–ç§èŠæœç´¢ï¼ˆåªä¼šæ‰§è¡Œä¸€æ¬¡ï¼‰
                this.init_private_contact_search();
            }

            init_private_contact_search() {
                const input = this.dashboard_element.querySelector(".chat-contact-search");
                const privateList = this.dashboard_element.querySelector(".chat-private-list");

                // DOM è¿˜æ²¡æ¸²æŸ“å¥½å°±ç›´æ¥è·³è¿‡ï¼ˆå®‰å…¨å…œåº•ï¼‰
                if (!input || !privateList) return;

                input.addEventListener("input", () => {
                    const keyword = input.value.trim().toLowerCase();

                    privateList.querySelectorAll(".chat-contact").forEach(li => {
                        const nameEl = li.querySelector(
                            ".chat-contact-session-status-top-name"
                        );

                        const name = nameEl
                            ? nameEl.textContent.toLowerCase()
                            : "";

                        li.style.display =
                            !keyword || name.includes(keyword)
                                ? ""
                                : "none";
                    });
                });
            }

            leave() {
                this.ws_close();
                this.stop_timer__sync();
                for (const mainaction of this.contact_items()) {
                    mainaction.e_online_status.dataset.onlineStatus = "offline";
                }
            }

            /*
            * å·¦ä¾§ è”ç³»äºº
            * */
            add_contact_item(attr,) {
                if (attr.type === subviews.Chat.receiver_type.group) {
                    const mainaction = {text: attr.gid, pagetype: contentpages.dashboard_chat.group,};
                    mainaction.contact_attr = attr;

                    mainaction.status_attr = {};
                    mainaction.ceid = null;
                    mainaction.msgs = [];
                    mainaction.draft_text = "";
                    mainaction.sending_msgs = [];

                    const lis = this.dashboard_element.mainactions[0].lis;
                    const ol = this.dashboard_element.mainactions[0].ol;
                    lis.push(mainaction);
                    this.add_contact_item_(mainaction, ol,);
                } else if (attr.type === subviews.Chat.receiver_type.user) {
                    const mainaction = {text: attr.uid, pagetype: contentpages.dashboard_chat.user,};
                    mainaction.contact_attr = attr;

                    mainaction.status_attr = {};
                    mainaction.ceid = null;
                    mainaction.msgs = [];
                    mainaction.draft_text = "";
                    mainaction.sending_msgs = [];

                    const lis = this.dashboard_element.mainactions[1].lis;
                    const ol = this.dashboard_element.mainactions[1].ol;
                    lis.push(mainaction);
                    this.add_contact_item_(mainaction, ol,);
                }
            }

            add_contact_item_(mainaction, ol,) {
                let html = `
<div class="chat-contact">

<span class="chat-contact-online-status">â—</span>

<div class="chat-contact-session-status">
    <div class="chat-contact-session-status-top">
        <span class="chat-contact-session-status-top-name">${mainaction.text}</span>
        <span class="chat-contact-session-status-top-lastmsgtime">æœªçŸ¥</span>
    </div>
      <div class="chat-contact-session-status-bottom">
        <span class="chat-contact-session-status-bottom-lastmsgview">${full_width_space}</span>
        <span class="chat-contact-session-status-bottom-unreadcount hidden"></span>
    </div>
</div>

</div>
`;
                ol.insertAdjacentHTML("beforeend", html);
                let li = ol.querySelector(":scope div.chat-contact:last-of-type");
                li.bindmap = mainaction;
                li.bindmap.element = li;
                li.addEventListener("click", (event) => {
                    checkin.switch_content_page(event, li);
                });

                mainaction.e_online_status = li.querySelector(":scope .chat-contact-online-status");
                mainaction.e_online_status.dataset.onlineStatus = "offline";

                mainaction.e_sst_name = li.querySelector(":scope .chat-contact-session-status-top-name");
                mainaction.e_sst_lastmsgtime = li.querySelector(":scope .chat-contact-session-status-top-lastmsgtime");
                mainaction.e_ssb_lastmsgview = li.querySelector(":scope .chat-contact-session-status-bottom-lastmsgview");
                mainaction.e_ssb_unreadcount = li.querySelector(":scope .chat-contact-session-status-bottom-unreadcount");

            }

            static is_group(contact_attr) {
                return contact_attr.type === subviews.Chat.receiver_type.group;
            }

            static get_contact_xxid(contact_attr) {
                if (contact_attr.type === subviews.Chat.receiver_type.group) {
                    return contact_attr.gid;
                } else {
                    return contact_attr.uid;
                }
            }

            async _update_contact_item_status(item, status_attr, for_refresh = false) {
                if (for_refresh && item.status_attr !== status_attr) return;
                item.status_attr = status_attr;

                if (status_attr.edition_id !== null) { // æœ‰æœªåŒæ­¥çš„äºŒç¼–æ¶ˆæ¯
                    const former_ceid = item.ceid;
                    // item.ceid = status_attr.edition_id; // ç”±äºhttpå¹¶å‘æ—¶æ”¶åˆ°å“åº”çš„é¡ºåºä¸ç¡®å®šï¼Œåˆ¤æ–­ä¸‹æ˜¯å¦å¤§äºå†èµ‹å€¼
                    if (former_ceid === null || former_ceid < status_attr.edition_id) {
                        item.ceid = status_attr.edition_id;
                        this.sync_edited_messages(item, former_ceid, status_attr, status_attr.editions);
                    }
                }

                if (status_attr.type === subviews.Chat.receiver_type.group) {
                    item.e_online_status.dataset.onlineStatus = status_attr.online_count > 0 ? "online" : "offline";
                } else if (status_attr.type === subviews.Chat.receiver_type.user) {
                    item.e_online_status.dataset.onlineStatus = status_attr.online_status === ChatDashboardWrapper.online_status.online ? "online" : "offline";
                }
                item.e_sst_lastmsgtime.textContent = format_timestamp_utc8_day(status_attr.last_message_time);
                item.e_ssb_unreadcount.textContent = status_attr.unread_count;
                const string_activity = this.format_contact_item_status__activity(item, status_attr);
                if (status_attr.unread_count > 0) {
                    item.e_ssb_unreadcount.classList.remove("hidden");
                    item.e_ssb_lastmsgview.textContent = "[ç³»ç»Ÿ] ç‚¹å‡»æŸ¥çœ‹æœªè¯»ã€‚"
                    item.e_ssb_lastmsgview.dataset.hasActivity = "false";
                } else {
                    item.e_ssb_unreadcount.classList.add("hidden");
                    if (string_activity.length > 0) {
                        item.e_ssb_lastmsgview.textContent = string_activity;
                        item.e_ssb_lastmsgview.dataset.hasActivity = "true";
                    } else {
                        if (item.draft_text.length > 0) {
                            item.e_ssb_lastmsgview.textContent = "[è‰ç¨¿] " + this.format_text_for_msgview(item.draft_text);
                            item.e_ssb_lastmsgview.dataset.hasActivity = "false";
                        } else {
                            if (item.msgs.length === 0) {
                                item.e_ssb_lastmsgview.textContent = full_width_space;
                                item.e_ssb_lastmsgview.dataset.hasActivity = "false";
                            } else {
                                item.e_ssb_lastmsgview.textContent = await this.format_contact_item_status__lastmsgview(item.msgs.at(-1));
                                item.e_ssb_lastmsgview.dataset.hasActivity = "false";
                            }
                        }
                    }
                }

                if (checkin.current_content_page && checkin.current_content_page.li.bindmap === item) {
                    if (string_activity.length > 0) {
                        set_textContent_if_different(checkin.current_content_page.e_header_info_status, string_activity);
                    } else {
                        if (status_attr.type === subviews.Chat.receiver_type.group) {
                            set_textContent_if_different(checkin.current_content_page.e_header_info_status, `${status_attr.online_count}äººåœ¨çº¿`);
                        } else if (status_attr.type === subviews.Chat.receiver_type.user) {
                            set_textContent_if_different(checkin.current_content_page.e_header_info_status, status_attr.online_status === ChatDashboardWrapper.online_status.online ? "åœ¨çº¿" : "ç¦»çº¿");
                        }
                    }
                    // if (status_attr.unread_count > 0) {
                    //     checkin.current_content_page.start_timer__fetch_unread_msgs();
                    // }

                }

                // ğŸ”¥ æ–°å¢ï¼šæ¯æ¬¡çŠ¶æ€å˜åŒ–åé‡æ’è”ç³»äºº
                this.resort_contact_items();

            }

            sync_edited_messages(item, former_ceid, status_attr, message_ids) {
                const local_msg_ids = [];
                item.msgs.forEach(i => local_msg_ids.push(i.id));
                // item.sending_msgs.forEach(i => local_msg_ids.push(i.id)); // sending_msgsé‡Œçš„éƒ½æ²¡æœ‰id
                message_ids = message_ids.filter(i => local_msg_ids.includes(i)); // TODO è‡ªå·±å‘é€æ¶ˆæ¯åç«‹å³ç¼–è¾‘ï¼Œä¼šä¸ä¼šå‡ºç°é—®é¢˜ï¼Ÿæ˜¯ä¸æ˜¯ä¸èƒ½è¿‡æ»¤ï¼Ÿ

                if (message_ids.length === 0) {
                    // console.log("åŒæ­¥äºŒç¼–æ¶ˆæ¯ï¼ˆè·³è¿‡ï¼‰", former_ceid, status_attr.edition_id, status_attr, message_ids);
                    return;
                }
                // console.log("åŒæ­¥äºŒç¼–æ¶ˆæ¯", former_ceid, status_attr.edition_id, status_attr, message_ids);

                item.msgs.filter(i => message_ids.includes(i.id)).forEach((msg) => {
                    msg.msgobj.blur_content();
                });
                // item.sending_msgs.filter(i => message_ids.includes(i.id)).forEach((msg) => {
                //     msg.msgobj.blur_content();
                // });

                this._sync_edited_messages(item, former_ceid, message_ids);
            }

            _sync_edited_messages(item, former_ceid, message_ids) {
                const xxid = item.contact_attr.type === subviews.Chat.receiver_type.group ? item.contact_attr.gid : item.contact_attr.uid;

                const onfetchload = (result) => {
                    // if (this.closed) return;
                    this.update_contact_item_status(result.sync);
                    this.handle_response__sync_edited_messages(item, former_ceid, message_ids, result);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;

                    if (error.auto_retry) {
                        this._sync_edited_messages(item, former_ceid, message_ids);
                    } else {
                        MessageMark.report(error, null, () => {
                            this._sync_edited_messages(item, former_ceid, message_ids);
                        });
                    }

                };
                const ws_isopen = this.ws_isopen();
                checkin.subviews.chat.sync_message(ws_isopen ? (args) => {
                    this.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, item.contact_attr.type, xxid, item.ceid, message_ids,)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });
            }

            handle_response__sync_edited_messages(item, former_ceid, message_ids, result) {
                // console.log(result)

                // result.message_attrs.forEach(i => { // å› åªä¼šæ£€æŸ¥item.msgsé‡Œçš„æ¶ˆæ¯æ˜¯å¦è¢«äºŒç¼–ï¼Œä¸å¿…å†æ¬¡è®¾ç½®is_sent
                //     i.is_sent = true;
                // });

                // const new_msgattrs = this.msgflow_manage.store_msgs(last_msgattr, result.messages);
                // if (new_msgattrs.length > 0) {
                //     const msg = new_msgattrs.find(i => i.sender !== logged_user.uid);
                //     if (msg) {
                //         msg.msgobj.highlight();
                //         if (!is_background) msg.msgobj.scroll_to_view(true);
                //     }
                // }

                if (checkin.current_content_page && checkin.current_content_page.li.bindmap === item) {
                    for (const messageAttr of result.message_attrs) {
                        const msgattr = item.msgs.findLast(i => i.id === messageAttr.id);
                        if (!msgattr) continue;
                        checkin.current_content_page.msgflow_manage.update_msg(msgattr, messageAttr,);
                    }
                } else {
                    for (const messageAttr of result.message_attrs) {
                        const msgattr = item.msgs.findLast(i => i.id === messageAttr.id);
                        if (!msgattr) continue;
                        this.msgflow_manage.update_msg(null, msgattr, messageAttr);
                    }
                }

            }

            /*
             * ç®¡ç†ç¼“å­˜çš„æ¶ˆæ¯å’Œæ¸²æŸ“ï¼Œå¯èƒ½ä¸contentpageæ— å…³çš„éƒ¨åˆ†
             * */
            msgflow_manage = { // this=dashboardwrapper

                _assign_new_message_attr: (this_msgattr, new_message_attr) => {
                    Object.assign(this_msgattr, new_message_attr);
                    this_msgattr.plain_data_text = undefined;
                    this_msgattr.plain_data_markdown = undefined;
                    this_msgattr.formated_lastmsgview = undefined;
                },

                update_msg: (contentpage, this_msgattr, new_message_attr) => {
                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(this_msgattr.type) && // ç¼–è¾‘
                        dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(new_message_attr.type)) {
                        this.msgflow_manage._assign_new_message_attr(this_msgattr, new_message_attr);
                        this_msgattr.msgobj.unblur_content();
                        this_msgattr.msgobj.update();

                    } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_sys(new_message_attr.type)) { // è¢«æ’¤å›/åˆ é™¤äº†çš„è¯ï¼Œç±»å‹å°±å˜äº†
                        if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_sys(this_msgattr.type)) { // ä¾‹å¦‚ä» è¢«ç”¨æˆ·æ’¤å› åˆ° è‡ªåŠ¨åˆ é™¤
                            this.msgflow_manage._assign_new_message_attr(this_msgattr, new_message_attr);
                            this_msgattr.formated_sys_msg = undefined;
                            this_msgattr.formated_lastmsgview = undefined;
                            this_msgattr.msgobj.unblur_content();
                            this_msgattr.msgobj.update();
                        } else {
                            // const affected_msgobjs = [];
                            // affected_msgobjs.push(msgattr.msgobj);
                            // if (msgattr.msgobj.is_header()) {
                            //     affected_msgobjs.push(...msgattr.msgobj.msgobjchildren);
                            // } else {
                            // }
                            if (this_msgattr.msgobj.is_header()) {
                                this.msgflow_manage._assign_new_message_attr(this_msgattr, new_message_attr);
                                const header = this_msgattr.msgobj;
                                const affected_msgobjs = []; // part2
                                for (const msgobjchild of header.msgobjchildren) {
                                    affected_msgobjs.push(msgobjchild);
                                }
                                // header.remove_from_flow(); // å…ˆä¸åˆ ï¼Œç­‰groupæ¶ˆæ¯ç§»åˆ°flowé‡Œåå†åˆ 
                                for (const affectedMsgobj of affected_msgobjs) header.remove_child(affectedMsgobj);

                                const new_header_msgobjs = [];
                                for (const msgobjchild of [this_msgattr.msgobj, ...affected_msgobjs]) {
                                    const msgseniors = [...msgobjchild.msgattrseniors];
                                    const msgobj = this.msgflow_manage.add_element(contentpage, msgobjchild.msgattr, msgseniors, false);
                                    msgobjchild.msgattr.msgobj = msgobj;
                                    if (msgobj.is_header()) {
                                        new_header_msgobjs.push(msgobj);
                                    }
                                }
                                if (contentpage) {
                                    header.msgelement.insertAdjacentElement("afterend", this_msgattr.msgobj.msgelement);
                                    let previous_header = this_msgattr.msgobj.msgelement;
                                    for (const affectedMsgobj of new_header_msgobjs.slice(1)) {
                                        if (affectedMsgobj.is_header()) {
                                            previous_header.insertAdjacentElement("afterend", affectedMsgobj.msgelement);
                                            previous_header = affectedMsgobj.msgelement;
                                        }
                                    }
                                    header.remove_from_flow();
                                }

                            } else {
                                this.msgflow_manage._assign_new_message_attr(this_msgattr, new_message_attr);
                                const header = this_msgattr.msgobj.header();
                                const affected_msgobjs = []; // part2
                                let found = false;
                                for (const msgobjchild of header.msgobjchildren) {
                                    if (found) {
                                        affected_msgobjs.push(msgobjchild);
                                    } else {
                                        if (msgobjchild === this_msgattr.msgobj) found = true;
                                    }
                                }
                                header.remove_child(this_msgattr.msgobj);
                                for (const affectedMsgobj of affected_msgobjs) header.remove_child(affectedMsgobj);

                                const new_header_msgobjs = [];
                                for (const msgobjchild of [this_msgattr.msgobj, ...affected_msgobjs]) {
                                    const msgseniors = [...msgobjchild.msgattrseniors];
                                    const msgobj = this.msgflow_manage.add_element(contentpage, msgobjchild.msgattr, msgseniors, false);
                                    msgobjchild.msgattr.msgobj = msgobj;
                                    if (msgobj.is_header()) {
                                        new_header_msgobjs.push(msgobj);
                                    }
                                }

                                header.msgelement.insertAdjacentElement("afterend", this_msgattr.msgobj.msgelement);
                                let previous_header = this_msgattr.msgobj.msgelement;
                                for (const affectedMsgobj of new_header_msgobjs.slice(1)) {
                                    if (affectedMsgobj.is_header()) {
                                        previous_header.insertAdjacentElement("afterend", affectedMsgobj.msgelement);
                                        previous_header = affectedMsgobj.msgelement;
                                    }
                                }
                            }
                        }
                    } else { // æ ‡è®°å·²è¯»
                        this.msgflow_manage._assign_new_message_attr(this_msgattr, new_message_attr);
                        this_msgattr.msgobj.unblur_content();
                        this_msgattr.msgobj.update();
                    }
                },

                add_element: (contentpage, msgattr, msgseniors, noappend = false) => {
                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(msgattr.type)) {
                        const msgobj = new contentpages._chat.msgtypes.TextMsg(this.dashboard_element, contentpage, msgattr, msgseniors);
                        msgattr.msgobj = msgobj;
                        if (msgobj.is_header()) {
                            if (!noappend) contentpage.e_msgflow.append(msgobj.msgelement);
                        } else {
                            msgobj.header().append_child(msgobj);
                        }
                        return msgobj;
                    } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_image(msgattr.type)) {
                        const msgobj = new contentpages._chat.msgtypes.ImageMsg(this.dashboard_element, contentpage, msgattr, msgseniors);
                        msgattr.msgobj = msgobj;
                        if (msgobj.is_header()) {
                            if (!noappend) contentpage.e_msgflow.append(msgobj.msgelement);
                        } else {
                            msgobj.header().append_child(msgobj);
                        }
                        return msgobj;
                    } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_file(msgattr.type)) {
                        const msgobj = new contentpages._chat.msgtypes.FileMsg(this.dashboard_element, contentpage, msgattr, msgseniors);
                        msgattr.msgobj = msgobj;
                        if (msgobj.is_header()) {
                            if (!noappend) contentpage.e_msgflow.append(msgobj.msgelement);
                        } else {
                            msgobj.header().append_child(msgobj);
                        }
                        return msgobj;
                    } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_sys(msgattr.type)) {
                        const msgobj = new contentpages._chat.msgtypes.SysMsg(this.dashboard_element, contentpage, msgattr, msgseniors);
                        msgattr.msgobj = msgobj;
                        if (msgobj.is_header()) {
                            if (!noappend && contentpage) contentpage.e_msgflow.append(msgobj.msgelement);
                        } else {
                            msgobj.header().append_child(msgobj);
                        }
                        return msgobj;
                    }
                },


            }

            format_text_for_msgview(text) {
                text = text.replace(/[\r\n\f\t]+/g, " ");
                if (text.length > 100) text = text.slice(0, 100) + "...";
                return text;
            }

            format_contact_item_status__activity(item, status_attr) {
                let string = "";

                const users__typing = [];
                status_attr.activities.forEach(i => {
                    if (i.type === ChatDashboardWrapper.activity_type.typing) {
                        users__typing.push(i);
                    }
                });

                if (users__typing.length > 0) {
                    string = `æ­£åœ¨è¾“å…¥...(${users__typing.map(i => i.sender).join(", ")})`
                }

                return string;
            }

            format_sys_msg(msgattr) {
                let string = "æœªçŸ¥ç³»ç»Ÿæ¶ˆæ¯";
                const sys_attr = msgattr.sys_attr;
                const sender = msgattr.sender ? msgattr.sender : "null";
                const a1_uid = sys_attr.a1_uid ? sys_attr.a1_uid : "null";
                if (sys_attr.type === dashboardwrappers.ChatDashboardWrapper.data_spec_action_type.revoke_message || sys_attr.type === dashboardwrappers.ChatDashboardWrapper.data_spec_action_type.delete_message) {
                    const action_name = sys_attr.type === dashboardwrappers.ChatDashboardWrapper.data_spec_action_type.revoke_message ? "æ’¤å›" : "åˆ é™¤";
                    if (sender === logged_user.uid) {
                        if (a1_uid === logged_user.uid) {
                            string = `ä½ ${action_name}äº†ä¸€æ¡æ¶ˆæ¯`;
                        } else {
                            string = `${a1_uid}${action_name}äº†ä½ çš„ä¸€æ¡æ¶ˆæ¯`;
                        }
                    } else if (sender === a1_uid) {
                        string = `${a1_uid}${action_name}äº†ä¸€æ¡æ¶ˆæ¯`;
                    } else {
                        if (a1_uid === logged_user.uid) {
                            string = `ä½ ${action_name}äº†${sender}çš„ä¸€æ¡æ¶ˆæ¯`;
                        } else {
                            string = `${a1_uid}${action_name}äº†${sender}çš„ä¸€æ¡æ¶ˆæ¯`;
                        }
                    }
                } //
                else if (sys_attr.type === dashboardwrappers.ChatDashboardWrapper.data_spec_action_type.clear_message) {
                    const hours = sys_attr.a3_number === 0 ? "å…¨éƒ¨" : `${sys_attr.a3_number}å°æ—¶å‰çš„`;
                    if (a1_uid === logged_user.uid) {
                        string = `ä½ æ‰§è¡Œäº†åˆ é™¤${hours}æ¶ˆæ¯`;
                    } else {
                        string = `${a1_uid}æ‰§è¡Œäº†åˆ é™¤${hours}æ¶ˆæ¯`;
                    }
                } //
                else if (sys_attr.type === dashboardwrappers.ChatDashboardWrapper.data_spec_action_type.auto_delete_message) {
                    string = `å·²åˆ é™¤çš„æ¶ˆæ¯`;
                }
                return string;
            }

            get_contact_sort_weight(item) {
                const status = item.status_attr;
                if (!status) return 999;

                // 1ï¸âƒ£ æœ‰æœªè¯»æ¶ˆæ¯ï¼Œæœ€é«˜ä¼˜å…ˆçº§
                if (status.unread_count > 0) return 0;

                // 2ï¸âƒ£ åœ¨çº¿
                if (status.type === subviews.Chat.receiver_type.group) {
                    if (status.online_count > 0) return 1;
                } else if (status.type === subviews.Chat.receiver_type.user) {
                    if (status.online_status === ChatDashboardWrapper.online_status.online) {
                        return 1;
                    }
                }

                // 3ï¸âƒ£ ç¦»çº¿
                return 2;
            }

            resort_contact_items() {
                // ä¸¤ä¸ª mainactionsï¼šç¾¤ + ç§èŠ
                for (let i = 0; i < 2; i++) {
                    const mainaction_group = this.dashboard_element.mainactions[i];
                    const lis = mainaction_group.lis;
                    const ol = mainaction_group.ol;

                    // æ’åº mainaction æ•°ç»„
                    lis.sort((a, b) => {
                        const wa = this.get_contact_sort_weight(a);
                        const wb = this.get_contact_sort_weight(b);
                        if (wa !== wb) return wa - wb;

                        // åŒçº§åˆ«ï¼ŒæŒ‰æœ€åæ¶ˆæ¯æ—¶é—´å€’åº
                        const ta = a.status_attr?.last_message_time || 0;
                        const tb = b.status_attr?.last_message_time || 0;
                        return tb - ta;
                    });

                    // æŒ‰æ–°é¡ºåºé‡æ–°æ’å…¥ DOMï¼ˆä¸ä¼šæ–°å»ºå…ƒç´ ï¼‰
                    lis.forEach(item => {
                        ol.appendChild(item.element);
                    });
                }
            }

            async format_contact_item_status__lastmsgview(newest_msg) {
                let string;
                if (newest_msg.formated_lastmsgview) {
                    string = newest_msg.formated_lastmsgview;
                } else {
                    if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_text(newest_msg.type)) {
                        let failed_decrypting = false;
                        if (!newest_msg.plain_data_text) {
                            if (newest_msg.status & ChatDashboardWrapper.message_status.encrypted) {
                                try {
                                    newest_msg.plain_data_text = await encryptors.decrypt2string(newest_msg.data_text);
                                } catch (e) {
                                    failed_decrypting = true;
                                }
                            } else {
                                newest_msg.plain_data_text = newest_msg.data_text;
                            }
                        }
                        if (newest_msg.plain_data_text) {
                            string = `${this.format_text_for_msgview(newest_msg.plain_data_text)}${full_width_space}`;
                        }
                        if (failed_decrypting) {
                            string = `[ç³»ç»Ÿ] ${decrypt_error_string}`;
                        }

                    } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_drive_item(newest_msg.type)) {
                        let prefix;
                        if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_image(newest_msg.type)) {
                            prefix = "[ğŸ–¼ï¸å›¾ç‰‡]";
                        } else if (dashboardwrappers.ChatDashboardWrapper.message_type_checker.is_file(newest_msg.type)) {
                            prefix = "[æ–‡ä»¶]";
                        }

                        let failed_decrypting = false;
                        if (!newest_msg.plain_file_name) {
                            if (newest_msg.status & ChatDashboardWrapper.message_status.encrypted) {
                                try {
                                    newest_msg.plain_file_name = await encryptors.decrypt2string(newest_msg.file_attr.name);
                                } catch (e) {
                                    failed_decrypting = true;
                                }
                            } else {
                                newest_msg.plain_file_name = newest_msg.file_attr.name;
                            }
                        }
                        if (newest_msg.plain_file_name) {
                            string = `${prefix} ${this.format_text_for_msgview(newest_msg.plain_file_name)}${full_width_space}`;
                        }
                        if (failed_decrypting) {
                            string = `[ç³»ç»Ÿ] ${decrypt_error_string}`;
                        }

                    } else if (newest_msg.type === ChatDashboardWrapper.message_type.sys) {
                        if (!newest_msg.formated_sys_msg) newest_msg.formated_sys_msg = this.format_sys_msg(newest_msg);
                        string = `[ç³»ç»Ÿ] ${newest_msg.formated_sys_msg}`;
                    }
                }
                if (!string) return full_width_space;
                newest_msg.formated_lastmsgview = string;
                return string;
            }

            remove_all_contact_items() {
                for (let i = 0; i < 2; i++) {
                    const lis = this.dashboard_element.mainactions[i].lis;
                    for (const mainaction of lis) {
                        mainaction.element.remove();
                    }
                    lis.length = 0;
                }
            }

            contact_items() {
                const result = [];
                for (let i = 0; i < 2; i++) {
                    const lis = this.dashboard_element.mainactions[i].lis;
                    result.push(...lis);
                }
                return result; // mainactions
            }

            static online_status = "chat"; // è¢«æœåŠ¡ç«¯æ–‡æœ¬æ›¿æ¢
            static activity_type = "chat";
            static message_type = "chat";
            static message_status = "chat";
            static data_spec_action_type = "chat";
            static ws_action_type = "chat";

            static message_type_checker = {
                is_drive_item: (type) => {
                    return type === dashboardwrappers.ChatDashboardWrapper.message_type.image || type === dashboardwrappers.ChatDashboardWrapper.message_type.file;
                }, is_image: (type) => {
                    return type === dashboardwrappers.ChatDashboardWrapper.message_type.image;
                }, is_file: (type) => {
                    return type === dashboardwrappers.ChatDashboardWrapper.message_type.file;
                }, is_text: (type) => {
                    return type === dashboardwrappers.ChatDashboardWrapper.message_type.text;
                }, is_sys: (type) => {
                    return type === dashboardwrappers.ChatDashboardWrapper.message_type.sys;
                },
            }

            /*
            * å®šæœŸåŒæ­¥
            * */
            start_timer__sync(is_background = true) {
                if (!is_background) {
                    // this.remove_loading_mark();
                    // this.loading_mark.show();
                    remove_simple_loading_mark(this.aside_left_wrap);
                    this.aside_left_wrap.simple_loading_mark.show();
                    if (this.is_processing__sync) return;
                }
                this.stop_timer__sync();
                this.sync();
            }

            stop_timer__sync() {
                if (this.timer__sync !== null) clearTimeout(this.timer__sync);
                this.timer__sync = null;
            }

            sync() {
                if (!this.is_active()) return;
                const items = this.contact_items();
                if (items.length === 0) {
                    if (this.is_active()) this.timer__sync = setTimeout(() => {
                        this.sync()
                    }, this.ws_isopen() ? this.interval__sync__ws : this.interval__sync);
                    return;
                }

                this.is_processing__sync = true;
                this.change_loading_status__syncing();

                const gid_args = {};
                const uid_args = {};
                items.forEach(i => {
                    if (i.contact_attr.type === subviews.Chat.receiver_type.group) {
                        gid_args[i.contact_attr.gid] = {ceid: i.ceid,};
                    } else if (i.contact_attr.type === subviews.Chat.receiver_type.user) {
                        uid_args[i.contact_attr.uid] = {ceid: i.ceid,};
                    }
                });


                const onfetchload = (result) => {
                    // if (this.closed) return;

                    this.is_processing__sync = false;
                    this.change_loading_status__syncing();

                    // this.remove_loading_mark();
                    remove_simple_loading_mark(this.aside_left_wrap);

                    this.stop_timer__sync();
                    this.handle_response__sync(result);
                };
                const onfetcherror = (error) => {
                    // if (this.closed) return;

                    this.is_processing__sync = false;
                    this.change_loading_status__syncing();

                    // this.remove_loading_mark();
                    remove_simple_loading_mark(this.aside_left_wrap);

                    if (error.auto_retry) {
                        this.stop_timer__sync();
                        if (this.is_active()) this.sync();
                    } else {
                        MessageMark.report(error, null, () => {
                            this.stop_timer__sync();
                            if (this.is_active()) this.sync();
                        });
                    }

                };

                const ws_isopen = this.ws_isopen();
                checkin.subviews.chat.sync(ws_isopen ? (args) => {
                    this.ws_send(args.body, {onfetchload, onfetcherror});
                } : null, gid_args, uid_args)
                    .then(result => {
                        if (ws_isopen) return;
                        onfetchload(result);
                    }).catch(error => {
                    onfetcherror(error);
                });

                if (!this.ws_client && Date.now() - this.ws_lasttime_connecting > 30 * 1000) this.ws_connect();

            }


            async handle_response__sync(result) {
                if (!this.is_active()) return;

                let newMessageItem = null;

                const items = this.contact_items();
                for (const status_attr of result) {
                    let item;
                    if (status_attr.type === subviews.Chat.receiver_type.group) {
                        item = items.find(i => i.contact_attr.gid === status_attr.gid);
                    } else if (status_attr.type === subviews.Chat.receiver_type.user) {
                        item = items.find(i => i.contact_attr.uid === status_attr.uid);
                    }

                    // å…³é”®ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯â€œæ–°å¢æœªè¯»â€
                    if (
                        item &&
                        status_attr.unread_count > item.status_attr.unread_count
                    ) {
                        newMessageItem = item;
                    }

                    await this._update_contact_item_status(item, status_attr);
                }

                this.stop_timer__sync();
                if (this.is_active()) {
                    this.timer__sync = setTimeout(() => {
                        this.sync()
                    }, this.ws_isopen() ? this.interval__sync__ws : this.interval__sync);
                }

                // ğŸ¯ çœŸæ­£æ˜¾ç¤ºæ¶ˆæ¯å†’æ³¡çš„åœ°æ–¹
                if (newMessageItem) {
                    playSound();
                    startTitleFlash();

                    const senderName =
                        newMessageItem.contact_attr.nickname ||
                        newMessageItem.contact_attr.name ||
                        "æ–°æ¶ˆæ¯";

                    const preview =
                        newMessageItem.status_attr.last_message?.content ||
                        "ä½ æ”¶åˆ°äº†ä¸€æ¡æ–°æ¶ˆæ¯,æ³¨æ„çœ‹æœªè¯»æ¶ˆæ¯";

                    showChatToast({
                        title: senderName,
                        content: preview,
                        onClick: null
                    });
                }
            }


            async update_contact_item_status(status_attr) {
                if (!this.is_active()) return;
                const items = this.contact_items();
                let item;
                if (status_attr.type === subviews.Chat.receiver_type.group) {
                    item = items.find(i => i.contact_attr.gid === status_attr.gid);
                } else if (status_attr.type === subviews.Chat.receiver_type.user) {
                    item = items.find(i => i.contact_attr.uid === status_attr.uid);
                }
                await this._update_contact_item_status(item, status_attr);
            }

            change_loading_status__syncing() {
                if (this.is_processing__sync) {
                    this.mark_syncing.classList.remove("hidden");
                } else {
                    this.mark_syncing.classList.add("hidden");
                }
            }

            /*
            * websocket
            * */
            ws_connect() {
                this.ws_lasttime_connecting = Date.now();
                this.ws_close();
                const url = join_path(checkin.subviews.chat.api_url(), "ws",);
                if (url.protocol === 'https:') url.protocol = 'wss:';
                else if (url.protocol === 'http:') url.protocol = 'ws:';
                this.ws_client = new WebSocket(url);
                this.ws_client.addEventListener("open", (event) => {
                    console.log("websocket å·²è¿æ¥", event);
                });
                this.ws_client.addEventListener("close", (event) => {
                    this.ws_onclose(event);
                });
                this.ws_client.addEventListener("error", (event) => {
                    this.ws_onerror(event);
                });
                this.ws_client.addEventListener("message", (event) => {
                    // console.log("websocket æ”¶åˆ°æ¶ˆæ¯", event.data);
                    let json;
                    try {
                        json = JSON.parse(event.data);
                    } catch (e) {
                        return;
                    }
                    this.ws_receive(json);
                });
            }

            ws_close() {
                if (this.ws_client) {
                    this.ws_client.close();
                    this.ws_client = null;
                }
            }

            ws_onclose(event) {
                console.log("websocket å·²å…³é—­", event);
                for (let key in this.ws_callbacks) {
                    if (this.ws_callbacks.hasOwnProperty(key)) {
                        const error = new Error(`Websocketè¿æ¥å…³é—­ï¼š${event.code}ï¼Œ${event.reason}`);
                        error.auto_retry = true;
                        this.ws_callbacks[key].onfetcherror(error);
                        delete this.ws_callbacks[key];
                    }
                }
                this.ws_client = null;
            }

            ws_onerror(event) {
                console.log("websocket å‘ç”Ÿé”™è¯¯", event);
                for (let key in this.ws_callbacks) {
                    if (this.ws_callbacks.hasOwnProperty(key)) {
                        const error = new Error(`Websocketè¿æ¥å¼‚å¸¸å…³é—­ï¼š${event.code}ï¼Œ${event.reason}ï¼Œ${event}`);
                        error.auto_retry = true;
                        this.ws_callbacks[key].onfetcherror(error);
                        delete this.ws_callbacks[key];
                    }
                }
            }

            ws_isopen() {
                return this.ws_client && this.ws_client.readyState === WebSocket.OPEN;
            }

            ws_send(json, callback) {
                json.counter = this.ws_counter;
                this.ws_callbacks[json.counter.toString()] = callback;
                this.ws_counter++;
                // console.log("websocket å‘é€æ¶ˆæ¯", json);
                this.ws_client.send(JSON.stringify(json));
            }

            ws_receive(json) {
                const counter = json.counter?.toString();
                if (Object.keys(this.ws_callbacks).includes(counter)) {
                    const callback = this.ws_callbacks[counter];
                    delete this.ws_callbacks[counter];
                    if (json.error) {
                        const error = new Error(JSON.stringify(json));
                        if (json.error.message.includes("Too many API requests by single worker invocation")) {
                            this.ws_close();
                            error.auto_retry = true;
                        }
                        callback.onfetcherror(error);
                    } else {
                        callback.onfetchload(json.result);
                    }
                } else {
                    console.log("websocket æ²¡æœ‰æ³¨å†Œå›è°ƒçš„æ¶ˆæ¯ã€‚");
                }
            }
        }

        return {DashboardWrapper, ChatDashboardWrapper,}

    })()


    /*
    * APP
    * */
    class Checkin {
        constructor() {
            this.name = document.title;
            this.subviews = {
                api: new subviews.Api(this),
                admin: new subviews.Admin(this),
                me: new subviews.Me(this),
                mail: new subviews.Mail(this),
                drive: new subviews.Drive(this),
                chat: new subviews.Chat(this),
            };

            this.header_btn_mail = document.getElementById("header-btn-mail"); // åˆ‡æ¢é¢æ¿
            this.header_btn_mail.classList.add("hidden");
            this.header_btn_drive = document.getElementById("header-btn-drive");
            this.header_btn_chat = document.getElementById("header-btn-chat");
            this.header_btn_forum = document.getElementById("header-btn-forum");
            this.header_btn_startpage = document.getElementById("header-btn-startpage");
            this.header_btns = [this.header_btn_startpage, this.header_btn_mail, this.header_btn_drive, this.header_btn_chat, this.header_btn_forum,];
            for (const headerBtn of this.header_btns) {
                // if (headerBtn !== this.header_btn_startpage) continue;
                headerBtn.addEventListener("click", (event) => {
                    this.switch_panel_btn(event)
                });
            }

            this.header_btn_tostartpage = document.getElementById("header-btn-tostartpage"); // è¿”å›é¦–é¡µ
            this.header_btn_tostartpage.addEventListener("click", (event) => {
                this.open_startpage(event, true);
            });

            // this.header_btn_backend = document.getElementById("header-btn-backend"); // åå°é¢æ¿ Aæ ‡ç­¾ï¼Œåœ¨æ–°åˆ†é¡µæ‰“å¼€
            // this.header_btn_backend.addEventListener("click", this.open_admin_page);
            // this.header_btn_backend.classList.add("hidden");

            this.header_btn_more_left = document.getElementById("header-btn-more-left"); // å·¦ä¾§ æ›´å¤š
            this.header_btn_more_left.addEventListener("click", (event) => {
            });
            this.header_btn_more_left.classList.add("hidden");
            this.header_btn_more_right = document.getElementById("header-btn-more-right"); // å³ä¾§
            this.header_btn_more_right.addEventListener("click", (event) => {
                const rect = event.target.getBoundingClientRect();
                const items = [];
                items.push(
                    {type: "button", text: "åˆ‡æ¢ä¸»é¢˜", callback: event => this.switch_theme(),},
                    {type: "section", text: "",},
                );
                if (!jumpto.backend_panel) {
                    items.push(
                        {type: "button", text: "è¿›å…¥åå°", callback: event => this.open_admin_page(event, true),},
                        {type: "section", text: "",},
                    );
                }
                if ((jumpto.backend_panel && logged_admin) || (!jumpto.backend_panel && logged_user)) {
                    items.push(
                        {type: "button", text: "ç™»å‡º", callback: this.logout.bind(this),},
                    );
                }
                MenuMark.exec({x: rect.left, y: rect.top + rect.height,}, items);
            });


            this.apps_item_drive = document.getElementById("apps-item-drive"); // åº”ç”¨æŒ‰é’®
            this.apps_item_chat = document.getElementById("apps-item-chat");
            this.apps_item_forum = document.getElementById("apps-item-forum");
            this.apps_items = [
                {app_item: this.apps_item_drive, header_btn: this.header_btn_drive,},
                {app_item: this.apps_item_chat, header_btn: this.header_btn_chat,},
                {app_item: this.apps_item_forum, header_btn: this.header_btn_forum,},
            ];
            for (const apps_item_attr of this.apps_items) {
                apps_item_attr.app_item.addEventListener("click", (event) => {
                    this.switch_apps(apps_item_attr.header_btn,);
                });
            }


            this.login_panel = document.getElementById("login-panel"); // é¢æ¿
            this.apps_panel = document.getElementById("apps-panel");
            this.dashboard_mail = document.getElementById("dashboard-mail");
            this.dashboard_drive = document.getElementById("dashboard-drive");
            this.dashboard_chat = document.getElementById("dashboard-chat");
            this.dashboard_forum = document.getElementById("dashboard-forum");
            this.backend_panel = document.getElementById("backend-panel");
            this.panels = [this.login_panel, this.apps_panel, this.dashboard_mail, this.dashboard_drive, this.dashboard_chat, this.dashboard_forum, this.backend_panel,];
            for (const panel of this.panels) {
                if (panel === this.dashboard_chat) {
                    panel.wrapper = new dashboardwrappers.ChatDashboardWrapper(panel);
                } else {
                    panel.wrapper = new dashboardwrappers.DashboardWrapper(panel);
                }
            }


            this.login_rect = document.getElementById("login-rect"); // ç™»å½•
            this.login_tip_user = document.getElementById("login-tip-user");
            this.login_tip_admin = document.getElementById("login-tip-admin");
            this.login_input_account = document.getElementById("login-input-account");
            this.login_input_account_label = document.getElementById("login-input-account-label");
            this.login_input_password = document.getElementById("login-input-password");
            /*æ¸…ç†å¯†ç */
            document.querySelectorAll('.clear-input-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    document.getElementById(targetId).value = '';
                });
            });

            this.login_btn = document.getElementById("login-btn");
            this.login_btn.addEventListener("click", (event) => {
                this.login(event)
            });

            const enter2focus = (a, b) => {
                a.addEventListener('keydown', function (event) {
                    if (event.key === 'Enter') b.focus();
                });
            }
            enter2focus(this.login_input_account, this.login_input_password);
            enter2focus(this.login_input_password, this.login_btn);


            this.#setup_divider(this.dashboard_mail) // é¢æ¿çš„å·¦å³å¸ƒå±€
            this.#setup_divider(this.dashboard_drive)
            this.#setup_divider(this.dashboard_chat)
            this.#setup_divider(this.dashboard_forum)
            this.#setup_divider(this.backend_panel)

            this.#bind_mainactions(this.dashboard_mail, 0, [ // æ§åˆ¶åˆ‡æ¢å³ä¾§ç”»é¢ æŒ‰é’®
                {text: "æ”¶ä»¶ç®±", pagetype: contentpages.dashboard_mail.inbox,},
                {text: "å·²å‘é€", pagetype: contentpages.dashboard_mail.sent,},
                {text: "åƒåœ¾æ¡¶", pagetype: contentpages.dashboard_mail.trashcan,},
                {text: "ä¸Šçº¿æƒ…å†µ", pagetype: contentpages.dashboard_mail.activity,},
            ])
            this.#bind_mainactions(this.dashboard_drive, 0, [
                {text: "ä¸ªäººç©ºé—´", pagetype: contentpages.dashboard_drive.myspace,},
                {text: "åƒåœ¾æ¡¶", pagetype: contentpages.dashboard_drive.trashcan,},
                {text: "æœ€è¿‘æ–°å¢", pagetype: contentpages.dashboard_drive.newfiles,},
                {text: "ä¸æˆ‘å…±äº«", pagetype: contentpages.dashboard_drive.sharewithme,},
                {text: "æ€»ç›˜", pagetype: contentpages.dashboard_drive.root,},
            ])
            this.#bind_mainactions(this.backend_panel, 0, [
                {text: "ä¸Šçº¿æƒ…å†µ", pagetype: contentpages.backend_panel.activity,},
                {text: "ç”¨æˆ·åˆ—è¡¨", pagetype: contentpages.backend_panel.users,},
                {text: "ç»„åˆ—è¡¨", pagetype: contentpages.backend_panel.groups,},
                {text: "å€™é€‰è¯ç®¡ç†", pagetype: contentpages.backend_panel.candidate_words,},
                {text: "å…¨ä½“é€šçŸ¥", pagetype: contentpages.backend_panel.all_people_notice,},
                {text: "å‚¨å­˜ç©ºé—´", pagetype: contentpages.backend_panel.disk,},
                {text: "æœåŠ¡çŠ¶æ€", pagetype: contentpages.backend_panel.status,},
                {text: "å¤‡ä»½æ¢å¤", pagetype: contentpages.backend_panel.backup,},
            ])

            this.#bind_mainactions(this.dashboard_chat, 0, [])
            this.#bind_mainactions(this.dashboard_chat, 1, [])

            this.#bind_mainactions(this.dashboard_forum, 0, [
                {text: "å…¨éƒ¨ä¸»é¢˜", pagetype: contentpages.dashboard_forum.myspace,},
                {text: "ç§æœ‰ä¸»é¢˜", pagetype: contentpages.dashboard_forum.myspace,},
                {text: "æˆ‘çš„å…³æ³¨", pagetype: contentpages.dashboard_forum.myspace,},
            ])

        }

        set_title(header_btn) {
            if (jumpto.backend_panel) return;
            let app_name = "";
            if (!logged_user) {
            } else {
                app_name = header_btn.textContent;
            }
            if (app_name) app_name = " - " + app_name;
            document.title = `${this.name}${app_name}`;
        }

        switch_theme() {
            if (is_theme_dark()) {
                localStorage.removeItem("theme");
            } else {
                localStorage.setItem("theme", "dark");
            }
            this.apply_theme();
        }

        apply_theme() {
            if (is_theme_dark()) {
                document.body.classList.add('theme-dark');
            } else {
                document.body.classList.remove('theme-dark');
            }
        }

        /*
        * é¢æ¿çš„åˆ†æ  åˆå§‹åŒ–
        * */
        #setup_divider(panel) {
            const divider = panel.querySelector('.aside-divider');
            const leftAside = panel.querySelector('.aside-left-wrap');
            let isDragging = false;

            divider.addEventListener('mousedown', e => {
                isDragging = true;
                panel.style.cursor = 'col-resize';
            });

            panel.addEventListener('mousemove', e => {
                if (!isDragging) return;

                let newWidth = e.clientX; // é¼ æ ‡åˆ°çª—å£å·¦è¾¹çš„è·ç¦»
                // é™åˆ¶æœ€å°/æœ€å¤§å®½åº¦
                if (newWidth < 100) newWidth = 100;
                if (newWidth > window.innerWidth - 100) newWidth = window.innerWidth - 100;

                leftAside.style.width = newWidth + 'px';
            });

            panel.addEventListener('mouseup', () => {
                isDragging = false;
                panel.style.cursor = 'default';
            });
        }

        #bind_mainactions(panel, ol_index, lis,) {
            if (!panel.hasOwnProperty("mainactions")) panel.mainactions = {};
            const ol = panel.querySelector(`:scope nav:nth-of-type(${ol_index + 1}) > ol.nav-buttons:first-of-type`);
            panel.mainactions[ol_index] = {lis, ol,};
            for (const m of lis) {
                let html = `<li>${m.text}</li>`;
                ol.insertAdjacentHTML("beforeend", html);
                let li = ol.querySelector(":scope li:last-child");
                li.bindmap = m;
                li.bindmap.element = li;
                li.addEventListener("click", (event) => {
                    // li.bindmap.func.call(this, event);
                    this.switch_content_page(event, li);
                });
            }
        }

        /*
        * ç™»å½• ç™»å‡º
        * */
        async login(event) {

            // â­ åªæœ‰è¾“å…¥æ¡†ä¸ºç©ºæ‰å°è¯•è‡ªåŠ¨å¡«å……
            if (
                this.login_input_account.value.trim() === "" &&
                this.login_input_password.value.trim() === ""
            ) {
                await this.autofill_from_clipboard_if_empty();
            }

            // åªå»é¦–å°¾ç©ºæ ¼ï¼ˆæ›´å®‰å…¨ï¼‰
            this.login_input_account.value =
                this.login_input_account.value.trim();

            this.login_input_password.value =
                this.login_input_password.value.trim();

            let account = this.login_input_account.value;
            let password = this.login_input_password.value;

            if ((!jumpto.backend_panel && account.length === 0) || password.length === 0) {
                return;
            }

            const lm = new LoadingMark(this.login_rect);
            lm.show();

            if (jumpto.backend_panel) {
                this.subviews.admin.auth(password)
                    .then(result => {
                        lm.remove();
                        logged_admin = true;
                        this.switch_panel_to_backend();
                    })
                    .catch(error => {
                        lm.remove();
                        MessageMark.report(error);
                    });
            } else {
                this.subviews.api.auth(account, password)
                    .then(result => {
                        lm.remove();
                        logged_user = result;

                        this.header_btn_startpage.classList.remove("hidden");
                        floatball.show();
                        this.restore_selected_panel_id();
                    })
                    .catch(error => {
                        lm.remove();
                        MessageMark.report(error);
                    });
            }
        }


        logout(event) {
            if (jumpto.backend_panel) {
                delete_cookie("admin_session_id");
                this.open_admin_page(null, true);
            } else {
                const loading_mark = new LoadingMark(document.body);
                loading_mark.show();
                this.subviews.me.logout()
                    .then(result => {
                        // if (this.closed) return;
                        delete_cookie("session_id");
                        this.open_startpage(null, true);
                    }).catch(error => {
                    // if (this.closed) return;
                    delete_cookie("session_id");
                    this.open_startpage(null, true);
                });
            }
        }

        async autofill_from_clipboard_if_empty() {

            try {
                const text = await navigator.clipboard.readText();
                if (!text) return;

                const lines = text.split(/\r?\n/);

                let account = "";
                let password = "";

                for (const line of lines) {

                    const trimmed = line.trim();

                    let m = trimmed.match(/^è´¦å·\s*[ï¼š:]\s*(.+)$/);
                    if (m) account = m[1].trim();

                    m = trimmed.match(/^å¯†ç \s*[ï¼š:]\s*(.+)$/);
                    if (m) password = m[1].trim();
                }

                if (account) this.login_input_account.value = account;
                if (password) this.login_input_password.value = password;

            } catch (e) {
                console.warn("æ— æ³•è¯»å–å‰ªè´´æ¿", e);
            }
        }

        /*
        * é¦–é¡µå’Œé¢æ¿ç›¸å…³
        * */
        open_startpage(event, _self) {
            const url = root_url();
            window.open(url, _self ? "_self" : '_blank')
        }

        open_admin_page(event, _self) {
            const url = join_path(root_url(), "admin");
            window.open(url, _self ? "_self" : '_blank')
        }

        check_exception_to_reload(e) {
            const keywords = ["è¯·é‡æ–°ç™»å½•",];
            for (const keyword of keywords) {
                if (e.toString().includes(keyword)) {
                    this.reload_current_page();
                    return;
                }
            }
        }

        reload_current_page() {
            window.location.reload();
        }

        current_panel_btn() {
            for (const headerBtn of this.header_btns) {
                if (headerBtn.classList.contains("selected")) {
                    return headerBtn;
                }
            }
            return null;
        }

        save_selected_panel_id(header_btn) {
            localStorage.setItem("selected_panel_id", header_btn.id);
        }

        clear_selected_panel_id() {
            localStorage.removeItem("selected_panel_id");
        }

        restore_selected_panel_id() {
            // if (jumpto.backend_panel) return;
            // const id = localStorage.getItem("selected_panel_id");
            // for (const headerBtn of this.header_btns) {
            //     if (headerBtn.id === id) {
            //         headerBtn.click();
            //         return;
            //     }
            // }
            // this.header_btn_chat.click();

            this.header_btn_startpage.click();
        }

        switch_panel_btn(event) {
            if (jumpto.backend_panel)
                return;
            for (const headerBtn of this.header_btns) {
                headerBtn.classList.remove("selected")
            }
            if (event) {
                event.target.classList.add("selected");
                this.save_selected_panel_id(event.target);
            } else {
                // this.clear_selected_panel_id() // é€€å‡ºç™»å½•æ—¶ä¸å¿…æ¸…ç†
            }
            this.switch_panel(event);

            this.check_if_need_hide_aside();
        }

        current_panel() {
            for (const panel of this.panels) {
                if (panel.classList.contains("active")) {
                    return panel;
                }
            }
            return null;
        }

        switch_panel(event) {
            if (jumpto.backend_panel) return;
            const btn = this.current_panel_btn();
            this.set_title(btn);
            const current_panel = this.current_panel();
            if (current_panel) current_panel.wrapper.leave();
            for (const panel of this.panels) panel.classList.remove("active")
            if (btn === this.header_btn_mail) {
                if (!logged_user) return this.switch_panel_to_login();
                this.dashboard_mail.classList.add("active");
                this._switch_panel_to_mail();
            } else if (btn === this.header_btn_drive) {
                if (!logged_user) return this.switch_panel_to_login();
                this.dashboard_drive.classList.add("active");
                history.replaceState(history.state, null, join_path(root_url(), appnames.drive).toString());
                this._switch_panel_to_drive();
            } else if (btn === this.header_btn_chat) {
                if (!logged_user) return this.switch_panel_to_login();
                this.dashboard_chat.classList.add("active");
                history.replaceState(history.state, null, join_path(root_url(), appnames.chat).toString());
                this._switch_panel_to_chat();
            } else if (btn === this.header_btn_forum) {
                if (!logged_user) return this.switch_panel_to_login();
                this.dashboard_forum.classList.add("active");
                this._switch_panel_to_forum();
            } else if (btn === this.header_btn_startpage) {
                if (!logged_user) return this.switch_panel_to_login();
                this.apps_panel.classList.add("active");
                history.replaceState(history.state, null, root_url().toString());
                this._switch_panel_to_apps();
            } else {
                this.login_panel.classList.add("active");
            }

            if (btn) {
                this.header_btn_more_right.textContent = `${logged_user.uid}`;
            } else {
                this.header_btn_more_right.textContent = `#`;
            }
        }

        switch_panel_to_login() {
            if (jumpto.backend_panel) {
                this.login_panel.classList.add("active");
            } else {
                this.switch_panel_btn(null);
            }
        }

        _switch_panel_to_apps() {

        }

        _switch_panel_to_mail() {

        }

        _switch_panel_to_drive() {
            let _mainaction_root = null;
            for (const mainaction of this.dashboard_drive.mainactions[0].lis) {
                if (mainaction.pagetype === contentpages.dashboard_drive.root) {
                    _mainaction_root = mainaction;
                    break;
                }
            }
            if (logged_user.manage_drive) {
                _mainaction_root.element.classList.remove("hidden")
            } else {
                _mainaction_root.element.classList.add("hidden")
            }

            if (this.current_content_page) {
                if (this.current_content_page instanceof contentpages._drive) {
                    this.current_content_page.refresh();
                } else {
                    this.close_content_page();
                }
            }
        }

        _switch_panel_to_chat() {
            if (!form_field_checker.ffc_array(this.dashboard_chat.wrapper.contact_items())) { // è·å–è”ç³»äººåˆ—è¡¨
                if (!this.dashboard_chat.wrapper.loading_mark.is_visible()) {
                    this.dashboard_chat.wrapper.remove_all_contact_items();
                    this.dashboard_chat.wrapper.loading_mark.show();
                    this.subviews.chat.fetch_contacts()
                        .then(result => {
                            // if (this.closed) return;
                            for (const resultElement of result) this.dashboard_chat.wrapper.add_contact_item(resultElement);
                            if (this.dashboard_chat.wrapper.is_active()) this.dashboard_chat.wrapper.start_timer__sync(false);
                            this.dashboard_chat.wrapper.remove_loading_mark();
                        }).catch(error => {
                        // if (this.closed) return;
                        this.dashboard_chat.wrapper.remove_loading_mark();
                        MessageMark.report(error);
                    });
                }
            } else {
                this.dashboard_chat.wrapper.start_timer__sync(false);
            }

            if (this.current_content_page) {
                if (this.current_content_page instanceof contentpages._chat) {
                    this.current_content_page.start_timer__fetch_unread_msgs(false);
                    this.current_content_page.start_timer__update_read_progress(false);
                } else {
                    this.close_content_page();
                }
            }

        }

        _switch_panel_to_forum() {

        }

        switch_panel_to_backend() {
            if (jumpto.backend_panel) {
                this.login_panel.classList.remove("active");
                this.backend_panel.classList.add("active");
                this.header_btn_more_right.textContent = `æœåŠ¡ç®¡ç†å‘˜`;

                this.check_if_need_hide_aside();
            }
        }


        /*
        * ä»é¦–é¡µæ‰“å¼€åº”ç”¨
        * */
        switch_apps(header_btn) {
            for (const headerBtn of this.header_btns) {
                if (headerBtn === this.header_btn_startpage) continue;
                headerBtn.classList.add("hidden");
            }
            header_btn.classList.remove("hidden");
            this.switch_panel_btn({target: header_btn,});
        }


        /*
        * å³ä¾§é¡µé¢
        * */
        current_content_page = null;

        switch_content_page(event, li_item) {
            let li = li_item ? li_item : event.target;
            const panel = li.closest("section");

            this.close_content_page();

            this.current_content_page = new li.bindmap.pagetype(this, panel, li);
            this.current_content_page.open_page();

            this.check_if_need_hide_aside();
        }

        close_content_page() {
            if (this.current_content_page) this.current_content_page.close_page();
            this.current_content_page = null;

            this.check_if_need_hide_aside();
        }

        /*
        * å°å±å•é¢
        * */
        check_if_need_hide_aside(left, right) {
            const cur = this.current_panel();
            if (cur && cur.wrapper.aside_right) {
                left = cur.wrapper.aside_left_wrap;
                right = cur.wrapper.aside_right;
            } else {
                return;
            }

            const width = document.body.clientWidth;
            // console.log(width);
            if (width < 767 && _isMobileDevice) {
                if (this.current_content_page && this.current_content_page.aside_right === right) {
                    left.classList.add("hidden");
                    right.classList.remove("hidden");
                } else {
                    left.classList.remove("hidden");
                    right.classList.add("hidden");
                    left.classList.add("fullscreen");
                }
            } else {
                left.classList.remove("hidden");
                right.classList.remove("hidden");
                left.classList.remove("fullscreen");
            }
        }

    }

    window.addEventListener('resize', (event) => {
        checkin.check_if_need_hide_aside();
    });

    function handlejumpto() {
        if (jumpto.appname === appnames.drive) {
            checkin.apps_item_drive.click();
        } else if (jumpto.appname === appnames.chat) {
            checkin.apps_item_chat.click();
        }
        window.addEventListener('popstate', (event) => {
            console.log('popstate:', event.state);
        });

    }

    function initialize() {
        // è®¿é—®çš„æ˜¯adminè·¯å¾„
        if (jumpto.backend_panel) {
            document.title = `${document.title} - ç®¡ç†`;
            // checkin.header_btn_backend.classList.remove("hidden");
            // checkin.header_btn_backend.classList.add("transparent");
            // checkin.header_btn_backend.classList.add("no-width");
            // checkin.header_btn_backend.classList.add("no-height");
            // checkin.header_btn_backend.innerHTML = "";
            for (const headerBtn of checkin.header_btns) headerBtn.classList.add("hidden");

            checkin.header_btn_more_left.classList.add("hidden");
            // checkin.header_btn_more_right.classList.add("hidden");

            checkin.login_tip_admin.classList.remove("hidden");
            checkin.login_input_account_label.classList.add("hidden");
        } else {
            checkin.header_btn_tostartpage.classList.add("hidden");

            checkin.login_tip_user.classList.remove("hidden");
        }
        checkin.header_btn_tostartpage.classList.remove("initiation_hidden");

        // åˆ‡æ¢åˆ°é»˜è®¤é¢æ¿
        let switched = false;
        if (jumpto.backend_panel) {
            if (logged_admin) {
                switched = true;
                checkin.switch_panel_to_backend();
            }
        } else {
            if (logged_user) {
                switched = true;

                // checkin.header_btn_mail.classList.remove("hidden");
                // checkin.header_btn_drive.classList.remove("hidden");
                // checkin.header_btn_chat.classList.remove("hidden");
                // checkin.header_btn_forum.classList.remove("hidden");
                checkin.header_btn_startpage.classList.remove("hidden");

                floatball.show();

                checkin.restore_selected_panel_id();

                handlejumpto();
            }
        }
        if (!switched)
            checkin.switch_panel_to_login();

    }

    const checkin = new Checkin();
    checkin.apply_theme();
    initialize();


</script>


<script>
const textarea = document.querySelector('.chat-session-inputarea-textarea');
textarea.addEventListener('input', () => {
    textarea.style.height = 'auto';                     // é‡ç½®é«˜åº¦
    textarea.style.height = textarea.scrollHeight + 'px'; // æ ¹æ®å†…å®¹è‡ªé€‚åº”é«˜åº¦
});
</script>
<!---->
<!-- ChatGPT æ‚¬æµ®æŒ‰é’® -->
<a href="https://chat.openai.com/"
   target="_blank"
   class="chatgpt-float">
  ğŸ¤– ChatGPT
</a>
<div id="chat-toast-container"></div>

</body>

</html>
